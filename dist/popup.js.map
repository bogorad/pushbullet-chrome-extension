{
  "version": 3,
  "sources": ["../src/lib/ui/dom.ts", "../src/infrastructure/storage/storage.repository.ts", "../src/popup/index.ts"],
  "sourcesContent": ["/**\n * DOM manipulation utilities for UI pages\n */\n\n/**\n * Safely get an element by ID with type checking\n */\nexport function getElementById<T extends HTMLElement>(id: string): T {\n  const element = document.getElementById(id);\n  if (!element) {\n    throw new Error(`Element with id \"${id}\" not found`);\n  }\n  return element as T;\n}\n\n/**\n * Safely query selector with type checking\n */\nexport function querySelector<T extends Element>(selector: string): T {\n  const element = document.querySelector(selector);\n  if (!element) {\n    throw new Error(`Element with selector \"${selector}\" not found`);\n  }\n  return element as T;\n}\n\n/**\n * Show an element\n */\nexport function show(element: HTMLElement): void {\n  element.style.display = '';\n}\n\n/**\n * Hide an element\n */\nexport function hide(element: HTMLElement): void {\n  element.style.display = 'none';\n}\n\n/**\n * Toggle element visibility\n */\nexport function toggle(element: HTMLElement): void {\n  if (element.style.display === 'none') {\n    show(element);\n  } else {\n    hide(element);\n  }\n}\n\n/**\n * Set text content safely\n */\nexport function setText(element: HTMLElement, text: string): void {\n  element.textContent = text;\n}\n\n/**\n * Set HTML content safely (sanitized)\n */\nexport function setHTML(element: HTMLElement, html: string): void {\n  // Basic sanitization - remove script tags\n  const sanitized = html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  element.innerHTML = sanitized;\n}\n\n/**\n * Add event listener with type safety\n */\nexport function on<K extends keyof HTMLElementEventMap>(\n  element: HTMLElement,\n  event: K,\n  handler: (this: HTMLElement, ev: HTMLElementEventMap[K]) => void\n): void {\n  element.addEventListener(event, handler);\n}\n\n/**\n * Format timestamp for display\n */\nexport function formatTimestamp(date: Date): string {\n  const now = new Date();\n  const diff = now.getTime() - date.getTime();\n  const seconds = Math.floor(diff / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (seconds < 60) {\n    return 'just now';\n  } else if (minutes < 60) {\n    return `${minutes}m ago`;\n  } else if (hours < 24) {\n    return `${hours}h ago`;\n  } else if (days < 7) {\n    return `${days}d ago`;\n  } else {\n    return date.toLocaleDateString();\n  }\n}\n\n/**\n * Show status message\n */\nexport function showStatus(element: HTMLElement, message: string, type: 'success' | 'error' | 'info' = 'info'): void {\n  element.textContent = message;\n  element.className = `status-message status-${type}`;\n  show(element);\n  \n  // Auto-hide after 3 seconds\n  setTimeout(() => {\n    hide(element);\n  }, 3000);\n}\n\n/**\n * Clear all children of an element\n */\nexport function clearChildren(element: HTMLElement): void {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\n\n", "/**\n * Storage Repository Pattern\n * \n * This module implements the Repository Pattern for storage operations.\n * It abstracts away the chrome.storage API, making the code more testable\n * and maintainable.\n * \n * Benefits:\n * - Testability: Easy to mock storage in tests\n * - Maintainability: Storage logic centralized in one place\n * - Clarity: Simple, clear API for storage operations\n */\n\n/**\n * Storage Repository Interface\n * \n * This interface defines the contract for storage operations.\n * Any implementation must provide these methods.\n */\nexport interface StorageRepository {\n  // API Key\n  getApiKey(): Promise<string | null>;\n  setApiKey(key: string | null): Promise<void>;\n\n  // Device Information\n  getDeviceIden(): Promise<string | null>;\n  setDeviceIden(iden: string | null): Promise<void>;\n\n  getDeviceNickname(): Promise<string | null>;\n  setDeviceNickname(nickname: string): Promise<void>;\n\n  // Settings\n  getAutoOpenLinks(): Promise<boolean>;\n  setAutoOpenLinks(enabled: boolean): Promise<void>;\n\n  getNotificationTimeout(): Promise<number>;\n  setNotificationTimeout(timeout: number): Promise<void>;\n\n  // Encryption\n  getEncryptionPassword(): Promise<string | null>;\n  setEncryptionPassword(password: string | null): Promise<void>;\n\n  // UI State\n  getScrollToRecentPushes(): Promise<boolean>;\n  setScrollToRecentPushes(scroll: boolean): Promise<void>;\n  removeScrollToRecentPushes(): Promise<void>;\n\n  // Device Registration\n  getDeviceRegistrationInProgress(): Promise<boolean>;\n  setDeviceRegistrationInProgress(inProgress: boolean): Promise<void>;\n\n  // Last Modified Cutoff\n  getLastModifiedCutoff(): Promise<number | null>;\n  setLastModifiedCutoff(value: number): Promise<void>;\n  removeLastModifiedCutoff(): Promise<void>;\n\n  // Auto Open Links on Reconnect\n  getLastAutoOpenCutoff(): Promise<number | null>;\n  setLastAutoOpenCutoff(value: number): Promise<void>;\n  getAutoOpenLinksOnReconnect(): Promise<boolean>;\n  setAutoOpenLinksOnReconnect(value: boolean): Promise<void>;\n  getMaxAutoOpenPerReconnect(): Promise<number>;\n  setMaxAutoOpenPerReconnect(value: number): Promise<void>;\n  getDismissAfterAutoOpen(): Promise<boolean>;\n  setDismissAfterAutoOpen(value: boolean): Promise<void>;\n\n  // User Info Cache\n  getUserInfoCache(): Promise<any | null>;\n  setUserInfoCache(value: any): Promise<void>;\n\n  // Bulk Operations\n  clear(): Promise<void>;\n  remove(keys: string[]): Promise<void>;\n\n  // Diagnostics\n  getAutoOpenDebugSnapshot(): Promise<{\n    lastAutoOpenCutoff: number;\n    lastModifiedCutoff: number;\n    mruCount: number;\n    maxOpenedCreated: number;\n  }>;\n}\n\n/**\n * Chrome Storage Repository Implementation\n * \n * This class implements the StorageRepository interface using the\n * chrome.storage API. It handles the promisification of the callback-based\n * chrome.storage API.\n */\nexport class ChromeStorageRepository implements StorageRepository {\n  /**\n   * Get API Key from local storage\n   * Security: API keys are stored in local storage (not synced) to prevent\n   * exposure through Chrome's sync infrastructure\n   */\n  async getApiKey(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['apiKey']);\n    return result.apiKey || null;\n  }\n\n  /**\n   * Set API Key in local storage\n   * Security: API keys are stored in local storage (not synced) to prevent\n   * exposure through Chrome's sync infrastructure\n   */\n  async setApiKey(key: string | null): Promise<void> {\n    if (key === null) {\n      await chrome.storage.local.remove(['apiKey']);\n    } else {\n      await chrome.storage.local.set({ apiKey: key });\n    }\n  }\n\n  /**\n   * Get Device Identifier from local storage\n   */\n  async getDeviceIden(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['deviceIden']);\n    return result.deviceIden || null;\n  }\n\n  /**\n   * Set Device Identifier in local storage\n   */\n  async setDeviceIden(iden: string | null): Promise<void> {\n    if (iden === null) {\n      await chrome.storage.local.remove(['deviceIden']);\n    } else {\n      await chrome.storage.local.set({ deviceIden: iden });\n    }\n  }\n\n  /**\n    * Get Device Nickname from local storage\n    */\n  async getDeviceNickname(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['deviceNickname']);\n    return result.deviceNickname || null;\n  }\n\n  /**\n    * Set Device Nickname in local storage\n    */\n  async setDeviceNickname(nickname: string): Promise<void> {\n    await chrome.storage.local.set({ deviceNickname: nickname });\n  }\n\n  /**\n   * Get Auto Open Links setting from sync storage\n   */\n  async getAutoOpenLinks(): Promise<boolean> {\n    const result = await chrome.storage.sync.get(['autoOpenLinks']);\n    return result.autoOpenLinks !== undefined ? result.autoOpenLinks : false;\n  }\n\n  /**\n   * Set Auto Open Links setting in sync storage\n   */\n  async setAutoOpenLinks(enabled: boolean): Promise<void> {\n    await chrome.storage.sync.set({ autoOpenLinks: enabled });\n  }\n\n  /**\n   * Get Notification Timeout from sync storage\n   */\n  async getNotificationTimeout(): Promise<number> {\n    const result = await chrome.storage.sync.get(['notificationTimeout']);\n    return result.notificationTimeout !== undefined ? result.notificationTimeout : 5000;\n  }\n\n  /**\n   * Set Notification Timeout in sync storage\n   */\n  async setNotificationTimeout(timeout: number): Promise<void> {\n    await chrome.storage.sync.set({ notificationTimeout: timeout });\n  }\n\n  /**\n   * Get Encryption Password from local storage\n   */\n  async getEncryptionPassword(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['encryptionPassword']);\n    return result.encryptionPassword || null;\n  }\n\n  /**\n   * Set Encryption Password in local storage\n   */\n  async setEncryptionPassword(password: string | null): Promise<void> {\n    if (password === null) {\n      await chrome.storage.local.remove(['encryptionPassword']);\n    } else {\n      await chrome.storage.local.set({ encryptionPassword: password });\n    }\n  }\n\n  /**\n   * Get Scroll to Recent Pushes flag from local storage\n   */\n  async getScrollToRecentPushes(): Promise<boolean> {\n    const result = await chrome.storage.local.get(['scrollToRecentPushes']);\n    return result.scrollToRecentPushes || false;\n  }\n\n  /**\n   * Set Scroll to Recent Pushes flag in local storage\n   */\n  async setScrollToRecentPushes(scroll: boolean): Promise<void> {\n    await chrome.storage.local.set({ scrollToRecentPushes: scroll });\n  }\n\n  /**\n   * Remove Scroll to Recent Pushes flag from local storage\n   */\n  async removeScrollToRecentPushes(): Promise<void> {\n    await chrome.storage.local.remove(['scrollToRecentPushes']);\n  }\n\n  /**\n   * Get Device Registration In Progress flag from local storage\n   */\n  async getDeviceRegistrationInProgress(): Promise<boolean> {\n    const result = await chrome.storage.local.get(['deviceRegistrationInProgress']);\n    return result.deviceRegistrationInProgress || false;\n  }\n\n  /**\n   * Set Device Registration In Progress flag in local storage\n   */\n  async setDeviceRegistrationInProgress(inProgress: boolean): Promise<void> {\n    await chrome.storage.local.set({ deviceRegistrationInProgress: inProgress });\n  }\n\n  /**\n   * Get Last Modified Cutoff from local storage\n   */\n  async getLastModifiedCutoff(): Promise<number | null> {\n    const result = await chrome.storage.local.get(['lastModifiedCutoff']);\n    const cutoff = result.lastModifiedCutoff;\n    return typeof cutoff === 'number' ? cutoff : null;\n  }\n\n  /**\n   * Set Last Modified Cutoff in local storage\n   */\n  async setLastModifiedCutoff(value: number): Promise<void> {\n    if (value === 0) {\n      console.warn('Storage: Setting lastModifiedCutoff to 0 - ensure this is via unsafe setter');\n    }\n    await chrome.storage.local.set({ lastModifiedCutoff: value });\n  }\n\n  /**\n   * Remove Last Modified Cutoff from local storage\n   * Used during invalid cursor recovery\n   */\n  async removeLastModifiedCutoff(): Promise<void> {\n    await chrome.storage.local.remove('lastModifiedCutoff');\n  }\n\n  /**\n   * Get Last Auto Open Cutoff from local storage\n   */\n  async getLastAutoOpenCutoff(): Promise<number | null> {\n    const result = await chrome.storage.local.get(['lastAutoOpenCutoff']);\n    const v = result.lastAutoOpenCutoff;\n    return typeof v === 'number' ? v : null;\n  }\n\n  /**\n   * Set Last Auto Open Cutoff in local storage\n   */\n  async setLastAutoOpenCutoff(value: number): Promise<void> {\n    await chrome.storage.local.set({ lastAutoOpenCutoff: value });\n  }\n\n  /**\n   * Get Auto Open Links on Reconnect setting from local storage\n   */\n  async getAutoOpenLinksOnReconnect(): Promise<boolean> {\n    const result = await chrome.storage.local.get(['autoOpenLinksOnReconnect']);\n    const v = result.autoOpenLinksOnReconnect;\n    return typeof v === 'boolean' ? v : false;\n  }\n\n  /**\n   * Set Auto Open Links on Reconnect setting in local storage\n   */\n  async setAutoOpenLinksOnReconnect(value: boolean): Promise<void> {\n    await chrome.storage.local.set({ autoOpenLinksOnReconnect: value });\n  }\n\n  /**\n   * Get Max Auto Open Per Reconnect from local storage\n   */\n  async getMaxAutoOpenPerReconnect(): Promise<number> {\n    const result = await chrome.storage.local.get(['maxAutoOpenPerReconnect']);\n    const v = result.maxAutoOpenPerReconnect;\n    return typeof v === 'number' && v > 0 ? v : 5;\n  }\n\n  /**\n   * Set Max Auto Open Per Reconnect in local storage\n   */\n  async setMaxAutoOpenPerReconnect(value: number): Promise<void> {\n    await chrome.storage.local.set({ maxAutoOpenPerReconnect: value });\n  }\n\n  /**\n   * Get Dismiss After Auto Open setting from local storage\n   */\n  async getDismissAfterAutoOpen(): Promise<boolean> {\n    const result = await chrome.storage.local.get(['dismissAfterAutoOpen']);\n    return Boolean(result.dismissAfterAutoOpen);\n  }\n\n  /**\n   * Set Dismiss After Auto Open setting in local storage\n   */\n  async setDismissAfterAutoOpen(value: boolean): Promise<void> {\n    await chrome.storage.local.set({ dismissAfterAutoOpen: value });\n  }\n\n  /**\n   * Get User Info Cache from local storage\n   */\n  async getUserInfoCache(): Promise<any | null> {\n    const result = await chrome.storage.local.get(['userInfoCache']);\n    return result.userInfoCache || null;\n  }\n\n  /**\n   * Set User Info Cache in local storage\n   */\n  async setUserInfoCache(value: any): Promise<void> {\n    await chrome.storage.local.set({ userInfoCache: value });\n  }\n\n  /**\n   * Clear all storage (both sync and local)\n   */\n  async clear(): Promise<void> {\n    await Promise.all([\n      chrome.storage.sync.clear(),\n      chrome.storage.local.clear()\n    ]);\n  }\n\n  /**\n   * Remove specific keys from storage\n   * Removes from both sync and local storage\n   */\n  async remove(keys: string[]): Promise<void> {\n    await Promise.all([\n      chrome.storage.sync.remove(keys),\n      chrome.storage.local.remove(keys)\n    ]);\n  }\n\n  /**\n   * Get Auto Open Debug Snapshot for diagnostics\n   */\n  async getAutoOpenDebugSnapshot(): Promise<{\n    lastAutoOpenCutoff: number;\n    lastModifiedCutoff: number;\n    mruCount: number;\n    maxOpenedCreated: number;\n  }> {\n    const { lastAutoOpenCutoff = 0 } =\n      await chrome.storage.local.get('lastAutoOpenCutoff');\n    const { lastModifiedCutoff = 0 } =\n      await chrome.storage.local.get('lastModifiedCutoff');\n    const raw = await chrome.storage.local.get('openedPushMRU');\n    const mru = raw.openedPushMRU as\n      | { idens?: string[]; maxOpenedCreated?: number }\n      | undefined;\n    return {\n      lastAutoOpenCutoff:\n        typeof lastAutoOpenCutoff === 'number' ? lastAutoOpenCutoff : 0,\n      lastModifiedCutoff:\n        typeof lastModifiedCutoff === 'number' ? lastModifiedCutoff : 0,\n      mruCount: Array.isArray(mru?.idens) ? mru!.idens!.length : 0,\n      maxOpenedCreated:\n        typeof mru?.maxOpenedCreated === 'number' ? mru!.maxOpenedCreated! : 0,\n    };\n  }\n}\n\n/**\n * Create a singleton instance of the storage repository\n * This ensures we have a single point of access throughout the application\n */\nexport const storageRepository = new ChromeStorageRepository();\n\n", "/**\n * Popup page - Full TypeScript implementation\n */\n\nimport type { Push, Device, User, Chat, SessionDataResponse } from \"../types/domain\";\nimport { MessageAction } from \"../types/domain\";\nimport {\n  getElementById,\n} from \"../lib/ui/dom\";\nimport { storageRepository } from \"../infrastructure/storage/storage.repository\";\n\n// Response type for API key save operations\ntype SaveKeyResponse = SessionDataResponse | { success: false; error?: string };\n\n// API URLs - MOSTLY REMOVED\n// ARCHITECTURAL CHANGE: Popup no longer makes direct API calls\n// All API communication is centralized in the background script\n//\n// EXCEPTION: File upload still requires direct API access because:\n// - FormData cannot be serialized through chrome.runtime.sendMessage\n// - File upload involves two steps: upload-request + S3 upload\n// - The final push creation is still delegated to background\n//\n// Removed URLs (now handled by background):\n// - USER_INFO_URL (user info fetched by background)\n// - DEVICES_URL (devices fetched by background)\n// - PUSHES_URL (pushes sent via background)\n// - WEBSOCKET_URL (WebSocket managed by background)\n\n// Type definitions\ninterface SessionData {\n  isAuthenticated: boolean;\n  userInfo: User | null;\n  devices: Device[];\n  recentPushes: Push[];\n  chats: Chat[]; // \u2190 ADD THIS\n  autoOpenLinks: boolean;\n  websocketConnected?: boolean;\n  deviceNickname: string;\n  state?: string; // State machine state\n}\n\ntype PushType = \"note\" | \"link\" | \"file\";\n\ninterface PushData {\n  type: PushType;\n  device_iden?: string;\n  email?: string;\n  source_device_iden?: string;\n  title?: string;\n  body?: string;\n  url?: string;\n  file_name?: string;\n  file_type?: string;\n  file_url?: string;\n}\n\ninterface UploadRequestResponse {\n  file_name: string;\n  file_type: string;\n  file_url: string;\n  upload_url: string;\n  data: Record<string, string>;\n}\n\n// DOM elements\nconst loadingSection = getElementById<HTMLDivElement>(\"loading-section\");\nconst loginSection = getElementById<HTMLDivElement>(\"login-section\");\nconst mainSection = getElementById<HTMLDivElement>(\"main-section\");\nconst errorStatePanel = getElementById<HTMLDivElement>(\"error-state-panel\");\nconst manualReconnectBtn = getElementById<HTMLButtonElement>(\"manual-reconnect-btn\");\nconst apiKeyInput = getElementById<HTMLInputElement>(\"api-key\");\nconst deviceNicknameInput = getElementById<HTMLInputElement>(\"device-nickname\");\nconst saveApiKeyButton = getElementById<HTMLButtonElement>(\"save-api-key\");\nconst logoutButton = getElementById<HTMLButtonElement>(\"logout\");\nconst userImage = getElementById<HTMLImageElement>(\"user-image\");\nconst userName = getElementById<HTMLSpanElement>(\"user-name\");\n// Connection indicator removed - using badge instead\nconst pushTypeNoteBtn = getElementById<HTMLButtonElement>(\"push-type-note\");\nconst pushTypeLinkBtn = getElementById<HTMLButtonElement>(\"push-type-link\");\nconst pushTypeFileBtn = getElementById<HTMLButtonElement>(\"push-type-file\");\nconst noteForm = getElementById<HTMLDivElement>(\"note-form\");\nconst linkForm = getElementById<HTMLDivElement>(\"link-form\");\nconst fileForm = getElementById<HTMLDivElement>(\"file-form\");\nconst fileInput = getElementById<HTMLInputElement>(\"file-input\");\nconst fileSelected = getElementById<HTMLDivElement>(\"file-selected\");\nconst fileName = getElementById<HTMLSpanElement>(\"file-name\");\nconst fileSize = getElementById<HTMLSpanElement>(\"file-size\");\nconst noteTitleInput = getElementById<HTMLInputElement>(\"note-title\");\nconst noteBodyInput = getElementById<HTMLTextAreaElement>(\"note-body\");\nconst linkTitleInput = getElementById<HTMLInputElement>(\"link-title\");\nconst linkUrlInput = getElementById<HTMLInputElement>(\"link-url\");\nconst linkBodyInput = getElementById<HTMLTextAreaElement>(\"link-body\");\nconst targetDeviceSelect = getElementById<HTMLSelectElement>(\"target-device\");\nconst sendPushButton = getElementById<HTMLButtonElement>(\"send-push\");\nconst pushesList = getElementById<HTMLDivElement>(\"pushes-list\");\nconst statusMessage = getElementById<HTMLDivElement>(\"status-message\");\nconst openSettingsBtn = getElementById<HTMLButtonElement>(\"open-settings\");\nconst openDebugDashboardBtn = getElementById<HTMLButtonElement>(\n  \"open-debug-dashboard\",\n);\n\n// State variables\nlet deviceNickname = \"Chrome\";\nconst devices: Device[] = [];\nlet currentPushType: PushType = \"note\";\n// websocket variable removed - background script manages the single WebSocket connection\n\n/**\n * Initialize popup\n */\nfunction init(): void {\n  console.log(\"Popup initializing\");\n  setupEventListeners();\n  checkStorageForApiKey();\n}\n\n/**\n * Initialize from session data (from background)\n */\nasync function initializeFromSessionData(response: SessionData): Promise<void> {\n  if (!response.isAuthenticated) {\n    showSection(\"login\");\n    return;\n  }\n\n  // Check if extension is in error state\n  if (response.state === 'error') {\n    showSection(\"error\");\n    return;\n  }\n\n  // Update device nickname\n  deviceNickname = response.deviceNickname;\n  console.log(\"Device nickname:\", deviceNickname);\n\n  // Update user info\n  if (response.userInfo) {\n    updateUserInfo(response.userInfo);\n  }\n\n  // Populate device dropdown\n  populateDeviceDropdown(response.devices, response.chats);\n\n  // Display pushes\n  displayPushes(response.recentPushes);\n\n  // Get version from manifest\n  const manifest = chrome.runtime.getManifest();\n  const version = manifest.version;\n\n  // Update the \"Send a Push\" heading with version\n  const sendPushHeading = document.getElementById('send-push-heading');\n  if (sendPushHeading) {\n    sendPushHeading.innerHTML = `Send a Push <span class=\"version-text\">(v.${version})</span>`;\n  }\n\n  // Show main section\n  showSection(\"main\");\n\n  // Connection status is now shown via badge icon (no UI indicator needed)\n  // WebSocket connection is managed by background script - popup receives updates via chrome.runtime.onMessage\n}\n\n/**\n * Check storage for API key and get session data from background\n * ARCHITECTURAL CHANGE: Popup no longer makes direct API calls.\n * All data is fetched from background script's session cache.\n */\nfunction checkStorageForApiKey(): void {\n  console.log(\"Requesting session data from background\");\n  showSection(\"loading\");\n\n  // Request session data from background script (single source of truth)\n  chrome.runtime.sendMessage(\n    { action: MessageAction.GET_SESSION_DATA },\n    async (response: SessionData) => {\n      if (chrome.runtime.lastError) {\n        console.error(\"Error getting session data:\", chrome.runtime.lastError);\n        showSection(\"login\");\n        return;\n      }\n\n      if (response.isAuthenticated) {\n        // Initialize from background's cached data\n        await initializeFromSessionData(response);\n\n        // Check if we should scroll to recent pushes\n        const shouldScroll = await storageRepository.getScrollToRecentPushes();\n        if (shouldScroll) {\n          await storageRepository.removeScrollToRecentPushes();\n          setTimeout(() => {\n            scrollToRecentPushes();\n          }, 100);\n        }\n      } else {\n        showSection(\"login\");\n      }\n    },\n  );\n}\n\n/**\n * Show section\n */\nfunction showSection(section: \"loading\" | \"login\" | \"main\" | \"error\"): void {\n  console.log(\"Showing section:\", section);\n  loadingSection.style.display = section === \"loading\" ? \"flex\" : \"none\";\n  loginSection.style.display = section === \"login\" ? \"block\" : \"none\";\n  mainSection.style.display = section === \"main\" ? \"block\" : \"none\";\n  errorStatePanel.style.display = section === \"error\" ? \"block\" : \"none\";\n}\n\n/**\n * Handles global keyboard shortcuts for the popup.\n * This function responds to hotkeys like N, L, A for switching modes,\n * and Ctrl+Enter for instant send.\n *\n * @param event - The keyboard event\n */\nfunction handleGlobalHotkeys(event: KeyboardEvent): void {\n  // IMPORTANT: Get the element that's currently focused\n  const target = event.target as HTMLElement;\n  const isTypingInInput =\n    target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement;\n\n  // === HANDLE CTRL+ENTER (works from ANY field) ===\n  if (event.ctrlKey && event.key === \"Enter\") {\n    event.preventDefault(); // Stop the browser's default behavior\n    sendPush(); // Call the existing send function\n    return; // Exit early - we're done\n  }\n\n  // === PREVENT HOTKEYS WHILE TYPING ===\n  // If user is typing in a text field, don't trigger mode-switching hotkeys\n  // (This prevents \"n\" from switching to Note mode while typing \"connect\")\n  if (isTypingInInput) {\n    return; // Exit - let the user type normally\n  }\n\n  // === MODE-SWITCHING HOTKEYS ===\n  // Convert key to lowercase so both \"N\" and \"n\" work\n  const key = event.key.toLowerCase();\n\n  switch (key) {\n  case \"n\":\n    // Switch to Note mode and focus the title input\n    event.preventDefault();\n    togglePushType(\"note\");\n    // Wait a tiny bit for the form to show, then focus\n    setTimeout(() => noteTitleInput.focus(), 50);\n    break;\n\n  case \"l\":\n    // Switch to Link mode and focus the COMMENT field (URL is auto-filled)\n    event.preventDefault();\n    togglePushType(\"link\");\n    // Wait for togglePushType to finish auto-filling the URL\n    setTimeout(() => linkBodyInput.focus(), 100);\n    break;\n\n  case \"a\":\n    // Switch to Attach mode and open file picker\n    event.preventDefault();\n    togglePushType(\"file\");\n    // Trigger the file input's click to open file picker dialog\n    setTimeout(() => fileInput.click(), 50);\n    break;\n\n  case \"s\":\n    // Open Settings page\n    event.preventDefault();\n    chrome.runtime.openOptionsPage();\n    break;\n\n  case \"d\":\n    // Open Debug Dashboard\n    event.preventDefault();\n    chrome.tabs.create({\n      url: chrome.runtime.getURL(\"debug-dashboard.html\"),\n    });\n    break;\n\n  case \"p\":\n    // Open Pushbullet website\n    event.preventDefault();\n    chrome.tabs.create({\n      url: \"https://www.pushbullet.com\",\n    });\n    break;\n\n    // ESC is handled by Chrome automatically - it closes popups by default\n  }\n}\n\n/**\n * Set up event listeners\n */\nfunction setupEventListeners(): void {\n  // Save API key button\n  saveApiKeyButton.addEventListener(\"click\", saveApiKey);\n\n  // API key input - save on Enter\n  apiKeyInput.addEventListener(\"keyup\", (event) => {\n    if (event.key === \"Enter\") {\n      saveApiKey();\n    }\n  });\n\n  // Device nickname input - save on Enter\n  deviceNicknameInput.addEventListener(\"keyup\", (event) => {\n    if (event.key === \"Enter\") {\n      saveApiKey();\n    }\n  });\n\n  // Logout button\n  logoutButton.addEventListener(\"click\", logout);\n\n  // Push type buttons\n  pushTypeNoteBtn.addEventListener(\"click\", () => togglePushType(\"note\"));\n  pushTypeLinkBtn.addEventListener(\"click\", () => togglePushType(\"link\"));\n  pushTypeFileBtn.addEventListener(\"click\", () => togglePushType(\"file\"));\n\n  // File input\n  fileInput.addEventListener(\"change\", handleFileSelect);\n\n  // Send push button\n  sendPushButton.addEventListener(\"click\", sendPush);\n\n  // Open settings\n  openSettingsBtn.addEventListener(\"click\", () => {\n    chrome.runtime.openOptionsPage();\n  });\n\n  // Open debug dashboard\n  openDebugDashboardBtn.addEventListener(\"click\", () => {\n    chrome.tabs.create({\n      url: chrome.runtime.getURL(\"debug-dashboard.html\"),\n    });\n  });\n\n  // Manual reconnect button\n  manualReconnectBtn.addEventListener('click', async () => {\n    // Send message to background to attempt reconnection\n    await chrome.runtime.sendMessage({\n      action: 'attemptReconnect'\n    });\n\n    // Close popup\n    window.close();\n  });\n\n  // === NEW CODE: Global keyboard shortcuts ===\n  document.addEventListener(\"keydown\", handleGlobalHotkeys);\n  // === END NEW CODE ===\n}\n\n/**\n * Save API key\n * ARCHITECTURAL CHANGE: Delegates API key validation to background script\n */\nasync function saveApiKey(): Promise<void> {\n  const newApiKey = apiKeyInput.value.trim();\n  const newNickname = deviceNicknameInput.value.trim() || \"Chrome\";\n\n  if (!newApiKey) {\n    showStatus(\"Please enter an Access Token.\", \"error\");\n    return;\n  }\n\n  showSection(\"loading\");\n\n  try {\n    // Save to storage repository\n    await storageRepository.setApiKey(newApiKey);\n    await storageRepository.setDeviceNickname(newNickname);\n\n    deviceNickname = newNickname;\n\n    // Notify background to validate and initialize\n    // Background will respond AFTER initialization is complete (no setTimeout needed!)\n    chrome.runtime.sendMessage(\n      {\n        action: MessageAction.API_KEY_CHANGED,\n        apiKey: newApiKey,\n        deviceNickname: newNickname,\n      },\n      (response: SaveKeyResponse) => {\n        if (chrome.runtime.lastError) {\n          console.error(\n            \"Error notifying background:\",\n            chrome.runtime.lastError,\n          );\n          showStatus(\"Error: Could not connect to background script\", \"error\");\n          showSection(\"login\");\n          return;\n        }\n\n        // Type guard: Check if response is a successful session object\n        if ('isAuthenticated' in response) {\n          // Response is SessionData\n          if (response.isAuthenticated) {\n            initializeFromSessionData(response);\n          } else {\n            showStatus(\"Invalid Access Token\", \"error\");\n            showSection(\"login\");\n          }\n        } else {\n          // Response is error object\n          showStatus(\n            `Error: ${response.error || \"Invalid Access Token\"}`,\n            \"error\",\n          );\n          showSection(\"login\");\n        }\n      },\n    );\n  } catch (error) {\n    showStatus(`Error: ${(error as Error).message}`, \"error\");\n    showSection(\"login\");\n  }\n}\n\n/**\n * Logout\n */\nasync function logout(): Promise<void> {\n  // WebSocket disconnection is handled by background script\n  await storageRepository.setApiKey(null);\n  await storageRepository.setDeviceIden(null);\n\n  // Notify background script to disconnect WebSocket\n  chrome.runtime.sendMessage({ action: MessageAction.LOGOUT }).catch((error) => {\n    console.warn(\"Could not notify background of logout:\", error.message);\n  });\n\n  showSection(\"login\");\n  apiKeyInput.value = \"\";\n  deviceNicknameInput.value = \"\";\n}\n\n/**\n * REMOVED: initializeAuthenticated()\n *\n * This function previously made direct API calls to fetch user info, devices, and pushes.\n * It has been removed as part of the architectural refactoring to centralize all API\n * communication in the background script.\n *\n * The popup now uses initializeFromSessionData() which receives data from the background\n * script's session cache via chrome.runtime.sendMessage({ action: 'getSessionData' }).\n */\n\n/**\n * REMOVED: fetchUserInfo(), fetchDevices(), fetchRecentPushes()\n *\n * These functions previously made direct API calls to the Pushbullet API.\n * They have been removed as part of the architectural refactoring to centralize\n * all API communication in the background script.\n *\n * ARCHITECTURAL CHANGE:\n * - The popup is now a \"dumb client\" that only displays data\n * - All data comes from the background script's session cache\n * - The background script is the single source of truth for API state\n * - This eliminates redundant API calls every time the popup opens\n * - Improves efficiency and prevents state desynchronization\n *\n * Data flow:\n * 1. Popup opens \u2192 sends getSessionData message to background\n * 2. Background responds with cached session data\n * 3. Popup displays the data using initializeFromSessionData()\n * 4. Background proactively sends pushesUpdated when new data arrives\n */\n\n/**\n * REMOVED: connectWebSocket() and disconnectWebSocket()\n *\n * The popup no longer maintains its own WebSocket connection.\n * The background service worker manages a single, persistent WebSocket connection\n * and sends push updates to the popup via chrome.runtime.sendMessage with action 'pushesUpdated'.\n *\n * This architectural change:\n * - Eliminates dual state (popup and background having separate connections)\n * - Reduces resource consumption (only one WebSocket connection)\n * - Ensures connection persists when popup is closed\n * - Makes background script the single source of truth for WebSocket state\n */\n\n/**\n * Update user info\n */\nfunction updateUserInfo(userInfo: User): void {\n  userName.textContent = userInfo.name || userInfo.email || '';\n\n  if (userInfo.image_url) {\n    userImage.src = userInfo.image_url;\n    userImage.style.display = \"block\";\n  } else {\n    userImage.style.display = \"none\";\n  }\n}\n\n/**\n * Populate device dropdown\n */\nfunction populateDeviceDropdown(devicesList: Device[], chatsList?: Chat[]): void {\n  const devicesToUse = devicesList || devices;\n\n  // Clear existing options except 'All Devices'\n  while (targetDeviceSelect.options.length > 1) {\n    targetDeviceSelect.remove(1);\n  }\n\n  // Add devices\n  devicesToUse.forEach((device) => {\n    const option = document.createElement(\"option\");\n    option.value = device.iden;\n    option.textContent = device.nickname || device.model || \"Unknown Device\";\n    targetDeviceSelect.appendChild(option);\n  });\n\n  // ========== ADD THIS ENTIRE SECTION ==========\n  // Add friends/contacts to dropdown\n  const chatsToUse = chatsList || [];\n  if (chatsToUse && chatsToUse.length > 0) {\n    // Add visual separator\n    const friendSeparator = document.createElement(\"option\");\n    friendSeparator.disabled = true;\n    friendSeparator.textContent = \"--- Friends ---\";\n    targetDeviceSelect.appendChild(friendSeparator);\n\n    // Add each friend\n    chatsToUse.forEach((chat) => {\n      const option = document.createElement(\"option\");\n\n      // Value: \"friend:<email>\" - lets us detect friend selection\n      option.value = `friend:${chat.with.email}`;\n\n      // Display: \"F: <name>\" or \"F: <email>\" if no name\n      const displayName = chat.with.name || chat.with.email;\n      option.textContent = `F: ${displayName}`;\n\n      targetDeviceSelect.appendChild(option);\n    });\n  }\n  // ========== END OF SECTION ==========\n}\n\n/**\n * Display pushes\n */\nfunction displayPushes(pushes: Push[]): void {\n  pushesList.innerHTML = \"\";\n\n  if (!pushes || pushes.length === 0) {\n    pushesList.innerHTML = \"<p>No recent pushes</p>\";\n    return;\n  }\n\n  // Show 10 most recent\n  const recentPushes = pushes.slice(0, 10);\n\n  recentPushes.forEach((push) => {\n    // Declare variables to hold the content for this specific push\n    let title: string | undefined;\n    let body: string | undefined;\n    let url: string | undefined;\n\n    // Use type guards based on 'push.type' to safely access properties\n    if (push.type === 'note') {\n      title = push.title;\n      body = push.body;\n    } else if (push.type === 'link') {\n      title = push.title;\n      url = push.url;\n      body = push.body;\n    } else if (push.type === 'mirror') {\n      title = `SMS: ${push.title || ''}`;\n      body = push.body;\n    } else if (push.type === 'sms_changed') {\n      // This also fixes the 'sms is possibly undefined' error\n      if (push.notifications && push.notifications.length > 0) {\n        const sms = push.notifications[0]!;\n        title = sms.title;\n        body = sms.body;\n      }\n    }\n\n    // Skip empty\n    if (!title && !body && !url) {\n      return;\n    }\n\n    const pushItem = document.createElement(\"div\");\n    pushItem.className = \"push-item\";\n\n    // Add SMS badge for SMS-related pushes\n    if (push.type === \"mirror\" && push.application_name?.toLowerCase().includes(\"messaging\")) {\n      pushItem.classList.add(\"push-sms\");\n    } else if (push.type === \"sms_changed\") {\n      pushItem.classList.add(\"push-sms\");\n    }\n\n    // Timestamp\n    if (push.created) {\n      const timestamp = new Date(push.created * 1000);\n      const timeElement = document.createElement(\"div\");\n      timeElement.className = \"push-time\";\n      timeElement.textContent = formatTimestamp(timestamp);\n      pushItem.appendChild(timeElement);\n    }\n\n    // Title\n    if (title) {\n      const titleEl = document.createElement(\"div\");\n      titleEl.className = \"push-title\";\n      titleEl.textContent = title || '';\n      pushItem.appendChild(titleEl);\n    }\n\n    // URL\n    if (url) {\n      const urlEl = document.createElement(\"a\");\n      urlEl.href = url as string;\n      urlEl.target = \"_blank\";\n      urlEl.className = \"push-url\";\n      urlEl.textContent = url || '';\n      pushItem.appendChild(urlEl);\n    }\n\n    // Body\n    if (body) {\n      const bodyEl = document.createElement(\"div\");\n      bodyEl.className = \"push-body\";\n      bodyEl.textContent = body || '';\n      pushItem.appendChild(bodyEl);\n    }\n\n    pushesList.appendChild(pushItem);\n  });\n}\n\n/**\n * Format timestamp\n */\nfunction formatTimestamp(date: Date): string {\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffSec = Math.floor(diffMs / 1000);\n  const diffMin = Math.floor(diffSec / 60);\n  const diffHour = Math.floor(diffMin / 60);\n  const diffDay = Math.floor(diffHour / 24);\n\n  if (diffDay > 0) {\n    return `${diffDay}d ago`;\n  } else if (diffHour > 0) {\n    return `${diffHour}h ago`;\n  } else if (diffMin > 0) {\n    return `${diffMin}m ago`;\n  } else {\n    return \"just now\";\n  }\n}\n\n/**\n * Handle file selection\n */\nfunction handleFileSelect(event: Event): void {\n  const target = event.target as HTMLInputElement;\n  const file = target.files?.[0];\n  if (file) {\n    fileName.textContent = file.name;\n    fileSize.textContent = formatFileSize(file.size);\n    fileSelected.style.display = \"block\";\n  } else {\n    fileSelected.style.display = \"none\";\n  }\n}\n\n/**\n * Format file size\n */\nfunction formatFileSize(bytes: number): string {\n  if (bytes === 0) return \"0 Bytes\";\n  const k = 1024;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + \" \" + sizes[i];\n}\n\n/**\n * Toggle push type\n */\nasync function togglePushType(type: PushType): Promise<void> {\n  currentPushType = type;\n\n  // Update buttons\n  pushTypeNoteBtn.classList.toggle(\"active\", type === \"note\");\n  pushTypeLinkBtn.classList.toggle(\"active\", type === \"link\");\n  pushTypeFileBtn.classList.toggle(\"active\", type === \"file\");\n\n  if (type === \"note\") {\n    noteForm.style.display = \"block\";\n    linkForm.style.display = \"none\";\n    fileForm.style.display = \"none\";\n  } else if (type === \"link\") {\n    noteForm.style.display = \"none\";\n    linkForm.style.display = \"block\";\n    fileForm.style.display = \"none\";\n\n    // Auto-populate with current tab\n    try {\n      const tabs = await chrome.tabs.query({\n        active: true,\n        currentWindow: true,\n      });\n      if (tabs[0]) {\n        linkUrlInput.value = tabs[0].url ? tabs[0].url : \"\";\n        linkTitleInput.value = tabs[0].title ? tabs[0].title : \"\";\n      }\n    } catch (error) {\n      console.error(\"Error getting current tab info:\", error);\n    }\n  } else if (type === \"file\") {\n    noteForm.style.display = \"none\";\n    linkForm.style.display = \"none\";\n    fileForm.style.display = \"block\";\n  }\n}\n\n/**\n * Send push\n */\nasync function sendPush(): Promise<void> {\n  logToBackground(\"INFO\", \"[sendPush] Function initiated.\");\n\n  try {\n    const pushType = currentPushType;\n    const targetDevice = targetDeviceSelect.value;\n\n    logToBackground(\"INFO\", `[sendPush] currentPushType is: '${pushType}'`);\n\n    const pushData: PushData = {\n      type: pushType,\n    };\n\n    // ========== REPLACE OLD CODE WITH THIS ==========\n    // Check if sending to friend or device\n    if (targetDevice !== \"all\") {\n      if (targetDevice.startsWith(\"friend:\")) {\n        // Sending to a friend - extract email\n        const email = targetDevice.replace(\"friend:\", \"\");\n        pushData.email = email; // Use email field, not device_iden\n\n        logToBackground(\"INFO\", \"Sending push to friend\", {\n          email: email,\n          pushType: pushType,\n        });\n      } else {\n        // Sending to a specific device\n        pushData.device_iden = targetDevice;\n\n        logToBackground(\"INFO\", \"Sending push to device\", {\n          deviceIden: targetDevice,\n          pushType: pushType,\n        });\n      }\n    } else {\n      // No selection = send to all devices\n      logToBackground(\"INFO\", \"Sending push to all devices\", {\n        pushType: pushType,\n      });\n    }\n    // ========== END OF REPLACEMENT ==========\n\n    // Set push data based on type\n    if (pushType === \"note\") {\n      logToBackground(\"INFO\", '[sendPush] Handling \"note\" type.');\n      pushData.title = noteTitleInput.value.trim();\n      pushData.body = noteBodyInput.value.trim();\n\n      if (!pushData.title && !pushData.body) {\n        logToBackground(\n          \"WARN\",\n          \"[sendPush] Exiting: Note title and body are empty.\",\n        );\n        showStatus(\"Please enter a title or body for the note.\", \"error\");\n        return;\n      }\n    } else if (pushType === \"link\") {\n      logToBackground(\"INFO\", '[sendPush] Handling \"link\" type.');\n      pushData.title = linkTitleInput.value.trim();\n      pushData.url = linkUrlInput.value.trim();\n      pushData.body = linkBodyInput.value.trim();\n\n      if (!pushData.url) {\n        logToBackground(\"WARN\", \"[sendPush] Exiting: Link URL is empty.\");\n        showStatus(\"Please enter a URL for the link.\", \"error\");\n        return;\n      }\n    } else if (pushType === \"file\") {\n      logToBackground(\"INFO\", '[sendPush] Handling \"file\" type.');\n      const file = fileInput.files?.[0];\n\n      showStatus(\"Uploading file...\", \"info\");\n\n      try {\n        // Check if file exists\n        if (!file) {\n          logToBackground(\n            \"WARN\",\n            \"[sendPush] Exiting: File type selected but no file is attached.\",\n          );\n          showStatus(\"Please select a file to attach.\", \"error\");\n          return;\n        }\n        const uploadApiKey = await storageRepository.getApiKey();\n        if (!uploadApiKey) {\n          logToBackground(\n            \"WARN\",\n            \"[sendPush] Exiting: Cannot upload file, user is not logged in.\",\n          );\n          showStatus(\"Not logged in. Please log in first.\", \"error\");\n          return;\n        }\n\n        // Request upload authorization\n        const uploadRequestResponse = await fetch(\n          \"https://api.pushbullet.com/v2/upload-request\",\n          {\n            method: \"POST\",\n            headers: {\n              \"Access-Token\": uploadApiKey,\n              \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n              file_name: file.name,\n              file_type: file.type || \"application/octet-stream\",\n            }),\n          },\n        );\n\n        if (!uploadRequestResponse.ok) {\n          throw new Error(\"Failed to request file upload authorization\");\n        }\n\n        const uploadData =\n          (await uploadRequestResponse.json()) as UploadRequestResponse;\n\n        // Upload to S3\n        const formData = new FormData();\n        Object.keys(uploadData.data).forEach((key) => {\n          formData.append(key, uploadData.data[key] as string);\n        });\n        formData.append(\"file\", file);\n\n        const uploadResponse = await fetch(uploadData.upload_url, {\n          method: \"POST\",\n          body: formData,\n        });\n\n        if (!uploadResponse.ok) {\n          throw new Error(\"Failed to upload file to server\");\n        }\n\n        // Create file push\n        pushData.type = \"file\";\n        pushData.file_name = uploadData.file_name;\n        pushData.file_type = uploadData.file_type;\n        pushData.file_url = uploadData.file_url;\n        pushData.body = (\n          document.getElementById(\"file-body\") as HTMLTextAreaElement\n        ).value.trim();\n\n        showStatus(\"File uploaded, sending push...\", \"info\");\n      } catch (uploadError) {\n        logToBackground(\"ERROR\", \"[sendPush] File upload error.\", {\n          error: (uploadError as Error).message,\n        });\n        showStatus(\n          \"Failed to upload file: \" + (uploadError as Error).message,\n          \"error\",\n        );\n        return;\n      }\n    }\n\n    logToBackground(\n      \"INFO\",\n      \"[sendPush] Validation passed. Preparing to send message to background script.\",\n      pushData,\n    );\n\n    // Send push via background script\n    chrome.runtime.sendMessage(\n      {\n        action: MessageAction.SEND_PUSH,\n        pushData: pushData,\n      },\n      (response) => {\n        if (chrome.runtime.lastError) {\n          logToBackground(\n            \"ERROR\",\n            \"[sendPush] Error sending message to background.\",\n            { error: chrome.runtime.lastError },\n          );\n          showStatus(\"Error: Could not send push\", \"error\");\n          return;\n        }\n\n        logToBackground(\n          \"INFO\",\n          \"[sendPush] Received response from background script.\",\n          response,\n        );\n\n        if (response.success) {\n          clearPushForm();\n          showStatus(\"Push sent successfully!\", \"success\");\n          chrome.runtime.sendMessage(\n            { action: MessageAction.GET_SESSION_DATA },\n            (sessionResponse: SessionData) => {\n              if (sessionResponse && sessionResponse.recentPushes) {\n                displayPushes(sessionResponse.recentPushes);\n              }\n            },\n          );\n        } else {\n          showStatus(\n            `Error: ${response.error || \"Failed to send push\"}`,\n            \"error\",\n          );\n        }\n      },\n    );\n  } catch (error) {\n    logToBackground(\"ERROR\", \"[sendPush] An unexpected error occurred.\", {\n      error: (error as Error).message,\n    });\n    showStatus(\n      `An unexpected error occurred: ${(error as Error).message}`,\n      \"error\",\n    );\n  }\n}\n\n/**\n * Clear push form\n */\nfunction clearPushForm(): void {\n  noteTitleInput.value = \"\";\n  noteBodyInput.value = \"\";\n  linkTitleInput.value = \"\";\n  linkUrlInput.value = \"\";\n  linkBodyInput.value = \"\";\n  fileInput.value = \"\";\n  (document.getElementById(\"file-body\") as HTMLTextAreaElement).value = \"\";\n  fileSelected.style.display = \"none\";\n}\n\n/**\n * Show status message\n */\nfunction showStatus(message: string, type: \"success\" | \"error\" | \"info\"): void {\n  statusMessage.textContent = message;\n  statusMessage.className = type;\n\n  setTimeout(() => {\n    statusMessage.textContent = \"\";\n    statusMessage.className = \"\";\n  }, 3000);\n}\n\n/**\n * Sends a log message to the background script for centralized logging.\n * Falls back to console.log if the background script is unreachable.\n * @param level The severity level of the log.\n * @param message The log message.\n * @param data Optional data to include with the log.\n */\nfunction logToBackground(\n  level: \"INFO\" | \"WARN\" | \"ERROR\",\n  message: string,\n  data?: unknown,\n) {\n  try {\n    chrome.runtime.sendMessage({\n      action: \"log\",\n      payload: {\n        level,\n        message,\n        data,\n      },\n    });\n  } catch (error) {\n    // Fallback to console if background is unavailable\n    const fallbackLog = `[FALLBACK] ${message}`;\n    if (level === \"ERROR\") {\n      console.error(fallbackLog, data, error);\n    } else if (level === \"WARN\") {\n      console.warn(fallbackLog, data);\n    } else {\n      // We don't log INFO fallbacks to avoid noise if the background is just waking up.\n    }\n  }\n}\n\n/**\n * Scroll to recent pushes\n */\nfunction scrollToRecentPushes(): void {\n  const recentPushesSection = document.querySelector(\".recent-pushes\");\n  if (recentPushesSection) {\n    console.log(\"Scrolling to recent pushes section\");\n    recentPushesSection.scrollIntoView({\n      behavior: \"smooth\",\n    });\n  }\n}\n\n/**\n * Update connection indicator\n * REMOVED: Connection indicator UI element removed, using badge instead\n */\n// function updateConnectionIndicator() - REMOVED\n\n/**\n * Listen for messages from background\n */\nchrome.runtime.onMessage.addListener((message, _, __) => {\n  if (message.action === MessageAction.CONNECTION_STATE_CHANGED) {\n    // Connection state changes now shown via badge icon only\n    console.log(\"Connection state changed:\", message.state);\n  } else if (message.action === MessageAction.PUSHES_UPDATED) {\n    if (message.pushes) {\n      displayPushes(message.pushes as Push[]);\n    }\n  }\n});\n\n// Export init for testing\nexport { init };\n\n// Initialize on DOM load\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", init);\n} else {\n  init();\n}\n"],
  "mappings": "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",
  "names": []
}
