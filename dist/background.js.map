{
  "version": 3,
  "sources": ["../src/lib/logging/index.ts", "../src/lib/perf/index.ts", "../src/lib/monitoring/index.ts", "../src/types/domain.ts", "../src/app/notifications/index.ts", "../src/lib/events/event-bus.ts", "../src/app/ws/client.ts", "../src/app/api/client.ts", "../src/infrastructure/storage/storage.repository.ts", "../src/app/session/index.ts", "../src/app/reconnect/index.ts", "../src/lib/crypto/index.ts", "../src/background/state.ts", "../src/background/utils.ts", "../src/background/state-machine.ts", "../src/lib/security/message-validation.ts", "../src/background/index.ts"],
  "sourcesContent": ["/* Logging and debug configuration (TypeScript)\n   Mirrors js/logging.js without changing behavior. */\n\nexport type LogLevel = \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\nexport type LogCategory =\n  | \"WEBSOCKET\"\n  | \"NOTIFICATIONS\"\n  | \"API\"\n  | \"STORAGE\"\n  | \"GENERAL\"\n  | \"PERFORMANCE\"\n  | \"ERROR\";\n\n// Persistent logging constants\nconst STORAGE_KEY = \"persistentDebugLogs\";\nconst MAX_PERSISTENT_LOGS = 5000; // Store the last 5000 log entries\n\nexport interface DebugConfig {\n  enabled: boolean;\n  categories: Record<LogCategory, boolean>;\n  logLevel: LogLevel;\n  maxLogEntries: number;\n  sanitizeData: boolean;\n}\n\n// DEBUG TOGGLE: Default to disabled to prevent unnecessary log accumulation\nexport const DEBUG_CONFIG: DebugConfig = {\n  enabled: false,\n  categories: {\n    WEBSOCKET: true,\n    NOTIFICATIONS: true,\n    API: true,\n    STORAGE: true,\n    GENERAL: true,\n    PERFORMANCE: true,\n    ERROR: true,\n  },\n  logLevel: \"DEBUG\",\n  maxLogEntries: 1000,\n  sanitizeData: true,\n};\n\nexport interface LogEntry {\n  timestamp: string;\n  category: LogCategory;\n  level: LogLevel;\n  message: string;\n  data: unknown | null;\n  error: { name: string; message: string; stack?: string } | null;\n}\n\nexport class DebugLogger {\n  private logs: LogEntry[] = [];\n  private startTime = Date.now();\n  private performanceMarkers = new Map<string, number>();\n\n  /**\n   * Rehydrate logs from persistent storage on startup\n   * This method loads logs from the previous session\n   */\n  async rehydrate(): Promise<void> {\n    try {\n      const result = await chrome.storage.local.get(STORAGE_KEY);\n      if (result[STORAGE_KEY] && Array.isArray(result[STORAGE_KEY])) {\n        this.logs = result[STORAGE_KEY];\n        console.log(\n          `[Logger] Rehydrated ${this.logs.length} logs from persistent storage.`,\n        );\n      }\n    } catch (error) {\n      console.error(\"[Logger] Failed to rehydrate logs:\", error);\n    }\n  }\n\n  /**\n   * Flush logs to persistent storage\n   * This method saves the current in-memory logs with circular buffer logic\n   */\n  async flush(): Promise<void> {\n    try {\n      // Circular buffer: trim to MAX_PERSISTENT_LOGS before saving\n      if (this.logs.length > MAX_PERSISTENT_LOGS) {\n        this.logs = this.logs.slice(this.logs.length - MAX_PERSISTENT_LOGS);\n      }\n      await chrome.storage.local.set({ [STORAGE_KEY]: this.logs });\n    } catch (error) {\n      // Don't use debugLogger here to avoid potential infinite loop\n      console.error(\"[Logger] Failed to flush logs to storage:\", error);\n    }\n  }\n\n  /**\n   * Clear all logs from memory and persistent storage\n   * This method is called when the user clicks \"Clear All Logs\" in the debug dashboard\n   */\n  async clearLogs(): Promise<void> {\n    this.logs = [];\n    await this.flush();\n    this.log('GENERAL', 'INFO', 'Log buffer has been cleared by the user.');\n  }\n\n  private sanitize(data: unknown): unknown {\n    if (!DEBUG_CONFIG.sanitizeData) return data;\n    if (typeof data === \"string\") {\n      if (data.length > 20 && /^[a-zA-Z0-9_-]+$/.test(data)) {\n        return data.substring(0, 4) + \"***\" + data.substring(data.length - 4);\n      }\n      return data;\n    }\n    if (data && typeof data === \"object\") {\n      const sanitized: Record<string, unknown> | unknown[] = Array.isArray(data)\n        ? []\n        : {};\n      for (const key in data as Record<string, unknown>) {\n        if (\n          key.toLowerCase().includes(\"token\") ||\n          key.toLowerCase().includes(\"key\") ||\n          key.toLowerCase().includes(\"password\")\n        ) {\n          (sanitized as any)[key] = this.sanitize((data as any)[key]);\n        } else {\n          (sanitized as any)[key] = (data as any)[key];\n        }\n      }\n      return sanitized;\n    }\n    return data;\n  }\n\n  private getTimestamp(): string {\n    const now = new Date();\n    const elapsed = Date.now() - this.startTime;\n    return `${now.toISOString()} (+${elapsed}ms)`;\n  }\n\n  /**\n   * Format data for console output to avoid [object Object]\n   */\n  private formatDataForConsole(data: unknown): string {\n    if (typeof data === 'object' && data !== null) {\n      try {\n        return JSON.stringify(data, null, 2);\n      } catch {\n        return String(data);\n      }\n    }\n    return String(data ?? 'null');\n  }\n\n  /**\n   * Format error for console output\n   */\n  private formatErrorForConsole(error: Error | null): string {\n    if (!error) return 'null';\n    \n    if (error instanceof Error) {\n      return `${error.name}: ${error.message}`;\n    }\n    \n    // Handle non-Error objects (like WebSocket Event objects)\n    try {\n      return JSON.stringify(error, null, 2);\n    } catch {\n      return String(error);\n    }\n  }\n\n  log(\n    category: LogCategory,\n    level: LogLevel,\n    message: string,\n    data: unknown = null,\n    error: Error | null = null,\n  ) {\n    if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.categories[category]) return;\n    const timestamp = this.getTimestamp();\n    const entry: LogEntry = {\n      timestamp,\n      category,\n      level,\n      message,\n      data: data ? this.sanitize(data) : null,\n      error: error\n        ? {\n          name: error.name,\n          message: error.message,\n          stack: (error as any).stack,\n        }\n        : null,\n    };\n    if (error && level === \"ERROR\") {\n      globalErrorTracker.trackError(\n        error,\n        { category, message, data: data ? this.sanitize(data) : null },\n        category,\n      );\n    }\n    this.logs.push(entry);\n    // Trimming is now handled by the periodic flush() method to avoid performance overhead\n\n    const prefix = `[${category}:${level}] ${timestamp}`;\n    const full = `${prefix} ${message}`;\n    const sanitized = data ? this.sanitize(data) : null;\n    switch (level) {\n    case \"ERROR\":\n      if (sanitized && error) {\n        console.error(full);\n        console.error(\"  Data:\", this.formatDataForConsole(sanitized));\n        console.error(\"  Error:\", this.formatErrorForConsole(error));\n      } else if (sanitized) {\n        console.error(full);\n        console.error(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else if (error) {\n        console.error(full);\n        console.error(\"  Error:\", this.formatErrorForConsole(error));\n      } else {\n        console.error(full);\n      }\n      break;\n    case \"WARN\":\n      if (sanitized) {\n        console.warn(full);\n        console.warn(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else {\n        console.warn(full);\n      }\n      break;\n    case \"INFO\":\n      if (sanitized) {\n        console.info(full);\n        console.info(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else {\n        console.info(full);\n      }\n      break;\n    default:\n      if (sanitized) {\n        console.log(full);\n        console.log(\"  Data:\", sanitized);\n      } else {\n        console.log(full);\n      }\n    }\n  }\n\n  websocket(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"WEBSOCKET\", level, message, data, error || null);\n  }\n  notifications(\n    level: LogLevel,\n    message: string,\n    data?: unknown,\n    error?: Error,\n  ) {\n    this.log(\"NOTIFICATIONS\", level, message, data, error || null);\n  }\n  api(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"API\", level, message, data, error || null);\n  }\n  storage(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"STORAGE\", level, message, data, error || null);\n  }\n  general(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"GENERAL\", level, message, data, error || null);\n  }\n  performance(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"PERFORMANCE\", level, message, data, error || null);\n  }\n  error(message: string, data?: unknown, error?: Error) {\n    this.log(\"ERROR\", \"ERROR\", message, data, error || null);\n  }\n\n  startTimer(name: string) {\n    this.performanceMarkers.set(name, Date.now());\n    this.performance(\"DEBUG\", `Timer started: ${name}`);\n  }\n  endTimer(name: string): number | null {\n    const start = this.performanceMarkers.get(name);\n    if (start) {\n      const duration = Date.now() - start;\n      this.performanceMarkers.delete(name);\n      this.performance(\"INFO\", `Timer ended: ${name}`, {\n        duration: `${duration}ms`,\n      });\n      return duration;\n    }\n    this.performance(\"WARN\", `Timer not found: ${name}`);\n    return null;\n  }\n  getRecentLogs(count = 50, category: LogCategory | null = null) {\n    let logs = this.logs;\n    if (category) logs = logs.filter((l) => l.category === category);\n    return logs.slice(-count);\n  }\n  exportLogs() {\n    return {\n      config: DEBUG_CONFIG,\n      logs: this.logs,\n      summary: {\n        totalLogs: this.logs.length,\n        categories: (\n          Object.keys(DEBUG_CONFIG.categories) as LogCategory[]\n        ).reduce((acc: Record<string, number>, cat) => {\n          acc[cat] = this.logs.filter((l) => l.category === cat).length;\n          return acc;\n        }, {}),\n        errors: this.logs.filter((l) => l.level === \"ERROR\").length,\n      },\n    };\n  }\n}\n\nexport const debugLogger = new DebugLogger();\n\n// Rehydrate logs from persistent storage on startup\n// We don't await this because we can't have a top-level await in a module\ndebugLogger.rehydrate();\n\nexport class DebugConfigManager {\n  async loadConfig() {\n    try {\n      debugLogger.storage(\"DEBUG\", \"Loading debug configuration from storage\");\n      const result = await new Promise<any>((resolve) => {\n        chrome.storage.local.get([\"debugConfig\"], (items) => resolve(items));\n      });\n      if (result.debugConfig) {\n        Object.assign(DEBUG_CONFIG, result.debugConfig as Partial<DebugConfig>);\n        debugLogger.storage(\n          \"INFO\",\n          \"Debug configuration loaded from storage\",\n          DEBUG_CONFIG,\n        );\n      } else {\n        debugLogger.storage(\n          \"INFO\",\n          \"No stored debug configuration found - using defaults\",\n          DEBUG_CONFIG,\n        );\n      }\n    } catch (error: any) {\n      debugLogger.storage(\n        \"ERROR\",\n        \"Failed to load debug configuration\",\n        null,\n        error,\n      );\n    }\n  }\n  async saveConfig() {\n    try {\n      debugLogger.storage(\"DEBUG\", \"Saving debug configuration to storage\");\n      await new Promise((resolve) => {\n        chrome.storage.local.set({ debugConfig: DEBUG_CONFIG }, () =>\n          resolve(null),\n        );\n      });\n      debugLogger.storage(\"INFO\", \"Debug configuration saved to storage\");\n    } catch (error: any) {\n      debugLogger.storage(\n        \"ERROR\",\n        \"Failed to save debug configuration\",\n        null,\n        error,\n      );\n    }\n  }\n  updateConfig(updates: Partial<DebugConfig>) {\n    Object.assign(DEBUG_CONFIG, updates);\n    void this.saveConfig();\n    debugLogger.general(\"INFO\", \"Debug configuration updated\", updates);\n  }\n  toggleCategory(category: LogCategory) {\n    if (\n      Object.prototype.hasOwnProperty.call(DEBUG_CONFIG.categories, category)\n    ) {\n      DEBUG_CONFIG.categories[category] = !DEBUG_CONFIG.categories[category];\n      void this.saveConfig();\n      debugLogger.general(\"INFO\", `Debug category ${category} toggled`, {\n        category,\n        enabled: DEBUG_CONFIG.categories[category],\n      });\n    }\n  }\n  setLogLevel(level: LogLevel) {\n    const valid: LogLevel[] = [\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"];\n    if (valid.includes(level)) {\n      DEBUG_CONFIG.logLevel = level;\n      void this.saveConfig();\n      debugLogger.general(\"INFO\", `Debug log level set to ${level}`);\n    }\n  }\n  getConfig(): DebugConfig {\n    return { ...DEBUG_CONFIG };\n  }\n  resetConfig() {\n    const def: DebugConfig = {\n      enabled: true,\n      categories: {\n        WEBSOCKET: true,\n        NOTIFICATIONS: true,\n        API: true,\n        STORAGE: true,\n        GENERAL: true,\n        PERFORMANCE: true,\n        ERROR: true,\n      },\n      logLevel: \"DEBUG\",\n      maxLogEntries: 1000,\n      sanitizeData: true,\n    };\n    Object.assign(DEBUG_CONFIG, def);\n    void this.saveConfig();\n    debugLogger.general(\"INFO\", \"Debug configuration reset to defaults\");\n  }\n}\n\nexport const debugConfigManager = new DebugConfigManager();\nvoid debugConfigManager.loadConfig();\n\nexport class GlobalErrorTracker {\n  private errors: Array<{\n    timestamp: string;\n    category: string;\n    message: string;\n    name: string;\n    stack?: string;\n    context: any;\n  }> = [];\n  private errorCounts = new Map<string, number>();\n  private criticalErrors: any[] = [];\n\n  trackError(error: Error, context: any = {}, category = \"GENERAL\") {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      category,\n      message: error.message,\n      name: error.name,\n      stack: (error as any).stack,\n      context,\n    };\n    this.errors.push(entry);\n    const count = (this.errorCounts.get(category) || 0) + 1;\n    this.errorCounts.set(category, count);\n    if (count >= 5) this.criticalErrors.push(entry);\n  }\n  getErrorSummary() {\n    const byCat: Record<string, number> = {};\n    this.errorCounts.forEach((v, k) => (byCat[k] = v));\n    return {\n      total: this.errors.length,\n      byCategory: byCat,\n      critical: this.criticalErrors.length,\n    };\n  }\n  exportErrorData() {\n    return { errors: this.errors.slice(-200), summary: this.getErrorSummary() };\n  }\n}\n\nexport const globalErrorTracker = new GlobalErrorTracker();\n\n// Attach listeners in SW environment; swallow if not available\ntry {\n  self.addEventListener(\"error\", (event: ErrorEvent) => {\n    globalErrorTracker.trackError(\n      (event as any).error || new Error(event.message),\n      {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        type: \"unhandled\",\n      },\n      \"GLOBAL\",\n    );\n  });\n} catch {\n  /* noop */\n}\ntry {\n  self.addEventListener(\n    \"unhandledrejection\",\n    (event: PromiseRejectionEvent) => {\n      globalErrorTracker.trackError(\n        (event as any).reason || new Error(\"Unhandled promise rejection\"),\n        { type: \"unhandled_promise\" },\n        \"GLOBAL\",\n      );\n    },\n  );\n} catch {\n  /* noop */\n}\n", "/* Performance monitoring (TypeScript)\n   Mirrors js/performance.js */\n\nexport class PerformanceMonitor {\n  private metrics = new Map<string, number>();\n  private notificationTimeline: Array<{ ts: number; event: string }>= [];\n  private websocketMetrics = { connectionAttempts: 0, successfulConnections: 0, messagesReceived: 0, messagesProcessed: 0, reconnectionAttempts: 0, lastConnectionTime: null as number | null, totalDowntime: 0 };\n  private notificationMetrics = { pushesReceived: 0, notificationsCreated: 0, notificationsFailed: 0, unknownTypes: 0 };\n  private healthChecks = { success: 0, failure: 0, lastCheck: null as number | null };\n  private quality = { disconnections: 0, permanentErrors: 0, consecutiveFailures: 0 };\n  private timers: Record<string, number> = {};\n\n  record(metric: string, value = 1) { const cur = this.metrics.get(metric) || 0; this.metrics.set(metric, cur + value); }\n  start(name: string) { this.timers[name] = Date.now(); }\n  end(name: string) { if (this.timers[name]) { const d = Date.now() - this.timers[name]; delete this.timers[name]; this.record(`timer:${name}`, d); return d; } return null; }\n  recordWebSocketConnection(success: boolean) { this.websocketMetrics.connectionAttempts++; if (success) { this.websocketMetrics.successfulConnections++; this.websocketMetrics.lastConnectionTime = Date.now(); this.quality.consecutiveFailures = 0; } }\n  recordWebSocketMessage(received = true, processed = false) { if (received) this.websocketMetrics.messagesReceived++; if (processed) this.websocketMetrics.messagesProcessed++; }\n  recordWebSocketReconnection() { this.websocketMetrics.reconnectionAttempts++; this.quality.consecutiveFailures++; }\n  recordHealthCheckSuccess() { this.healthChecks.success++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures = 0; }\n  recordHealthCheckFailure() { this.healthChecks.failure++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures++; }\n  recordDisconnection() { this.quality.disconnections++; }\n  recordPermanentError() { this.quality.permanentErrors++; }\n  recordNotification(event: string) { this.notificationTimeline.push({ ts: Date.now(), event }); if (this.notificationTimeline.length > 200) this.notificationTimeline.shift(); }\n  recordPushReceived() { this.notificationMetrics.pushesReceived++; }\n  recordNotificationCreated() { this.notificationMetrics.notificationsCreated++; }\n  recordNotificationFailed() { this.notificationMetrics.notificationsFailed++; }\n  recordUnknownPushType() { this.notificationMetrics.unknownTypes++; }\n  getPerformanceSummary() { return { websocket: this.websocketMetrics, health: this.healthChecks, quality: this.quality, notifications: this.notificationMetrics, metrics: Object.fromEntries(this.metrics) as Record<string, number> }; }\n  getQualityMetrics() { return this.quality; }\n  exportPerformanceData() { return { summary: this.getPerformanceSummary(), timeline: this.notificationTimeline.slice(-200) }; }\n}\n\nexport const performanceMonitor = new PerformanceMonitor();\n\n", "/* Monitoring (TypeScript)\n   Mirrors js/monitoring.js */\n\nexport class InitializationTracker {\n  private initializations: Array<{ source: string; timestamp: string }> = [];\n  private stats: Record<string, number> = { onInstalled: 0, onStartup: 0, onAlarm: 0, onMessage: 0, manual: 0 };\n\n  recordInitialization(source: string) {\n    this.initializations.push({ source, timestamp: new Date().toISOString() });\n    if (this.stats[source] !== undefined) this.stats[source]++;\n  }\n  exportData() { return { initializations: this.initializations.slice(-100), stats: { ...this.stats } }; }\n}\n\nexport const initTracker = new InitializationTracker();\n\nexport class WebSocketStateMonitor {\n  private stateHistory: Array<{ timestamp: number; state: string | null; duration: number }>= [];\n  private lastStateCheck = Date.now();\n  private monitoringInterval: ReturnType<typeof setInterval> | null = null;\n  private alertThresholds = { slowReceive: 15000 };\n\n  recordStateChange(newState: string) {\n    const now = Date.now();\n    const prev = this.stateHistory[this.stateHistory.length - 1];\n    const duration = prev ? now - prev.timestamp : 0;\n    this.stateHistory.push({ timestamp: now, state: newState, duration });\n    if (this.stateHistory.length > 200) this.stateHistory.shift();\n  }\n  getStateReport() {\n    const currentState = (globalThis as any).websocket && typeof (globalThis as any).websocket.readyState === 'number'\n      ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][(globalThis as any).websocket.readyState] : 'NULL';\n    return { currentState, lastCheck: new Date(this.lastStateCheck).toISOString(), historyLength: this.stateHistory.length };\n  }\n  startMonitoring() {\n    if (this.monitoringInterval) return;\n    this.monitoringInterval = setInterval(() => {\n      this.lastStateCheck = Date.now();\n      const state = (globalThis as any).websocket ? (globalThis as any).websocket.readyState : null;\n      try { (globalThis as any).debugLogger?.websocket('DEBUG', 'WebSocket state check', { state }); } catch { /* noop */ }\n    }, 30000);\n  }\n  stopMonitoring() { if (this.monitoringInterval) { clearInterval(this.monitoringInterval); this.monitoringInterval = null; } }\n}\n\nexport const wsStateMonitor = new WebSocketStateMonitor();\n\n", "/************************************\n * Domain types for TypeScript plan *\n ************************************/\n\nexport type ISO8601 = string;\n\n// ============================================================================\n// User and Device Types\n// ============================================================================\n\nexport interface User {\n  iden: string;\n  email?: string;\n  name?: string;\n  image_url?: string;\n  max_upload_size?: number;\n}\n\nexport interface Device {\n  iden: string;\n  nickname?: string;\n  manufacturer?: string;\n  model?: string;\n  active?: boolean;\n  created?: number;\n  modified?: number;\n  push_token?: string;\n  app_version?: number;\n  type?: string;\n  kind?: string;\n  icon?: string;\n  has_sms?: boolean;\n}\n\n// ============================================================================\n// Push Types\n// ============================================================================\n\nexport interface PushBase {\n  iden?: string;\n  active?: boolean;\n  created?: number;\n  modified?: number;\n  dismissed?: boolean;\n  direction?: 'self' | 'incoming' | 'outgoing';\n  sender_iden?: string;\n  sender_email?: string;\n  sender_name?: string;\n  receiver_iden?: string;\n  receiver_email?: string;\n  target_device_iden?: string;\n  source_device_iden?: string;\n  encrypted?: boolean;\n  ciphertext?: string;\n}\n\nexport interface LinkPush extends PushBase {\n  type: 'link';\n  title?: string;\n  body?: string;\n  url: string;\n}\n\nexport interface NotePush extends PushBase {\n  type: 'note';\n  title?: string;\n  body?: string;\n}\n\nexport interface FilePush extends PushBase {\n  type: 'file';\n  file_name?: string;\n  file_type?: string;\n  file_url?: string;\n  body?: string;\n  image_url?: string;\n  image_width?: number;\n  image_height?: number;\n}\n\nexport interface MirrorPush extends PushBase {\n  type: 'mirror';\n  title?: string;\n  body?: string;\n  icon?: string;\n  application_name?: string;\n  package_name?: string;\n  notification_id?: string;\n  notification_tag?: string;\n  source_user_iden?: string;\n}\n\nexport interface DismissalPush extends PushBase {\n  type: 'dismissal';\n  package_name?: string;\n  notification_id?: string;\n  notification_tag?: string;\n  source_user_iden?: string;\n}\n\nexport type Push = LinkPush | NotePush | FilePush | MirrorPush | DismissalPush;\n\n// ============================================================================\n// Session and State Types\n// ============================================================================\n\nexport interface SessionCache {\n  userInfo: User | null;\n  devices: Device[];\n  recentPushes: Push[];\n  isAuthenticated: boolean;\n  lastUpdated: number;\n  autoOpenLinks: boolean;\n  deviceNickname: string;\n}\n\nexport interface InitializationState {\n  inProgress: boolean;\n  completed: boolean;\n  error: Error | null;\n  timestamp: number | null;\n}\n\n// ============================================================================\n// WebSocket Types\n// ============================================================================\n\nexport enum WS_READY_STATE {\n  CONNECTING = 0,\n  OPEN = 1,\n  CLOSING = 2,\n  CLOSED = 3\n}\n\nexport interface WebSocketTickleMessage {\n  type: 'tickle';\n  subtype: 'push' | 'device';\n}\n\nexport interface WebSocketPushMessage {\n  type: 'push';\n  push: Push;\n}\n\nexport interface WebSocketNopMessage {\n  type: 'nop';\n}\n\nexport type WebSocketMessage = WebSocketTickleMessage | WebSocketPushMessage | WebSocketNopMessage;\n\n// ============================================================================\n// API Response Types\n// ============================================================================\n\nexport interface APIResponse<T> {\n  data?: T;\n  error?: {\n    type: string;\n    message: string;\n    cat?: string;\n  };\n}\n\nexport interface DevicesResponse {\n  devices: Device[];\n}\n\nexport interface PushesResponse {\n  pushes: Push[];\n}\n\nexport type UserResponse = User;\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\nexport interface DebugConfig {\n  enabled: boolean;\n  categories: Record<string, boolean>;\n  logLevel: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\n  maxLogEntries: number;\n  sanitizeData: boolean;\n}\n\nexport interface StorageConfig {\n  apiKey?: string;\n  deviceIden?: string;\n  deviceNickname?: string;\n  autoOpenLinks?: boolean;\n  notificationTimeout?: number;\n  debugConfig?: DebugConfig;\n}\n\n// ============================================================================\n// Chrome Message Types\n// ============================================================================\n\nexport interface GetSessionDataMessage {\n  action: 'getSessionData';\n}\n\nexport interface SessionDataResponse {\n  isAuthenticated: boolean;\n  userInfo?: User | null;\n  devices?: Device[];\n  recentPushes?: Push[];\n  autoOpenLinks?: boolean;\n  deviceNickname?: string;\n  websocketConnected?: boolean;\n}\n\nexport interface ApiKeyChangedMessage {\n  action: 'apiKeyChanged';\n  apiKey: string;\n  deviceNickname?: string;\n}\n\nexport interface SessionDataUpdatedMessage {\n  action: 'sessionDataUpdated';\n  isAuthenticated: boolean;\n  userInfo?: User | null;\n  devices?: Device[];\n  recentPushes?: Push[];\n  autoOpenLinks?: boolean;\n  deviceNickname?: string;\n}\n\nexport interface PushesUpdatedMessage {\n  action: 'pushesUpdated';\n  pushes: Push[];\n}\n\nexport interface SettingsChangedMessage {\n  action: 'settingsChanged';\n  autoOpenLinks?: boolean;\n  notificationTimeout?: number;\n}\n\nexport interface LogoutMessage {\n  action: 'logout';\n}\n\nexport interface RefreshSessionMessage {\n  action: 'refreshSession';\n}\n\nexport interface UpdateDeviceNicknameMessage {\n  action: 'updateDeviceNickname';\n  nickname: string;\n}\n\nexport type ChromeMessage =\n  | GetSessionDataMessage\n  | ApiKeyChangedMessage\n  | SessionDataUpdatedMessage\n  | PushesUpdatedMessage\n  | SettingsChangedMessage\n  | LogoutMessage\n  | RefreshSessionMessage\n  | UpdateDeviceNicknameMessage;\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\nexport function isLinkPush(push: Push): push is LinkPush {\n  return push.type === 'link';\n}\n\nexport function isNotePush(push: Push): push is NotePush {\n  return push.type === 'note';\n}\n\nexport function isFilePush(push: Push): push is FilePush {\n  return push.type === 'file';\n}\n\nexport function isMirrorPush(push: Push): push is MirrorPush {\n  return push.type === 'mirror';\n}\n\nexport function isDismissalPush(push: Push): push is DismissalPush {\n  return push.type === 'dismissal';\n}\n\nexport function isTickleMessage(msg: WebSocketMessage): msg is WebSocketTickleMessage {\n  return msg.type === 'tickle';\n}\n\nexport function isPushMessage(msg: WebSocketMessage): msg is WebSocketPushMessage {\n  return msg.type === 'push';\n}\n\nexport function isNopMessage(msg: WebSocketMessage): msg is WebSocketNopMessage {\n  return msg.type === 'nop';\n}\n\n// ============================================================================\n// Validation Helpers\n// ============================================================================\n\nexport function isValidPush(push: unknown): push is Push {\n  if (!push || typeof push !== 'object') return false;\n  const p = push as Partial<Push>;\n  return typeof p.type === 'string' && ['link', 'note', 'file', 'mirror', 'dismissal'].includes(p.type);\n}\n\nexport function isValidDevice(device: unknown): device is Device {\n  if (!device || typeof device !== 'object') return false;\n  const d = device as Partial<Device>;\n  return typeof d.iden === 'string' && d.iden.length > 0;\n}\n\nexport function isValidUser(user: unknown): user is User {\n  if (!user || typeof user !== 'object') return false;\n  const u = user as Partial<User>;\n  return typeof u.iden === 'string' && u.iden.length > 0;\n}\n\n", "import { debugLogger } from '../../lib/logging';\nimport { performanceMonitor } from '../../lib/perf';\n\n// Track last disconnection notification to avoid spam\nlet lastDisconnectionNotification = 0;\nconst DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\n\n/**\n * Helper function to create notification with auto-dismiss\n */\nexport function createNotificationWithTimeout(\n  notificationId: string,\n  options: chrome.notifications.NotificationCreateOptions,\n  callback?: (id?: string) => void,\n  timeoutMs?: number\n): void {\n  // Get ABSOLUTE URL for the icon - service workers need absolute paths!\n  const iconUrl = chrome.runtime.getURL('icons/icon128.png');\n\n  // Create CLEAN options with ONLY the properties we want\n  const safeOptions: chrome.notifications.NotificationCreateOptions = {\n    type: 'basic',\n    iconUrl: iconUrl, // Use absolute URL\n    title: options.title || 'Pushbullet',\n    message: options.message || '',\n    priority: options.priority || 1\n  };\n\n  // Log what we're creating\n  debugLogger.notifications('DEBUG', 'Creating notification with safe options', {\n    notificationId,\n    iconUrl,\n    title: safeOptions.title,\n    messageLength: safeOptions.message?.length || 0\n  });\n\n  chrome.notifications.create(notificationId, safeOptions, (createdId) => {\n    // Check for errors\n    if (chrome.runtime.lastError) {\n      debugLogger.notifications('ERROR', 'Notification creation error', {\n        error: chrome.runtime.lastError.message,\n        notificationId\n      });\n    }\n\n    if (callback) callback(createdId);\n\n    // Auto-dismiss logic\n    try {\n      const timeout = timeoutMs !== undefined ? timeoutMs : 10000; // Default 10 seconds\n      if (typeof timeout === 'number' && timeout > 0) {\n        setTimeout(() => {\n          chrome.notifications.clear(createdId || notificationId, () => {});\n        }, timeout);\n      }\n    } catch (error) {\n      debugLogger.notifications('ERROR', 'Failed to set notification timeout', {\n        error: (error as Error).message\n      }, error as Error);\n    }\n  });\n}\n\n/**\n * Check if we should show a disconnection notification\n */\nexport function checkDisconnectionNotification(): void {\n  const now = Date.now();\n  const timeSinceLastNotification = now - lastDisconnectionNotification;\n\n  // Only notify if cooldown period has passed\n  if (timeSinceLastNotification < DISCONNECTION_NOTIFICATION_COOLDOWN) {\n    debugLogger.general('DEBUG', 'Disconnection notification suppressed - cooldown active', {\n      timeSinceLastNotification: `${Math.round(timeSinceLastNotification / 1000)}s`,\n      cooldownPeriod: `${DISCONNECTION_NOTIFICATION_COOLDOWN / 1000}s`\n    });\n    return;\n  }\n\n  // Check if we've been disconnected for threshold period\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n  if (qualityMetrics.consecutiveFailures >= 3) {\n    showDisconnectionNotification();\n    lastDisconnectionNotification = now;\n  }\n}\n\n/**\n * Show disconnection notification\n */\nexport function showDisconnectionNotification(): void {\n  createNotificationWithTimeout(\n    'pushbullet-disconnected',\n    {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title: 'Pushbullet Connection Issue',\n      message: 'Real-time push notifications may be delayed. Reconnecting...',\n      priority: 1\n    },\n    (notificationId) => {\n      debugLogger.general('INFO', 'Disconnection notification shown', { notificationId });\n    }\n  );\n}\n\n/**\n * Show permanent WebSocket error notification\n */\nexport function showPermanentWebSocketError(closeInfo: { code: number; reason?: string; wasClean?: boolean }): void {\n  const title = 'Pushbullet requires attention';\n  const message = `Real-time connection stopped (code ${closeInfo.code}). ${closeInfo.reason || ''}`.trim();\n\n  createNotificationWithTimeout(\n    'pushbullet-permanent-error',\n    {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title,\n      message,\n      priority: 2\n    },\n    () => {}\n  );\n\n  try {\n    chrome.action.setBadgeBackgroundColor({ color: '#d93025' });\n    chrome.action.setBadgeText({ text: 'ERR' });\n  } catch {\n    // noop\n  }\n}\n\n/**\n * Clear error badge\n */\nexport function clearErrorBadge(): void {\n  try {\n    chrome.action.setBadgeText({ text: '' });\n  } catch {\n    // ignore\n  }\n}\n\n", "/**\n * Event Bus Pattern\n * \n * This module implements a simple event bus for decoupling components.\n * Components can emit events without knowing who (if anyone) is listening.\n * \n * Benefits:\n * - Decoupling: Components don't need to know about each other\n * - Flexibility: Easy to add/remove listeners\n * - Testability: Easy to test components in isolation\n * \n * Example:\n * ```typescript\n * // Component A emits an event\n * globalEventBus.emit('user:login', { userId: 123 });\n * \n * // Component B listens for the event\n * globalEventBus.on('user:login', (data) => {\n *   console.log('User logged in:', data.userId);\n * });\n * ```\n */\n\n/**\n * Listener function type\n * Can receive optional data of any type\n */\ntype Listener = (data?: any) => void;\n\n/**\n * Event Bus Class\n * \n * Manages event listeners and event emission.\n * Uses a Map to store listeners for each event type.\n */\nclass EventBus {\n  /**\n   * Map of event names to sets of listener functions\n   * Using Set ensures each listener is only registered once\n   */\n  private listeners = new Map<string, Set<Listener>>();\n\n  /**\n   * Register a listener for an event\n   * \n   * @param event - Event name (e.g., 'websocket:connected')\n   * @param listener - Function to call when event is emitted\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.on('websocket:connected', () => {\n   *   console.log('WebSocket connected!');\n   * });\n   * ```\n   */\n  on(event: string, listener: Listener): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(listener);\n  }\n\n  /**\n   * Remove a listener for an event\n   * \n   * @param event - Event name\n   * @param listener - Listener function to remove\n   * \n   * @example\n   * ```typescript\n   * const handler = () => console.log('Connected');\n   * globalEventBus.on('websocket:connected', handler);\n   * globalEventBus.off('websocket:connected', handler);\n   * ```\n   */\n  off(event: string, listener: Listener): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n      // Clean up empty sets\n      if (eventListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   * \n   * @param event - Event name\n   * @param data - Optional data to pass to listeners\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.emit('websocket:message', { \n   *   type: 'push', \n   *   data: { title: 'Hello' } \n   * });\n   * ```\n   */\n  emit(event: string, data?: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      // Call each listener with the data\n      eventListeners.forEach(listener => {\n        try {\n          listener(data);\n        } catch (error) {\n          // Log errors but don't stop other listeners\n          console.error(`Error in event listener for '${event}':`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Register a one-time listener for an event\n   * The listener will be automatically removed after being called once\n   * \n   * @param event - Event name\n   * @param listener - Function to call when event is emitted\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.once('websocket:connected', () => {\n   *   console.log('Connected for the first time!');\n   * });\n   * ```\n   */\n  once(event: string, listener: Listener): void {\n    const onceWrapper = (data?: any) => {\n      listener(data);\n      this.off(event, onceWrapper);\n    };\n    this.on(event, onceWrapper);\n  }\n\n  /**\n   * Remove all listeners for an event\n   * If no event is specified, removes all listeners for all events\n   * \n   * @param event - Optional event name. If not provided, clears all listeners\n   * \n   * @example\n   * ```typescript\n   * // Remove all listeners for a specific event\n   * globalEventBus.removeAllListeners('websocket:connected');\n   * \n   * // Remove all listeners for all events\n   * globalEventBus.removeAllListeners();\n   * ```\n   */\n  removeAllListeners(event?: string): void {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n  }\n\n  /**\n   * Get the number of listeners for an event\n   * \n   * @param event - Event name\n   * @returns Number of listeners registered for the event\n   * \n   * @example\n   * ```typescript\n   * const count = globalEventBus.listenerCount('websocket:connected');\n   * console.log(`${count} listeners registered`);\n   * ```\n   */\n  listenerCount(event: string): number {\n    const eventListeners = this.listeners.get(event);\n    return eventListeners ? eventListeners.size : 0;\n  }\n\n  /**\n   * Get all event names that have listeners\n   * \n   * @returns Array of event names\n   * \n   * @example\n   * ```typescript\n   * const events = globalEventBus.eventNames();\n   * console.log('Events with listeners:', events);\n   * ```\n   */\n  eventNames(): string[] {\n    return Array.from(this.listeners.keys());\n  }\n}\n\n/**\n * Global Event Bus Instance\n * \n * This is a singleton instance that the whole extension can use.\n * Import this in any module that needs to emit or listen for events.\n * \n * @example\n * ```typescript\n * import { globalEventBus } from './lib/events/event-bus';\n * \n * // Emit an event\n * globalEventBus.emit('user:action', { action: 'click' });\n * \n * // Listen for an event\n * globalEventBus.on('user:action', (data) => {\n *   console.log('User action:', data.action);\n * });\n * ```\n */\nexport const globalEventBus = new EventBus();\n\n/**\n * Event Bus Class Export\n * \n * Export the class for testing purposes or if you need to create\n * multiple event bus instances (though the global singleton is recommended)\n */\nexport { EventBus };\n\n", "import { performanceMonitor } from \"../../lib/perf\";\nimport { debugLogger, globalErrorTracker } from \"../../lib/logging\";\nimport { wsStateMonitor } from \"../../lib/monitoring\";\nimport type { WebSocketMessage } from \"../../types/domain\";\nimport { WS_READY_STATE } from \"../../types/domain\";\nimport { clearErrorBadge, showPermanentWebSocketError } from \"../notifications\";\nimport { globalEventBus } from \"../../lib/events/event-bus\";\n\nexport interface CloseInfo {\n  code: number;\n  reason?: string;\n  wasClean?: boolean;\n}\n\n/**\n * WebSocket client for Pushbullet streaming API\n *\n * ARCHITECTURAL CHANGE: Event-Driven Architecture\n * This class now uses the global event bus to emit events instead of\n * calling handler functions directly. This decouples the WebSocketClient\n * from the background script and makes it more flexible and testable.\n *\n * Events emitted:\n * - websocket:connected - When WebSocket connection is established\n * - websocket:disconnected - When WebSocket connection is closed\n * - websocket:message - When a message is received\n * - websocket:tickle:push - When a push tickle is received\n * - websocket:tickle:device - When a device tickle is received\n * - websocket:push - When a push is received\n * - websocket:polling:check - When polling mode should be checked\n * - websocket:polling:stop - When polling mode should be stopped\n * - websocket:state - When connection state changes (for popup)\n */\nexport class WebSocketClient {\n  private socket: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    private websocketUrl: string,\n    private getApiKey: () => string | null,\n  ) {}\n\n  /**\n   * Get current WebSocket instance\n   */\n  getSocket(): WebSocket | null {\n    return this.socket;\n  }\n\n  /**\n   * Get current ready state\n   */\n  getReadyState(): number | null {\n    return this.socket ? this.socket.readyState : null;\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return (\n      this.socket !== null && this.socket.readyState === WS_READY_STATE.OPEN\n    );\n  }\n\n  /**\n   * Connect to WebSocket\n   */\n  connect(): void {\n    try {\n      const apiKey = this.getApiKey();\n      if (!apiKey) {\n        debugLogger.websocket(\"WARN\", \"connectWebSocket called without apiKey\");\n        return;\n      }\n\n      // If already open, do nothing\n      if (this.socket && this.socket.readyState === WS_READY_STATE.OPEN) {\n        debugLogger.websocket(\"DEBUG\", \"WebSocket already open\");\n        return;\n      }\n\n      // Fix WebSocket URL construction - Pushbullet uses simple concatenation\n      const url = this.websocketUrl + apiKey;\n\n      // CRITICAL: Log the exact URL being constructed (without exposing full API key)\n      debugLogger.websocket(\"INFO\", \"WebSocket URL construction debug\", {\n        baseUrl: this.websocketUrl,\n        apiKeyLength: apiKey.length,\n        apiKeyPrefix: apiKey.substring(0, 8) + \"...\",\n        finalUrlLength: url.length,\n        urlPattern: this.websocketUrl + \"***\",\n      });\n      debugLogger.websocket(\"INFO\", \"Connecting to WebSocket\", {\n        url: this.websocketUrl + \"***\",\n        reconnectAttempts: this.reconnectAttempts,\n        currentSocketState: this.socket\n          ? this.socket.readyState\n          : \"no_existing_socket\",\n        apiKeyPresent: !!apiKey,\n      });\n      this.reconnectAttempts = 0;\n\n      // Log pre-creation state\n      debugLogger.websocket(\"DEBUG\", \"About to create WebSocket object\", {\n        url: this.websocketUrl + \"***\",\n        currentSocketExists: !!this.socket,\n        currentSocketState: this.socket ? this.socket.readyState : \"null\",\n      });\n\n      try {\n        this.socket = new WebSocket(url);\n        debugLogger.websocket(\n          \"DEBUG\",\n          \"WebSocket object created successfully\",\n          {\n            url: this.websocketUrl + \"***\",\n            readyState: this.socket.readyState,\n            urlLength: url.length,\n          },\n        );\n      } catch (createError) {\n        debugLogger.websocket(\"ERROR\", \"Failed to create WebSocket object\", {\n          url: this.websocketUrl + \"***\",\n          error:\n            createError instanceof Error\n              ? createError.message\n              : String(createError),\n          errorType: createError?.constructor?.name,\n          timestamp: new Date().toISOString(),\n        });\n        // Reset socket to null on creation failure\n        this.socket = null;\n        throw createError;\n      }\n\n      debugLogger.websocket(\"DEBUG\", \"Setting up WebSocket event handlers\", {\n        url: this.websocketUrl + \"***\",\n        readyState: this.socket.readyState,\n        socketExists: !!this.socket,\n      });\n\n      this.socket.onopen = () => {\n        debugLogger.websocket(\"INFO\", \"WebSocket connection established\", {\n          timestamp: new Date().toISOString(),\n        });\n        performanceMonitor.recordWebSocketConnection(true);\n        wsStateMonitor.startMonitoring();\n\n        // Emit event to stop polling mode\n        globalEventBus.emit(\"websocket:polling:stop\");\n\n        try {\n          clearErrorBadge();\n        } catch {\n          // noop\n        }\n\n        chrome.alarms.clear(\"websocketReconnect\", () => {});\n\n        if (this.reconnectTimeout) {\n          clearTimeout(this.reconnectTimeout);\n          this.reconnectTimeout = null;\n        }\n\n        // Emit connected event\n        globalEventBus.emit(\"websocket:connected\");\n\n        // Emit state change for popup\n        globalEventBus.emit(\"websocket:state\", \"connected\");\n      };\n\n      this.socket.onmessage = async (event) => {\n        try {\n          const data: WebSocketMessage = JSON.parse(event.data);\n          debugLogger.websocket(\"DEBUG\", \"WebSocket message received\", {\n            type: data.type,\n            subtype: \"subtype\" in data ? data.subtype : undefined,\n            hasPush: \"push\" in data ? !!data.push : false,\n          });\n\n          switch (data.type) {\n          case \"tickle\":\n            if (data.subtype === \"push\") {\n              // Emit tickle:push event\n              globalEventBus.emit(\"websocket:tickle:push\");\n            } else if (data.subtype === \"device\") {\n              // Emit tickle:device event\n              globalEventBus.emit(\"websocket:tickle:device\");\n            }\n            break;\n\n          case \"push\":\n            if (\"push\" in data && data.push) {\n              // Emit push event with push data\n              globalEventBus.emit(\"websocket:push\", data.push);\n            } else {\n              debugLogger.websocket(\n                \"WARN\",\n                \"Push message received without push payload\",\n              );\n            }\n            break;\n\n          case \"nop\":\n            debugLogger.websocket(\n              \"DEBUG\",\n              \"Received nop (keep-alive) message\",\n              {\n                timestamp: new Date().toISOString(),\n              },\n            );\n            break;\n\n            // Note: 'ping' and 'pong' are WebSocket frame types, not message types\n            // They should not appear in the message data, but we handle them defensively\n\n          default:\n            debugLogger.websocket(\n              \"WARN\",\n              \"Unknown WebSocket message type received\",\n              {\n                type: (data as any).type,\n              },\n            );\n            break;\n          }\n        } catch (error) {\n          debugLogger.websocket(\n            \"ERROR\",\n            \"Failed to process WebSocket message\",\n            null,\n            error as Error,\n          );\n        }\n      };\n\n      this.socket.onerror = (error) => {\n        // WebSocket error events are generic Event objects, not Error instances\n        // This can occur during connection attempt, socket creation, or network issues\n        // CRITICAL: This error handler might be called when this.socket is null or undefined\n\n        const currentSocket = this.socket; // Local reference to avoid race conditions\n        const socketExists = !!currentSocket;\n        const socketState = socketExists\n          ? currentSocket.readyState\n          : \"no_socket\";\n        const isConnecting = socketExists\n          ? currentSocket.readyState === WS_READY_STATE.CONNECTING\n          : false;\n        const isConnected = socketExists\n          ? currentSocket.readyState === WS_READY_STATE.OPEN\n          : false;\n\n        const errorInfo = {\n          type: (error as any).type || \"unknown\",\n          target: (error as any).target ? \"WebSocket\" : \"unknown\",\n          readyState: socketState,\n          socketExists: socketExists,\n          url: this.websocketUrl,\n          timestamp: new Date().toISOString(),\n          reconnectAttempts: this.reconnectAttempts,\n          // Additional debugging info\n          isConnecting: isConnecting,\n          isConnected: isConnected,\n          errorEventDetails: {\n            timeStamp: (error as any).timeStamp,\n            bubbles: (error as any).bubbles,\n            cancelable: (error as any).cancelable,\n            currentTarget: (error as any).currentTarget\n              ? \"WebSocket\"\n              : \"unknown\",\n          },\n        };\n\n        debugLogger.websocket(\"ERROR\", \"WebSocket error occurred\", errorInfo);\n\n        // Create a proper Error object for tracking\n        const websocketError = new Error(\n          `WebSocket connection error: ${errorInfo.type} (socket: ${socketExists ? \"exists\" : \"null\"}, state: ${socketState})`,\n        );\n        websocketError.name = \"WebSocketError\";\n        globalErrorTracker.trackError(\n          websocketError,\n          {\n            category: \"WEBSOCKET\",\n            message: \"WebSocket error occurred\",\n            data: errorInfo,\n          },\n          \"WEBSOCKET\",\n        );\n      };\n\n      this.socket.onclose = (event) => {\n        const closeInfo: CloseInfo = {\n          code: event.code,\n          reason: event.reason || \"No reason provided\",\n          wasClean: event.wasClean,\n        };\n\n        debugLogger.websocket(\"WARN\", \"WebSocket connection closed\", {\n          ...closeInfo,\n          timestamp: new Date().toISOString(),\n          reconnectAttempts: this.reconnectAttempts,\n        });\n\n        // Emit disconnected event\n        globalEventBus.emit(\"websocket:disconnected\", {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean,\n        });\n\n        // Emit state change for popup\n        globalEventBus.emit(\"websocket:state\", \"disconnected\");\n\n        // Permanent error: stop and notify\n        if (\n          event.code === 1008 ||\n          event.code === 4001 ||\n          (event.code >= 4000 && event.code < 5000)\n        ) {\n          debugLogger.websocket(\n            \"ERROR\",\n            \"Permanent WebSocket error - stopping reconnection attempts\",\n            closeInfo,\n          );\n          try {\n            showPermanentWebSocketError(closeInfo);\n          } catch {\n            // noop\n          }\n          return;\n        }\n\n        // Transient: schedule next reconnect in ~30s (one-shot)\n        this.reconnectAttempts++;\n        performanceMonitor.recordWebSocketReconnection();\n\n        debugLogger.websocket(\n          \"INFO\",\n          \"Scheduling WebSocket reconnection (30s one-shot)\",\n          {\n            attempt: this.reconnectAttempts,\n            nextAttemptAt: new Date(Date.now() + 30000).toISOString(),\n          },\n        );\n\n        chrome.alarms.create(\"websocketReconnect\", {\n          when: Date.now() + 30000,\n        });\n      };\n    } catch (error) {\n      debugLogger.websocket(\n        \"ERROR\",\n        \"Failed to create WebSocket connection\",\n        {\n          url: this.websocketUrl + \"***\",\n          hasApiKey: !!this.getApiKey(),\n        },\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnect(): void {\n    if (this.socket) {\n      try {\n        debugLogger.websocket(\"INFO\", \"Disconnecting WebSocket\", {\n          readyState: this.socket.readyState,\n        });\n\n        this.socket.close();\n        this.socket = null;\n\n        wsStateMonitor.stopMonitoring();\n      } catch (error) {\n        debugLogger.websocket(\n          \"ERROR\",\n          \"Error disconnecting WebSocket\",\n          null,\n          error as Error,\n        );\n      }\n    }\n  }\n\n  /**\n   * Get reconnect attempts count\n   */\n  getReconnectAttempts(): number {\n    return this.reconnectAttempts;\n  }\n\n  /**\n   * Reset reconnect attempts\n   */\n  resetReconnectAttempts(): void {\n    this.reconnectAttempts = 0;\n  }\n}\n", "import type { User, Device, Push, DevicesResponse, PushesResponse } from \"../../types/domain\";\nimport { debugLogger } from \"../../lib/logging\";\n\nconst API_BASE_URL = 'https://api.pushbullet.com/v2';\nconst PUSHES_URL = `${API_BASE_URL}/pushes`;\nconst DEVICES_URL = `${API_BASE_URL}/devices`;\nconst USER_INFO_URL = `${API_BASE_URL}/users/me`;\n\ntype HeadersInit = Record<string, string>;\n\nfunction authHeaders(apiKey: string): HeadersInit {\n  return { 'Access-Token': apiKey };\n}\n\nexport async function fetchUserInfo(apiKey: string): Promise<User> {\n  const startTime = Date.now();\n  debugLogger.api('INFO', 'Fetching user info', { url: USER_INFO_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(USER_INFO_URL, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to fetch user info: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'User info fetch failed', {\n        url: USER_INFO_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      throw error;\n    }\n\n    const data = await response.json();\n    debugLogger.api('INFO', 'User info fetched successfully', {\n      url: USER_INFO_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      userEmail: data.email ? data.email.substring(0, 3) + '***' : 'unknown',\n      userName: data.name || 'unknown'\n    });\n    return data;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'User info fetch error', {\n      url: USER_INFO_URL,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function fetchDevices(apiKey: string): Promise<Device[]> {\n  const startTime = Date.now();\n  debugLogger.api('INFO', 'Fetching devices', { url: DEVICES_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(DEVICES_URL, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const error = new Error(`Failed to fetch devices: ${response.status} ${response.statusText}`);\n      debugLogger.api('ERROR', 'Devices fetch failed', {\n        url: DEVICES_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`\n      }, error);\n      throw error;\n    }\n\n    const data: DevicesResponse = await response.json();\n    const activeDevices = data.devices.filter(device => device.active);\n    debugLogger.api('INFO', 'Devices fetched successfully', {\n      url: DEVICES_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      totalDevices: data.devices.length,\n      activeDevices: activeDevices.length\n    });\n    return activeDevices;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'Devices fetch error', {\n      url: DEVICES_URL,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function fetchRecentPushes(apiKey: string): Promise<Push[]> {\n  const startTime = Date.now();\n  const url = `${PUSHES_URL}?limit=20`;\n  debugLogger.api('INFO', 'Fetching recent pushes', { url, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(url, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const error = new Error(`Failed to fetch pushes: ${response.status} ${response.statusText}`);\n      debugLogger.api('ERROR', 'Pushes fetch failed', {\n        url,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`\n      }, error);\n      throw error;\n    }\n\n    const data: PushesResponse = await response.json();\n    const filteredPushes = data.pushes.filter(push => {\n      const hasContent =\n        ('title' in push && push.title) ||\n        ('body' in push && push.body) ||\n        ('url' in push && push.url) ||\n        ('file_name' in push && push.file_name) ||\n        ('file_url' in push && push.file_url);\n      return hasContent && !push.dismissed;\n    });\n    debugLogger.api('INFO', 'Pushes fetched successfully', {\n      url,\n      status: response.status,\n      duration: `${duration}ms`,\n      totalPushes: data.pushes.length,\n      filteredPushes: filteredPushes.length,\n      pushTypes: filteredPushes.map(p => p.type).join(', ')\n    });\n    return filteredPushes;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'Pushes fetch error', {\n      url,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function registerDevice(\n  apiKey: string,\n  deviceIden: string | null,\n  deviceNickname: string\n): Promise<{ deviceIden: string; needsUpdate: boolean }> {\n  debugLogger.general('INFO', 'Starting device registration process', {\n    hasApiKey: !!apiKey,\n    currentDeviceIden: deviceIden,\n    deviceNickname,\n    timestamp: new Date().toISOString()\n  });\n\n  // Check if registration is already in progress\n  const result = await new Promise<{ deviceRegistrationInProgress?: boolean }>(resolve => {\n    chrome.storage.local.get(['deviceRegistrationInProgress'], (items) => resolve(items as any));\n  });\n\n  if (result.deviceRegistrationInProgress) {\n    debugLogger.general('INFO', 'Device registration already in progress - waiting for completion');\n    return new Promise(resolve => {\n      const listener = (changes: { [key: string]: chrome.storage.StorageChange }) => {\n        if (changes.deviceRegistrationInProgress && !changes.deviceRegistrationInProgress.newValue) {\n          chrome.storage.onChanged.removeListener(listener);\n          debugLogger.general('INFO', 'Device registration completed by another process');\n          resolve({ deviceIden: deviceIden || '', needsUpdate: false });\n        }\n      };\n      chrome.storage.onChanged.addListener(listener);\n    });\n  }\n\n  try {\n    await chrome.storage.local.set({ deviceRegistrationInProgress: true });\n\n    // Check if device is already registered\n    const storageResult = await new Promise<{ deviceIden?: string }>(resolve => {\n      chrome.storage.local.get(['deviceIden'], (items) => resolve(items as any));\n    });\n\n    if (storageResult.deviceIden) {\n      const existingIden = storageResult.deviceIden;\n      debugLogger.general('INFO', 'Device already registered', { deviceIden: existingIden, deviceNickname });\n\n      try {\n        await updateDeviceNickname(apiKey, existingIden, deviceNickname);\n        await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n        return { deviceIden: existingIden, needsUpdate: false };\n      } catch (error) {\n        debugLogger.general('WARN', 'Failed to update existing device, will re-register', {\n          error: (error as Error).message,\n          deviceIden: existingIden\n        });\n        await chrome.storage.local.remove(['deviceIden']);\n      }\n    }\n\n    // Register new device\n    debugLogger.general('INFO', 'Registering new device with Pushbullet API', { deviceNickname, url: DEVICES_URL });\n\n    const registrationData = {\n      nickname: deviceNickname,\n      model: 'Chrome',\n      manufacturer: 'Google',\n      push_token: '',\n      app_version: 8623,\n      icon: 'browser',\n      has_sms: false,\n      type: 'chrome'\n    };\n\n    debugLogger.api('INFO', 'Sending device registration request', {\n      url: DEVICES_URL,\n      method: 'POST',\n      deviceData: registrationData\n    });\n\n    const startTime = Date.now();\n    const response = await fetch(DEVICES_URL, {\n      method: 'POST',\n      headers: {\n        ...authHeaders(apiKey),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(registrationData)\n    });\n\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to register device: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'Device registration failed', {\n        url: DEVICES_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n      throw error;\n    }\n\n    const device: Device = await response.json();\n    const newDeviceIden = device.iden;\n\n    debugLogger.api('INFO', 'Device registered successfully', {\n      url: DEVICES_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      deviceIden: newDeviceIden,\n      deviceNickname: device.nickname\n    });\n\n    // Save device iden to storage\n    await chrome.storage.local.set({ deviceIden: newDeviceIden } as any);\n    await chrome.storage.local.set({ deviceRegistrationInProgress: false } as any);\n\n    debugLogger.general('INFO', 'Device registration completed', {\n      deviceIden: newDeviceIden,\n      deviceNickname: device.nickname\n    });\n\n    return { deviceIden: newDeviceIden, needsUpdate: false };\n  } catch (error) {\n    await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n    debugLogger.general('ERROR', 'Error in registerDevice function', {\n      errorMessage: (error as Error).message,\n      errorStack: (error as Error).stack\n    });\n    throw error;\n  }\n}\n\nexport async function updateDeviceNickname(\n  apiKey: string,\n  deviceIden: string,\n  newNickname: string\n): Promise<void> {\n  debugLogger.general('INFO', 'Updating device nickname', {\n    deviceIden,\n    newNickname,\n    timestamp: new Date().toISOString()\n  });\n\n  try {\n    const url = `${DEVICES_URL}/${deviceIden}`;\n    const startTime = Date.now();\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        ...authHeaders(apiKey),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ nickname: newNickname })\n    });\n\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to update device nickname: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'Device nickname update failed', {\n        url,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      throw error;\n    }\n\n    const device: Device = await response.json();\n    debugLogger.api('INFO', 'Device nickname updated successfully', {\n      url,\n      status: response.status,\n      duration: `${duration}ms`,\n      deviceIden,\n      newNickname: device.nickname\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Error in updateDeviceNickname function', {\n      errorMessage: (error as Error).message,\n      errorStack: (error as Error).stack\n    });\n    throw error;\n  }\n}\n\n", "/**\n * Storage Repository Pattern\n * \n * This module implements the Repository Pattern for storage operations.\n * It abstracts away the chrome.storage API, making the code more testable\n * and maintainable.\n * \n * Benefits:\n * - Testability: Easy to mock storage in tests\n * - Maintainability: Storage logic centralized in one place\n * - Clarity: Simple, clear API for storage operations\n */\n\n/**\n * Storage Repository Interface\n * \n * This interface defines the contract for storage operations.\n * Any implementation must provide these methods.\n */\nexport interface StorageRepository {\n  // API Key\n  getApiKey(): Promise<string | null>;\n  setApiKey(key: string | null): Promise<void>;\n\n  // Device Information\n  getDeviceIden(): Promise<string | null>;\n  setDeviceIden(iden: string | null): Promise<void>;\n\n  getDeviceNickname(): Promise<string | null>;\n  setDeviceNickname(nickname: string): Promise<void>;\n\n  // Settings\n  getAutoOpenLinks(): Promise<boolean>;\n  setAutoOpenLinks(enabled: boolean): Promise<void>;\n\n  getNotificationTimeout(): Promise<number>;\n  setNotificationTimeout(timeout: number): Promise<void>;\n\n  // Encryption\n  getEncryptionPassword(): Promise<string | null>;\n  setEncryptionPassword(password: string | null): Promise<void>;\n\n  // UI State\n  getScrollToRecentPushes(): Promise<boolean>;\n  setScrollToRecentPushes(scroll: boolean): Promise<void>;\n  removeScrollToRecentPushes(): Promise<void>;\n\n  // Bulk Operations\n  clear(): Promise<void>;\n  remove(keys: string[]): Promise<void>;\n}\n\n/**\n * Chrome Storage Repository Implementation\n * \n * This class implements the StorageRepository interface using the\n * chrome.storage API. It handles the promisification of the callback-based\n * chrome.storage API.\n */\nexport class ChromeStorageRepository implements StorageRepository {\n  /**\n   * Get API Key from local storage\n   * Security: API keys are stored in local storage (not synced) to prevent\n   * exposure through Chrome's sync infrastructure\n   */\n  async getApiKey(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['apiKey']);\n    return result.apiKey || null;\n  }\n\n  /**\n   * Set API Key in local storage\n   * Security: API keys are stored in local storage (not synced) to prevent\n   * exposure through Chrome's sync infrastructure\n   */\n  async setApiKey(key: string | null): Promise<void> {\n    if (key === null) {\n      await chrome.storage.local.remove(['apiKey']);\n    } else {\n      await chrome.storage.local.set({ apiKey: key });\n    }\n  }\n\n  /**\n   * Get Device Identifier from local storage\n   */\n  async getDeviceIden(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['deviceIden']);\n    return result.deviceIden || null;\n  }\n\n  /**\n   * Set Device Identifier in local storage\n   */\n  async setDeviceIden(iden: string | null): Promise<void> {\n    if (iden === null) {\n      await chrome.storage.local.remove(['deviceIden']);\n    } else {\n      await chrome.storage.local.set({ deviceIden: iden });\n    }\n  }\n\n  /**\n   * Get Device Nickname from sync storage\n   */\n  async getDeviceNickname(): Promise<string | null> {\n    const result = await chrome.storage.sync.get(['deviceNickname']);\n    return result.deviceNickname || null;\n  }\n\n  /**\n   * Set Device Nickname in sync storage\n   */\n  async setDeviceNickname(nickname: string): Promise<void> {\n    await chrome.storage.sync.set({ deviceNickname: nickname });\n  }\n\n  /**\n   * Get Auto Open Links setting from sync storage\n   */\n  async getAutoOpenLinks(): Promise<boolean> {\n    const result = await chrome.storage.sync.get(['autoOpenLinks']);\n    return result.autoOpenLinks !== undefined ? result.autoOpenLinks : false;\n  }\n\n  /**\n   * Set Auto Open Links setting in sync storage\n   */\n  async setAutoOpenLinks(enabled: boolean): Promise<void> {\n    await chrome.storage.sync.set({ autoOpenLinks: enabled });\n  }\n\n  /**\n   * Get Notification Timeout from sync storage\n   */\n  async getNotificationTimeout(): Promise<number> {\n    const result = await chrome.storage.sync.get(['notificationTimeout']);\n    return result.notificationTimeout !== undefined ? result.notificationTimeout : 5000;\n  }\n\n  /**\n   * Set Notification Timeout in sync storage\n   */\n  async setNotificationTimeout(timeout: number): Promise<void> {\n    await chrome.storage.sync.set({ notificationTimeout: timeout });\n  }\n\n  /**\n   * Get Encryption Password from local storage\n   */\n  async getEncryptionPassword(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['encryptionPassword']);\n    return result.encryptionPassword || null;\n  }\n\n  /**\n   * Set Encryption Password in local storage\n   */\n  async setEncryptionPassword(password: string | null): Promise<void> {\n    if (password === null) {\n      await chrome.storage.local.remove(['encryptionPassword']);\n    } else {\n      await chrome.storage.local.set({ encryptionPassword: password });\n    }\n  }\n\n  /**\n   * Get Scroll to Recent Pushes flag from local storage\n   */\n  async getScrollToRecentPushes(): Promise<boolean> {\n    const result = await chrome.storage.local.get(['scrollToRecentPushes']);\n    return result.scrollToRecentPushes || false;\n  }\n\n  /**\n   * Set Scroll to Recent Pushes flag in local storage\n   */\n  async setScrollToRecentPushes(scroll: boolean): Promise<void> {\n    await chrome.storage.local.set({ scrollToRecentPushes: scroll });\n  }\n\n  /**\n   * Remove Scroll to Recent Pushes flag from local storage\n   */\n  async removeScrollToRecentPushes(): Promise<void> {\n    await chrome.storage.local.remove(['scrollToRecentPushes']);\n  }\n\n  /**\n   * Clear all storage (both sync and local)\n   */\n  async clear(): Promise<void> {\n    await Promise.all([\n      chrome.storage.sync.clear(),\n      chrome.storage.local.clear()\n    ]);\n  }\n\n  /**\n   * Remove specific keys from storage\n   * Removes from both sync and local storage\n   */\n  async remove(keys: string[]): Promise<void> {\n    await Promise.all([\n      chrome.storage.sync.remove(keys),\n      chrome.storage.local.remove(keys)\n    ]);\n  }\n}\n\n/**\n * Create a singleton instance of the storage repository\n * This ensures we have a single point of access throughout the application\n */\nexport const storageRepository = new ChromeStorageRepository();\n\n", "import type { SessionCache, InitializationState } from \"../../types/domain\";\nimport { debugLogger } from \"../../lib/logging\";\nimport {\n  fetchUserInfo,\n  fetchDevices,\n  fetchRecentPushes,\n  registerDevice,\n} from \"../api/client\";\nimport { storageRepository } from \"../../infrastructure/storage/storage.repository\";\n\n// Session cache state\nexport const sessionCache: SessionCache = {\n  userInfo: null,\n  devices: [],\n  recentPushes: [],\n  isAuthenticated: false,\n  lastUpdated: 0,\n  autoOpenLinks: true,\n  deviceNickname: \"Chrome\",\n};\n\n// Initialization state tracking\nexport const initializationState: InitializationState = {\n  inProgress: false,\n  completed: false,\n  error: null,\n  timestamp: null,\n};\n\n// Promise singleton for single-flight initialization\n// Prevents race conditions when multiple events trigger initialization concurrently\nlet initPromise: Promise<string | null> | null = null;\n\n/**\n * Get the current initialization promise (if any)\n * This allows callers to await ongoing initialization instead of polling\n */\nexport function getInitPromise(): Promise<string | null> | null {\n  return initPromise;\n}\n\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.sync\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\nexport async function initializeSessionCache(\n  source = \"unknown\",\n  connectWebSocketFn?: () => void,\n  stateSetters?: {\n    setApiKey: (key: string | null) => void;\n    setDeviceIden: (iden: string | null) => void;\n    setAutoOpenLinks: (value: boolean) => void;\n    setDeviceNickname: (nickname: string) => void;\n    setNotificationTimeout: (timeout: number) => void;\n  },\n): Promise<string | null> {\n  // If initialization is already in progress, return the existing promise\n  // This allows concurrent callers to await the same initialization\n  if (initializationState.inProgress && initPromise) {\n    debugLogger.general(\n      \"INFO\",\n      \"Initialization already in progress, returning existing promise\",\n      {\n        source,\n        existingInitialization: true,\n      },\n    );\n    return initPromise;\n  }\n\n  if (initializationState.completed) {\n    debugLogger.general(\"WARN\", \"Already initialized, skipping\", {\n      source,\n      previousTimestamp: initializationState.timestamp,\n    });\n    return null;\n  }\n\n  initializationState.inProgress = true;\n\n  // Create and store the initialization promise\n  initPromise = (async () => {\n    try {\n      debugLogger.general(\"INFO\", \"Initializing session cache\", {\n        source,\n        timestamp: new Date().toISOString(),\n      });\n\n      // Load core settings from sync storage\n      debugLogger.storage(\n        \"DEBUG\",\n        \"Loading initial configuration from storage repository\",\n      );\n\n      // Get API key and device iden from storage repository\n      const apiKeyValue = await storageRepository.getApiKey();\n      const deviceIdenValue = await storageRepository.getDeviceIden();\n\n      if (stateSetters) {\n        stateSetters.setApiKey(apiKeyValue);\n        stateSetters.setDeviceIden(deviceIdenValue);\n      }\n\n      // Get settings with defaults from storage repository\n      const autoOpenLinksValue = await storageRepository.getAutoOpenLinks();\n      const notificationTimeoutValue =\n        await storageRepository.getNotificationTimeout();\n      const deviceNicknameValue =\n        (await storageRepository.getDeviceNickname()) || \"Chrome\";\n\n      if (stateSetters) {\n        stateSetters.setAutoOpenLinks(autoOpenLinksValue);\n        stateSetters.setNotificationTimeout(notificationTimeoutValue);\n        stateSetters.setDeviceNickname(deviceNicknameValue);\n      }\n\n      sessionCache.autoOpenLinks = autoOpenLinksValue;\n      sessionCache.deviceNickname = deviceNicknameValue;\n\n      debugLogger.storage(\n        \"INFO\",\n        \"Loaded configuration from storage repository\",\n        {\n          hasApiKey: !!apiKeyValue,\n          hasDeviceIden: !!deviceIdenValue,\n          autoOpenLinks: autoOpenLinksValue,\n          deviceNickname: deviceNicknameValue,\n          notificationTimeout: notificationTimeoutValue,\n        },\n      );\n\n      debugLogger.general(\"DEBUG\", \"API key status\", {\n        hasApiKey: !!apiKeyValue,\n        apiKeyLength: apiKeyValue ? apiKeyValue.length : 0,\n      });\n\n      if (apiKeyValue) {\n        debugLogger.general(\n          \"INFO\",\n          \"API key available - initializing session data\",\n        );\n\n        // Fetch user info\n        const userInfo = await fetchUserInfo(apiKeyValue);\n        sessionCache.userInfo = userInfo;\n\n        // Fetch devices\n        const devices = await fetchDevices(apiKeyValue);\n        sessionCache.devices = devices;\n\n        // Fetch recent pushes\n        const pushes = await fetchRecentPushes(apiKeyValue);\n        sessionCache.recentPushes = pushes;\n\n        // Update session cache\n        sessionCache.isAuthenticated = true;\n        sessionCache.lastUpdated = Date.now();\n\n        debugLogger.general(\"INFO\", \"Session cache populated successfully\", {\n          hasUserInfo: !!sessionCache.userInfo,\n          deviceCount: sessionCache.devices.length,\n          pushCount: sessionCache.recentPushes.length,\n          lastUpdated: new Date(sessionCache.lastUpdated).toISOString(),\n        });\n\n        // Register device\n        await registerDevice(apiKeyValue, deviceIdenValue, deviceNicknameValue);\n\n        // Connect WebSocket if the function is provided\n        if (connectWebSocketFn) {\n          debugLogger.general(\"INFO\", \"Session initialized, connecting WebSocket.\");\n          connectWebSocketFn();\n        }\n\n        // Start periodic health check\n        chrome.alarms.create(\"websocketHealthCheck\", { periodInMinutes: 1 });\n        debugLogger.general(\"DEBUG\", \"WebSocket health check alarm created\", {\n          interval: \"5 minutes\",\n        });\n      } else {\n        debugLogger.general(\n          \"WARN\",\n          \"No API key available - session cache not initialized\",\n        );\n      }\n\n      initializationState.completed = true;\n      initializationState.timestamp = Date.now();\n      debugLogger.general(\"INFO\", \"Initialization completed successfully\", {\n        source,\n        timestamp: new Date(initializationState.timestamp).toISOString(),\n      });\n\n      return apiKeyValue;\n    } catch (error) {\n      initializationState.error = error as Error;\n      debugLogger.general(\n        \"ERROR\",\n        \"Error initializing session cache\",\n        {\n          error:\n            (error as Error).message ||\n            (error as Error).name ||\n            \"Unknown error\",\n        },\n        error as Error,\n      );\n      sessionCache.isAuthenticated = false;\n      throw error;\n    } finally {\n      initializationState.inProgress = false;\n      // Clear the promise reference to allow retry on failure\n      initPromise = null;\n    }\n  })();\n\n  return initPromise;\n}\n\nexport async function refreshSessionCache(apiKeyParam: string): Promise<void> {\n  debugLogger.general(\"INFO\", \"Refreshing session cache\", {\n    hasApiKey: !!apiKeyParam,\n    timestamp: new Date().toISOString(),\n  });\n\n  try {\n    if (apiKeyParam) {\n      debugLogger.general(\n        \"DEBUG\",\n        \"API key available - refreshing session data\",\n      );\n\n      // Fetch user info\n      debugLogger.general(\"DEBUG\", \"Refreshing user info\");\n      const userInfo = await fetchUserInfo(apiKeyParam);\n      sessionCache.userInfo = userInfo;\n\n      // Fetch devices\n      debugLogger.general(\"DEBUG\", \"Refreshing devices\");\n      const devices = await fetchDevices(apiKeyParam);\n      sessionCache.devices = devices;\n\n      // Fetch recent pushes\n      debugLogger.general(\"DEBUG\", \"Refreshing recent pushes\");\n      const pushes = await fetchRecentPushes(apiKeyParam);\n      sessionCache.recentPushes = pushes;\n\n      // Update session cache\n      sessionCache.isAuthenticated = true;\n      sessionCache.lastUpdated = Date.now();\n\n      debugLogger.general(\"INFO\", \"Session cache refreshed successfully\", {\n        hasUserInfo: !!sessionCache.userInfo,\n        deviceCount: sessionCache.devices.length,\n        pushCount: sessionCache.recentPushes.length,\n        lastUpdated: new Date(sessionCache.lastUpdated).toISOString(),\n      });\n    } else {\n      debugLogger.general(\n        \"WARN\",\n        \"No API key available - cannot refresh session cache\",\n      );\n      sessionCache.isAuthenticated = false;\n    }\n  } catch (error) {\n    debugLogger.general(\n      \"ERROR\",\n      \"Error refreshing session cache\",\n      {\n        error: (error as Error).message,\n      },\n      error as Error,\n    );\n    throw error;\n  }\n}\n", "import { debugLogger } from '../../lib/logging';\nimport { storageRepository } from '../../infrastructure/storage/storage.repository';\n\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.local\n// Security: API keys are stored in local storage (not synced) to prevent exposure\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n/**\n * Ensure critical configuration is loaded from storage\n * Used for service worker wake-ups to rehydrate state\n *\n * ARCHITECTURAL PATTERN: Uses StorageRepository for centralized storage access\n * All storage operations go through the repository pattern - NO direct chrome.storage calls\n *\n * @param stateSetters - Object containing state setter functions\n * @param stateGetters - Object containing state getter functions\n */\nexport async function ensureConfigLoaded(\n  stateSetters?: {\n    setApiKey: (key: string | null) => void;\n    setDeviceIden: (iden: string | null) => void;\n    setAutoOpenLinks: (value: boolean) => void;\n    setDeviceNickname: (nickname: string) => void;\n    setNotificationTimeout: (timeout: number) => void;\n  },\n  stateGetters?: {\n    getApiKey: () => string | null;\n    getDeviceIden: () => string | null;\n    getAutoOpenLinks: () => boolean;\n    getDeviceNickname: () => string;\n    getNotificationTimeout: () => number;\n  }\n): Promise<void> {\n  try {\n    if (!stateSetters || !stateGetters) {\n      // No state management provided, just return\n      return;\n    }\n\n    // Determine what needs to be loaded\n    const needsApiKey = !stateGetters.getApiKey();\n    const needsDeviceIden = !stateGetters.getDeviceIden();\n    const needsNickname = stateGetters.getDeviceNickname() === null || stateGetters.getDeviceNickname() === undefined;\n    const needsAutoOpen = stateGetters.getAutoOpenLinks() === null || stateGetters.getAutoOpenLinks() === undefined;\n    const needsTimeout = stateGetters.getNotificationTimeout() === null || stateGetters.getNotificationTimeout() === undefined;\n\n    // Load API key from repository (local storage, not synced)\n    if (needsApiKey) {\n      try {\n        const apiKey = await storageRepository.getApiKey();\n        if (apiKey) {\n          stateSetters.setApiKey(apiKey);\n        }\n      } catch {\n        // Swallow storage errors in ensureConfigLoaded\n      }\n    }\n\n    // Load device identifier from repository (local storage)\n    if (needsDeviceIden) {\n      try {\n        const deviceIden = await storageRepository.getDeviceIden();\n        if (deviceIden) {\n          stateSetters.setDeviceIden(deviceIden);\n        }\n      } catch {\n        // Swallow storage errors in ensureConfigLoaded\n      }\n    }\n\n    // Load device nickname from repository (synced storage)\n    if (needsNickname) {\n      try {\n        const deviceNickname = await storageRepository.getDeviceNickname();\n        if (deviceNickname !== null && deviceNickname !== undefined) {\n          stateSetters.setDeviceNickname(deviceNickname);\n        }\n      } catch {\n        // Swallow storage errors in ensureConfigLoaded\n      }\n    }\n\n    // Load auto-open links setting from repository (synced storage)\n    if (needsAutoOpen) {\n      try {\n        const autoOpenLinks = await storageRepository.getAutoOpenLinks();\n        if (autoOpenLinks !== null && autoOpenLinks !== undefined) {\n          stateSetters.setAutoOpenLinks(autoOpenLinks);\n        }\n      } catch {\n        // Swallow storage errors in ensureConfigLoaded\n      }\n    }\n\n    // Load notification timeout from repository (synced storage)\n    if (needsTimeout) {\n      try {\n        const notificationTimeout = await storageRepository.getNotificationTimeout();\n        if (notificationTimeout !== null && notificationTimeout !== undefined) {\n          stateSetters.setNotificationTimeout(notificationTimeout);\n        }\n      } catch {\n        // Swallow storage errors in ensureConfigLoaded\n      }\n    }\n\n    // Log completion\n    try {\n      debugLogger.storage('DEBUG', 'ensureConfigLoaded completed', {\n        hasApiKey: !!stateGetters.getApiKey(),\n        hasDeviceIden: !!stateGetters.getDeviceIden(),\n        autoOpenLinks: stateGetters.getAutoOpenLinks(),\n        notificationTimeout: stateGetters.getNotificationTimeout(),\n        deviceNickname: stateGetters.getDeviceNickname()\n      });\n    } catch {\n      // Swallow logging errors in ensureConfigLoaded\n    }\n  } catch (e) {\n    try {\n      debugLogger.storage('WARN', 'ensureConfigLoaded encountered an error', {\n        error: e && (e as Error).message\n      });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n", "/**\n * Pushbullet End-to-End Encryption (E2EE) Decryption\n * \n * Based on Pushbullet's E2EE specification:\n * - Key derivation: PBKDF2 with HMAC-SHA256\n * - Encryption: AES-256-GCM\n * - Encoding: Base64\n */\n\nimport type { Push } from '../../types/domain';\n\nexport class PushbulletCrypto {\n  /**\n   * Generate encryption/decryption key from password\n   * @param password - User's encryption password\n   * @param userIden - User's iden (used as salt)\n   * @returns Derived key for AES-GCM\n   */\n  static async deriveKey(password: string, userIden: string): Promise<CryptoKey> {\n    // Check if Web Crypto API is available\n    if (!globalThis.crypto || !crypto.subtle) {\n      throw new Error('Web Crypto API unavailable - requires HTTPS or localhost');\n    }\n\n    // Convert password to bytes\n    const encoder = new TextEncoder();\n    const passwordBytes = encoder.encode(password);\n    \n    // Import password as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      passwordBytes,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits', 'deriveKey']\n    );\n    \n    // Use user iden as salt\n    const salt = encoder.encode(userIden);\n    \n    // Derive key using PBKDF2\n    const key = await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: salt,\n        iterations: 30000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      { name: 'AES-GCM', length: 256 },\n      false,\n      ['decrypt']\n    );\n    \n    return key;\n  }\n  \n  /**\n   * Decrypt an encrypted message\n   * @param encodedMessage - Base64 encoded encrypted message\n   * @param key - Decryption key\n   * @returns Decrypted message object\n   */\n  static async decryptMessage(encodedMessage: string, key: CryptoKey): Promise<unknown> {\n    try {\n      // Decode from base64\n      const encryptedData = this.base64ToBytes(encodedMessage);\n      \n      // Parse the encoded message format:\n      // version (1 byte) + tag (16 bytes) + iv (12 bytes) + ciphertext (rest)\n      const version = encryptedData[0];\n      \n      if (version !== 49) { // ASCII '1'\n        throw new Error(`Unsupported encryption version: ${version}`);\n      }\n      \n      const tag = encryptedData.slice(1, 17);        // 16 bytes\n      const iv = encryptedData.slice(17, 29);        // 12 bytes (96 bits)\n      const ciphertext = encryptedData.slice(29);    // Rest\n      \n      // Combine ciphertext and tag for AES-GCM\n      const combined = new Uint8Array(ciphertext.length + tag.length);\n      combined.set(ciphertext);\n      combined.set(tag, ciphertext.length);\n      \n      // Decrypt using AES-GCM\n      const decrypted = await crypto.subtle.decrypt(\n        {\n          name: 'AES-GCM',\n          iv: iv,\n          tagLength: 128 // 16 bytes = 128 bits\n        },\n        key,\n        combined\n      );\n      \n      // Convert decrypted bytes to string\n      const decoder = new TextDecoder();\n      const decryptedText = decoder.decode(decrypted);\n      \n      // Parse as JSON\n      return JSON.parse(decryptedText);\n    } catch {\n      // SECURITY FIX (M-04): Don't log sensitive crypto data\n      console.error('Decryption error - check encryption password');\n      throw new Error('Failed to decrypt message. Check your encryption password.');\n    }\n  }\n  \n  /**\n   * Convert base64 string to Uint8Array\n   * @param base64 - Base64 encoded string\n   * @returns Decoded bytes\n   */\n  static base64ToBytes(base64: string): Uint8Array {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n  \n  /**\n   * Decrypt a Pushbullet encrypted push\n   * @param encryptedPush - Push object with 'encrypted' and 'ciphertext' fields\n   * @param password - User's encryption password\n   * @param userIden - User's iden\n   * @returns Decrypted push data\n   */\n  static async decryptPush(encryptedPush: Push, password: string, userIden: string): Promise<Push> {\n    if (!encryptedPush.encrypted || !encryptedPush.ciphertext) {\n      throw new Error('Push is not encrypted');\n    }\n    \n    // Derive key from password\n    const key = await this.deriveKey(password, userIden);\n    \n    // Decrypt the ciphertext\n    const decryptedData = await this.decryptMessage(encryptedPush.ciphertext, key);\n    \n    // Return decrypted push with original metadata\n    return {\n      ...encryptedPush,\n      ...(decryptedData as object),\n      encrypted: false // Mark as decrypted\n    } as Push;\n  }\n}\n\n", "/**\n * Global state management for background service worker\n */\n\nimport type { InitializationState } from '../types/domain';\nimport { WebSocketClient } from '../app/ws/client';\n\n// API constants\nexport const API_BASE_URL = 'https://api.pushbullet.com/v2';\nexport const PUSHES_URL = `${API_BASE_URL}/pushes`;\nexport const DEVICES_URL = `${API_BASE_URL}/devices`;\nexport const USER_INFO_URL = `${API_BASE_URL}/users/me`;\nexport const WEBSOCKET_URL = 'wss://stream.pushbullet.com/websocket/';\n\n// Global state variables\nlet apiKey: string | null = null;\nlet deviceIden: string | null = null;\nlet deviceNickname = 'Chrome';\nlet autoOpenLinks = true;\nlet notificationTimeout = 10000;\nlet websocketClient: WebSocketClient | null = null;\nlet pollingMode = false;\nlet lastDisconnectionNotification = 0;\n\n// Constants\nexport const DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\nexport const DISCONNECTION_NOTIFICATION_THRESHOLD = 300000; // 5 minutes\n\n// Initialization state\nexport const initializationState: InitializationState = {\n  inProgress: false,\n  completed: false,\n  error: null,\n  timestamp: null\n};\n\n// NO ENCRYPTION/DECRYPTION - API key is stored in plain text in chrome.storage.local\n// Security: API keys are stored in local storage (not synced) to prevent exposure\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n// Getters and setters\nexport function getApiKey(): string | null {\n  return apiKey;\n}\n\nexport function setApiKey(key: string | null): void {\n  apiKey = key;\n}\n\nexport function getDeviceIden(): string | null {\n  return deviceIden;\n}\n\nexport function setDeviceIden(iden: string | null): void {\n  deviceIden = iden;\n}\n\nexport function getDeviceNickname(): string {\n  return deviceNickname;\n}\n\nexport function setDeviceNickname(nickname: string): void {\n  deviceNickname = nickname;\n}\n\nexport function getAutoOpenLinks(): boolean {\n  return autoOpenLinks;\n}\n\nexport function setAutoOpenLinks(value: boolean): void {\n  autoOpenLinks = value;\n}\n\nexport function getNotificationTimeout(): number {\n  return notificationTimeout;\n}\n\nexport function setNotificationTimeout(timeout: number): void {\n  notificationTimeout = timeout;\n}\n\nexport function getWebSocketClient(): WebSocketClient | null {\n  return websocketClient;\n}\n\nexport function setWebSocketClient(client: WebSocketClient | null): void {\n  websocketClient = client;\n}\n\nexport function isPollingMode(): boolean {\n  return pollingMode;\n}\n\nexport function setPollingMode(mode: boolean): void {\n  pollingMode = mode;\n}\n\nexport function getLastDisconnectionNotification(): number {\n  return lastDisconnectionNotification;\n}\n\nexport function setLastDisconnectionNotification(timestamp: number): void {\n  lastDisconnectionNotification = timestamp;\n}\n\n", "/**\n * Utility functions for background service worker\n */\n\nimport { debugLogger } from '../lib/logging';\nimport { performanceMonitor } from '../lib/perf';\nimport { sessionCache } from '../app/session';\nimport { fetchRecentPushes } from '../app/api/client';\nimport {\n  getApiKey,\n  getAutoOpenLinks,\n  setPollingMode,\n  isPollingMode\n} from './state';\nimport type { Push, LinkPush } from '../types/domain';\nimport { isLinkPush } from '../types/domain';\nimport { createNotificationWithTimeout } from '../app/notifications';\nimport { ensureConfigLoaded } from '../app/reconnect';\n\n\n\n// Guard flag to prevent concurrent context menu setup\n// Ensures idempotent behavior when multiple startup events fire\nlet isSettingUpContextMenu = false;\n\n/**\n * Connection status for icon updates\n */\nexport type ConnectionStatus = 'connected' | 'connecting' | 'disconnected';\n\n/**\n * Sanitize text to prevent XSS attacks\n * Removes HTML tags and dangerous characters\n *\n * DEFENSE-IN-DEPTH STRATEGY:\n * 1. This function provides basic sanitization for Chrome notification content\n * 2. The extension's CSP (Content Security Policy) provides strong XSS protection\n * 3. UI code (popup, options, etc.) uses textContent instead of innerHTML for user data\n * 4. This regex-based approach is sufficient for notification text (not rendered as HTML)\n *\n * NOTE: For HTML rendering, use textContent or a library like DOMPurify.\n * The popup's displayPushes() function correctly uses textContent for all user data.\n */\nfunction sanitizeText(text: string): string {\n  if (!text) return '';\n\n  // Remove HTML tags\n  let sanitized = text.replace(/<[^>]*>/g, '');\n\n  // Remove script-like content\n  sanitized = sanitized.replace(/javascript:/gi, '');\n  sanitized = sanitized.replace(/on\\w+\\s*=/gi, '');\n\n  // Trim and limit length\n  sanitized = sanitized.trim().substring(0, 1000);\n\n  return sanitized;\n}\n\n/**\n * Sanitize URL to prevent XSS attacks\n * Validates URL format and ensures it's safe\n */\nfunction sanitizeUrl(url: string): string {\n  if (!url) return '';\n  \n  try {\n    const urlObj = new URL(url);\n    // Only allow http/https protocols\n    if (urlObj.protocol !== 'http:' && urlObj.protocol !== 'https:') {\n      return '';\n    }\n    return url;\n  } catch {\n    debugLogger.general('WARN', 'Invalid URL provided', { url });\n    return '';\n  }\n}\n\n/**\n * Validates if a given URL belongs to trusted domains for image loading.\n * This includes Pushbullet domains and Google secure content domains.\n * @param urlString The URL to validate.\n * @returns True if the URL is from a trusted domain, false otherwise.\n */\nfunction isTrustedImageUrl(urlString: string): boolean {\n  if (!urlString) {\n    return false;\n  }\n\n  try {\n    const url = new URL(urlString);\n    // Trust Pushbullet domains and Google secure content domains\n    return url.hostname.endsWith('.pushbullet.com') || \n           url.hostname === 'lh3.googleusercontent.com' ||\n           url.hostname === 'lh4.googleusercontent.com' ||\n           url.hostname === 'lh5.googleusercontent.com' ||\n           url.hostname === 'lh6.googleusercontent.com';\n  } catch {\n    debugLogger.general('WARN', 'Could not parse URL for domain check', { url: urlString });\n    return false;\n  }\n}\n\n/**\n * Update extension icon tooltip to show current state\n */\nexport function updateExtensionTooltip(stateDescription: string): void {\n  try {\n    chrome.action.setTitle({ title: stateDescription });\n    debugLogger.general('DEBUG', 'Updated extension tooltip', { stateDescription });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Exception setting tooltip', {\n      stateDescription,\n      error: (error as Error).message\n    });\n  }\n}\n\n/**\n * Update extension icon based on connection status\n * Uses badge color instead of different icon files since service workers have issues loading icons\n */\nexport function updateConnectionIcon(status: ConnectionStatus): void {\n  try {\n    // Set badge text\n    const badgeText = status === 'connected' ? '\u25CF' :\n      status === 'connecting' ? '\u25D0' :\n        '\u25CB';\n\n    // Set badge color\n    const badgeColor = status === 'connected' ? '#4CAF50' :  // Green\n      status === 'connecting' ? '#FFC107' :  // Yellow\n        '#F44336';  // Red\n\n    chrome.action.setBadgeText({ text: badgeText });\n    chrome.action.setBadgeBackgroundColor({ color: badgeColor });\n\n    debugLogger.general('DEBUG', 'Updated connection status badge', { status, badgeText, badgeColor });\n  } catch {\n    debugLogger.general('ERROR', 'Exception setting badge', {\n      status,\n      error: (error as Error).message\n    });\n  }\n}\n\n/**\n * Refresh pushes from API and show notifications for new ones\n */\nexport async function refreshPushes(notificationDataStore?: Map<string, Push>): Promise<void> {\n  // RACE CONDITION FIX: Ensure configuration is loaded before processing pushes\n  // This prevents the autoOpenLinks setting from being its default (false) value\n  // when a push arrives before settings have finished loading from storage\n  await ensureConfigLoaded();\n\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot refresh pushes - no API key');\n    return;\n  }\n\n  try {\n    debugLogger.general('DEBUG', 'Refreshing pushes from API');\n\n    // Get current push idens to detect new ones\n    const oldPushIdens = new Set(sessionCache.recentPushes.map(p => p.iden));\n\n    const pushes = await fetchRecentPushes(apiKey);\n\n    // Find NEW pushes (not in old cache)\n    const newPushes = pushes.filter(p => !oldPushIdens.has(p.iden));\n\n    debugLogger.general('INFO', 'Pushes refreshed successfully', {\n      totalPushes: pushes.length,\n      newPushes: newPushes.length\n    });\n\n    // Update cache\n    sessionCache.recentPushes = pushes;\n    sessionCache.lastUpdated = Date.now();\n\n    // Show notifications for NEW pushes\n    for (const push of newPushes) {\n      debugLogger.general('INFO', 'Showing notification for new push from tickle', {\n        pushIden: push.iden,\n        pushType: push.type\n      });\n      // Don't await - fire and forget\n      showPushNotification(push, notificationDataStore).catch((error) => {\n        debugLogger.general('ERROR', 'Failed to show notification', { pushIden: push.iden }, error);\n      });\n\n      // Auto-open links if setting is enabled\n      const autoOpenLinks = getAutoOpenLinks();\n      if (autoOpenLinks && isLinkPush(push)) {\n        debugLogger.general('INFO', 'Auto-opening link push from tickle', {\n          pushIden: push.iden,\n          url: (push as LinkPush).url\n        });\n\n        chrome.tabs.create({\n          url: (push as LinkPush).url,\n          active: false // Open in background to avoid disrupting user\n        }).catch((error) => {\n          debugLogger.general('ERROR', 'Failed to auto-open link from tickle', {\n            url: (push as LinkPush).url\n          }, error);\n        });\n      }\n    }\n\n    // Notify popup\n    chrome.runtime.sendMessage({\n      action: 'pushesUpdated',\n      pushes: pushes\n    }).catch(() => {\n      // Popup may not be open\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to refresh pushes', null, error as Error);\n  }\n}\n\n/**\n * Counter for notification IDs\n */\nlet counter = 0;\n\n/**\n * Show push notification\n */\nexport async function showPushNotification(push: Push, notificationDataStore?: Map<string, Push>): Promise<void> {\n  try {\n    const notificationId = `pushbullet-push-${counter++}-${Date.now()}`;\n    const baseOptions = {\n      iconUrl: chrome.runtime.getURL('icons/icon128.png'),\n    };\n\n    let notificationOptions: chrome.notifications.NotificationOptions = {\n      ...baseOptions,\n      type: 'basic',\n      title: 'Pushbullet',\n      message: 'New push received'\n    };\n\n    // Handle undecrypted pushes first\n    if (push.encrypted && 'ciphertext' in push) {\n      notificationOptions = {\n        ...baseOptions,\n        type: 'basic',\n        title: 'Pushbullet',\n        message: 'An encrypted push was received. To view future encrypted pushes you need to add the correct end2end password in options'\n      };\n      debugLogger.notifications('INFO', 'Showing notification for undecrypted push');\n    } else if ((push as any).type === 'sms_changed' && (push as any).notifications && (push as any).notifications.length > 0) {\n      // Handle MMS / SMS with image\n      const mms = (push as any).notifications[0];\n      notificationOptions = {\n        ...baseOptions,\n        type: 'image',\n        title: mms.title || 'New Message',\n        message: mms.body || '',\n        imageUrl: mms.image_url || '' // Set the image for the notification\n      };\n      debugLogger.notifications('INFO', 'Showing image notification for MMS');\n    } else {\n      // Standard handler for note, link, and file\n      let title = 'Pushbullet';\n      let message = '';\n\n      if (push.type === 'note') {\n        title = push.title || 'New Note';\n        message = push.body || '';\n        \n        notificationOptions = {\n          ...baseOptions,\n          type: 'basic',\n          title: title,\n          message: message\n        };\n      } else if (push.type === 'link') {\n        title = push.title || push.url || 'New Link';\n        message = push.url || '';\n        \n        notificationOptions = {\n          ...baseOptions,\n          type: 'basic',\n          title: title,\n          message: message\n        };\n      } else if (push.type === 'file') {\n        // Security validation for image URLs in file pushes\n        debugLogger.notifications('DEBUG', 'Complete file push object received', { push });\n        \n        let fileTitle = 'New File';\n        let fileMessage = '';\n        \n        if ((push as any).title) { // MMS-style file push\n          fileTitle = (push as any).title;\n          fileMessage = (push as any).body || `Image (${(push as any).file_type})`;\n        } else { // Regular file push\n          fileTitle = `New File: ${(push as any).file_name || 'unknown file'}`;\n          fileMessage = (push as any).body || (push as any).file_type || '';\n        }\n\n        // Security validation for image URLs - check both image_url and file_url\n        const imageUrl = (push as any).image_url;\n        const fileUrl = (push as any).file_url;\n        \n        // Determine which URL to use for image preview\n        let previewUrl = null;\n        if (imageUrl && isTrustedImageUrl(imageUrl)) {\n          previewUrl = imageUrl;\n        } else if (fileUrl && isTrustedImageUrl(fileUrl) && (push as any).file_type?.startsWith('image/')) {\n          previewUrl = fileUrl;\n        }\n\n        if (previewUrl) {\n          // Show image notification for trusted Pushbullet URLs\n          notificationOptions = {\n            ...baseOptions,\n            type: 'image',\n            title: fileTitle,\n            message: fileMessage,\n            imageUrl: previewUrl\n          };\n          debugLogger.notifications('INFO', 'Showing image notification for trusted file push', { \n            fileName: (push as any).file_name,\n            previewUrl: previewUrl \n          });\n        } else {\n          // Fallback to basic notification for security\n          notificationOptions = {\n            ...baseOptions,\n            type: 'basic',\n            title: fileTitle,\n            message: fileMessage\n          };\n          if (imageUrl && !isTrustedImageUrl(imageUrl)) {\n            debugLogger.notifications('WARN', 'Ignored image from untrusted domain for file push', { \n              imageUrl: imageUrl \n            });\n          }\n        }\n      } else if (push.type === 'mirror') {\n        const mirrorTitle = push.title || push.application_name || 'Notification';\n        const mirrorMessage = push.body || '';\n\n        // Security validation for image URLs\n        const mirrorImageUrl = (push as any).image_url;\n        if (mirrorImageUrl && isTrustedImageUrl(mirrorImageUrl)) {\n          notificationOptions = {\n            ...baseOptions,\n            type: 'image',\n            title: mirrorTitle,\n            message: mirrorMessage,\n            imageUrl: mirrorImageUrl\n          };\n          debugLogger.notifications('INFO', 'Showing image notification for trusted mirrored push', { pushType: push.type });\n        } else {\n          // Fallback to basic notification for security\n          notificationOptions = {\n            ...baseOptions,\n            type: 'basic',\n            title: mirrorTitle,\n            message: mirrorMessage\n          };\n          if (mirrorImageUrl) {\n            debugLogger.notifications('WARN', 'Ignored image from untrusted domain for mirror push', { imageUrl: mirrorImageUrl });\n          }\n        }\n      } else {\n        // Default handler for other types\n        const defaultTitle = 'Pushbullet';\n        const defaultMessage = `New ${push.type}`;\n        \n        notificationOptions = {\n          ...baseOptions,\n          type: 'basic',\n          title: defaultTitle,\n          message: defaultMessage\n        };\n        debugLogger.notifications('INFO', 'Showing basic notification', { pushType: push.type });\n      }\n    }\n\n    // Ensure all required properties are defined\n    const finalNotificationOptions: chrome.notifications.NotificationCreateOptions = {\n      type: notificationOptions.type || 'basic',\n      title: notificationOptions.title || 'Pushbullet',\n      message: notificationOptions.message || 'New push received',\n      iconUrl: notificationOptions.iconUrl || chrome.runtime.getURL('icons/icon128.png')\n    };\n    \n    // Add optional properties if they exist\n    if (notificationOptions.imageUrl) {\n      finalNotificationOptions.imageUrl = notificationOptions.imageUrl;\n    }\n    \n    await chrome.notifications.create(notificationId, finalNotificationOptions);\n\n    if (notificationDataStore) {\n      notificationDataStore.set(notificationId, push);\n    }\n\n    performanceMonitor.recordNotificationCreated();\n    debugLogger.notifications('INFO', 'Push notification created', { notificationId, pushType: push.type });\n\n  } catch (error) {\n    performanceMonitor.recordNotificationFailed();\n    debugLogger.notifications('ERROR', 'Failed to show push notification', { pushIden: push.iden }, error as Error);\n  }\n}\n\n/**\n * Check if we should enter polling mode\n */\nexport function checkPollingMode(): void {\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n  \n  if (qualityMetrics.consecutiveFailures >= 3 && !isPollingMode()) {\n    debugLogger.general('WARN', 'Entering polling mode due to consecutive failures', {\n      consecutiveFailures: qualityMetrics.consecutiveFailures\n    });\n    \n    setPollingMode(true);\n    \n    // Start polling alarm\n    chrome.alarms.create('pollingFallback', { periodInMinutes: 1 });\n    \n    debugLogger.general('INFO', 'Polling mode activated', { interval: '1 minute' });\n  }\n}\n\n/**\n * Stop polling mode\n */\nexport function stopPollingMode(): void {\n  if (isPollingMode()) {\n    debugLogger.general('INFO', 'Stopping polling mode - WebSocket reconnected');\n    setPollingMode(false);\n    chrome.alarms.clear('pollingFallback');\n  }\n}\n\n/**\n * Perform polling fetch\n */\nexport async function performPollingFetch(): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot perform polling fetch - no API key');\n    return;\n  }\n\n  debugLogger.general('DEBUG', 'Performing polling fetch', { \n    timestamp: new Date().toISOString() \n  });\n\n  try {\n    // Fetch recent pushes\n    const pushes = await fetchRecentPushes(apiKey);\n\n    // Check for new pushes\n    const latestPush = pushes[0];\n    if (latestPush && sessionCache.recentPushes[0]?.iden !== latestPush.iden) {\n      debugLogger.general('INFO', 'New push detected via polling', {\n        pushId: latestPush.iden,\n        pushType: latestPush.type\n      });\n\n      // Update session cache\n      sessionCache.recentPushes = pushes;\n\n      // Notify popup\n      chrome.runtime.sendMessage({\n        action: 'pushesUpdated',\n        pushes: pushes\n      }).catch(() => {});\n    }\n  } catch (error) {\n    debugLogger.general('ERROR', 'Polling fetch failed', null, error as Error);\n  }\n}\n\n/**\n * Perform WebSocket health check\n */\nexport function performWebSocketHealthCheck(wsClient: any, connectFn: () => void): void {\n  const apiKey = getApiKey();\n  \n  // If we have an API key but WebSocket is not connected, reconnect\n  if (apiKey && (!wsClient || !wsClient.isConnected())) {\n    debugLogger.websocket('WARN', 'Health check failed - WebSocket not connected', {\n      hasWebSocket: !!wsClient,\n      isConnected: wsClient ? wsClient.isConnected() : false\n    });\n\n    performanceMonitor.recordHealthCheckFailure();\n    connectFn();\n  } else if (wsClient && wsClient.isConnected()) {\n    debugLogger.websocket('DEBUG', 'Health check passed - WebSocket connected');\n    performanceMonitor.recordHealthCheckSuccess();\n  } else {\n    debugLogger.websocket('DEBUG', 'Health check skipped - no API key');\n  }\n}\n\n/**\n * Update popup connection state\n */\nexport function updatePopupConnectionState(state: string): void {\n  chrome.runtime.sendMessage({\n    action: 'connectionStateChanged',\n    state: state\n  }).catch(() => {\n    // Popup may not be open\n  });\n}\n\n/**\n * Setup context menu\n * Idempotent - safe to call from multiple event listeners\n */\nexport function setupContextMenu(): void {\n  // Guard against concurrent setup attempts\n  if (isSettingUpContextMenu) {\n    debugLogger.general('INFO', 'Context menu setup already in progress, skipping');\n    return;\n  }\n\n  isSettingUpContextMenu = true;\n\n  try {\n    chrome.contextMenus.removeAll(() => {\n      // Check for errors from removeAll\n      if (chrome.runtime.lastError) {\n        debugLogger.general('ERROR', 'Failed to remove existing context menus', {\n          error: chrome.runtime.lastError.message\n        });\n        isSettingUpContextMenu = false;\n        return;\n      }\n\n      // Now that menus are removed, create new ones\n      try {\n        chrome.contextMenus.create({\n          id: 'push-link',\n          title: 'Push this link',\n          contexts: ['link']\n        });\n        if (chrome.runtime.lastError) {\n          debugLogger.general('ERROR', 'Failed to create push-link menu', {\n            error: chrome.runtime.lastError.message\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: 'push-page',\n          title: 'Push this page',\n          contexts: ['page']\n        });\n        if (chrome.runtime.lastError) {\n          debugLogger.general('ERROR', 'Failed to create push-page menu', {\n            error: chrome.runtime.lastError.message\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: 'push-selection',\n          title: 'Push selected text',\n          contexts: ['selection']\n        });\n        if (chrome.runtime.lastError) {\n          debugLogger.general('ERROR', 'Failed to create push-selection menu', {\n            error: chrome.runtime.lastError.message\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: 'push-image',\n          title: 'Push this image',\n          contexts: ['image']\n        });\n        if (chrome.runtime.lastError) {\n          debugLogger.general('ERROR', 'Failed to create push-image menu', {\n            error: chrome.runtime.lastError.message\n          });\n        }\n\n        debugLogger.general('INFO', 'Context menu created successfully');\n      } finally {\n        // Always clear the guard flag when done\n        isSettingUpContextMenu = false;\n      }\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to create context menu', null, error as Error);\n    isSettingUpContextMenu = false;\n  }\n}\n\n/**\n * Push a link\n */\nexport async function pushLink(url: string, title?: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot push link - no API key');\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedUrl = sanitizeUrl(url);\n  const sanitizedTitle = sanitizeText(title || 'Link');\n\n  if (!sanitizedUrl) {\n    debugLogger.general('ERROR', 'Invalid URL provided', { url });\n    return;\n  }\n\n  try {\n    const response = await fetch('https://api.pushbullet.com/v2/pushes', {\n      method: 'POST',\n      headers: {\n        'Access-Token': apiKey,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        type: 'link',\n        title: sanitizedTitle,\n        url: sanitizedUrl\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push link: ${response.status}`);\n    }\n\n    debugLogger.general('INFO', 'Link pushed successfully', { url, title });\n    \n    createNotificationWithTimeout(\n      'pushbullet-link-sent',\n      {\n        type: 'basic',\n        iconUrl: 'icons/icon128.png',\n        title: 'Link Sent',\n        message: title || url\n      }\n    );\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to push link', { url, title }, error as Error);\n  }\n}\n\n/**\n * Push a note\n */\nexport async function pushNote(title: string, body: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot push note - no API key');\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedTitle = sanitizeText(title);\n  const sanitizedBody = sanitizeText(body);\n\n  try {\n    const response = await fetch('https://api.pushbullet.com/v2/pushes', {\n      method: 'POST',\n      headers: {\n        'Access-Token': apiKey,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        type: 'note',\n        title: sanitizedTitle,\n        body: sanitizedBody\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push note: ${response.status}`);\n    }\n\n    debugLogger.general('INFO', 'Note pushed successfully', { title });\n    \n    createNotificationWithTimeout(\n      'pushbullet-note-sent',\n      {\n        type: 'basic',\n        iconUrl: 'icons/icon128.png',\n        title: 'Note Sent',\n        message: title\n      }\n    );\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to push note', { title }, error as Error);\n  }\n}\n\n", "/**\n * Service Worker State Machine\n * \n * This module implements a State Machine Pattern to centralize all service worker\n * lifecycle logic. Instead of scattered state flags (initializationState.inProgress,\n * isPollingMode, etc.), we have a single, explicit state machine.\n * \n * Benefits:\n * - Predictable behavior (single currentState variable)\n * - Explicit transitions (transition('WS_CONNECTED'))\n * - No invalid states (state machine ensures only valid transitions)\n * - Easy to debug (state transitions are logged)\n * - Easy to test (can test each state and transition independently)\n * \n * See ADR 0005 for full design documentation.\n */\n\nimport { debugLogger } from '../lib/logging';\nimport { updateExtensionTooltip } from './utils';\n\n/**\n * Service Worker States\n * \n * These represent all possible states the service worker can be in.\n */\nexport enum ServiceWorkerState {\n  IDLE = 'idle',                 // Fresh start, no API key\n  INITIALIZING = 'initializing', // API key present, fetching session data\n  READY = 'ready',               // Authenticated, WebSocket connected\n  DEGRADED = 'degraded',         // Authenticated, using polling fallback\n  ERROR = 'error',               // Permanent, unrecoverable error\n}\n\n/**\n * Service Worker Events\n * \n * These are the events that can trigger state transitions.\n */\nexport type ServiceWorkerEvent =\n  | 'STARTUP'            // onInstalled or onStartup\n  | 'API_KEY_SET'        // User saves a new API key\n  | 'INIT_SUCCESS'       // Session data successfully fetched\n  | 'INIT_FAILURE'       // Session data fetching failed\n  | 'WS_CONNECTED'       // WebSocket connected successfully\n  | 'WS_DISCONNECTED'    // WebSocket disconnected (transient error)\n  | 'WS_PERMANENT_ERROR' // WebSocket disconnected (permanent error)\n  | 'LOGOUT';            // User logged out\n\n/**\n * State Machine Callbacks\n * \n * These callbacks are called when entering/exiting states.\n * They allow the state machine to trigger side effects without\n * being tightly coupled to the background script.\n */\nexport interface StateMachineCallbacks {\n  onInitialize?: (data?: any) => Promise<void>;\n  onConnectWebSocket?: () => void;\n  onStartPolling?: () => void;\n  onStopPolling?: () => void;\n  onShowError?: (error: string) => void;\n  onClearData?: () => Promise<void>;\n  onDisconnectWebSocket?: () => void;\n}\n\n/**\n * Service Worker State Machine\n * \n * Manages the lifecycle of the service worker through explicit states and transitions.\n */\nexport class ServiceWorkerStateMachine {\n  private currentState: ServiceWorkerState = ServiceWorkerState.IDLE;\n  private callbacks: StateMachineCallbacks;\n\n  private constructor(callbacks: StateMachineCallbacks) {\n    this.callbacks = callbacks;\n    debugLogger.general('INFO', '[StateMachine] Initialized', { initialState: this.currentState });\n  }\n\n  /**\n   * Create a new state machine instance with hydrated state from storage\n   *\n   * This static factory method is the only way to create a ServiceWorkerStateMachine.\n   * It reads the last known state from chrome.storage.local and initializes the\n   * state machine with that state, ensuring continuity across service worker restarts.\n   *\n   * @param callbacks - The callbacks to use for state transitions\n   * @returns A promise that resolves to a fully initialized state machine\n   */\n  public static async create(callbacks: StateMachineCallbacks): Promise<ServiceWorkerStateMachine> {\n    const instance = new ServiceWorkerStateMachine(callbacks);\n\n    try {\n      const { lastKnownState } = await chrome.storage.local.get('lastKnownState');\n\n      if (lastKnownState && Object.values(ServiceWorkerState).includes(lastKnownState)) {\n        instance.currentState = lastKnownState as ServiceWorkerState;\n        debugLogger.general('INFO', '[StateMachine] Hydrated state from storage', {\n          restoredState: instance.currentState\n        });\n      } else {\n        debugLogger.general('INFO', '[StateMachine] No valid state in storage, using default', {\n          initialState: instance.currentState\n        });\n      }\n    } catch (error) {\n      debugLogger.storage('ERROR', '[StateMachine] Failed to hydrate state, defaulting to IDLE', null, error as Error);\n      instance.currentState = ServiceWorkerState.IDLE;\n    }\n\n    return instance;\n  }\n\n  /**\n   * Get the current state\n   */\n  public getCurrentState(): ServiceWorkerState {\n    return this.currentState;\n  }\n\n  /**\n   * Check if in a specific state\n   */\n  public isInState(state: ServiceWorkerState): boolean {\n    return this.currentState === state;\n  }\n\n  /**\n   * Transition to a new state based on an event\n   * \n   * @param event - The event that triggers the transition\n   * @param data - Optional data to pass to the state entry handler\n   */\n  public async transition(event: ServiceWorkerEvent, data?: any): Promise<void> {\n    const nextState = this.getNextState(event, data);\n\n    if (nextState !== this.currentState) {\n      debugLogger.general('INFO', `[StateMachine] Transition`, {\n        from: this.currentState,\n        event,\n        to: nextState\n      });\n\n      // Run exit actions for the old state\n      await this.onStateExit(this.currentState, nextState);\n\n      // Change state\n      const previousState = this.currentState;\n      this.currentState = nextState;\n\n      // Run entry actions for the new state\n      await this.onStateEnter(this.currentState, previousState, data);\n\n      // ICON PERSISTENCE FIX: Persist state to storage so icon badge survives service worker restarts\n      // This ensures users always see the correct extension state (error, connected, etc.)\n      // even after Chrome shuts down the service worker or the browser is restarted\n      try {\n        await chrome.storage.local.set({\n          lastKnownState: this.currentState,\n          lastKnownStateDescription: this.getStateDescription()\n        });\n        debugLogger.storage('DEBUG', '[StateMachine] Persisted new state to storage', { state: this.currentState });\n      } catch (error) {\n        debugLogger.storage('ERROR', '[StateMachine] Failed to persist state', null, error as Error);\n      }\n    } else {\n      debugLogger.general('DEBUG', `[StateMachine] No transition`, {\n        state: this.currentState,\n        event\n      });\n    }\n  }\n\n  /**\n   * Determine the next state based on current state and event\n   *\n   * This implements the state transition table from ADR 0005.\n   */\n  private getNextState(event: ServiceWorkerEvent, data?: any): ServiceWorkerState {\n    // LOGOUT can happen from any state\n    if (event === 'LOGOUT') {\n      return ServiceWorkerState.IDLE;\n    }\n\n    // STARTUP event handling: When service worker restarts, we need to re-initialize\n    // if we have an API key, regardless of the current state. This handles the case\n    // where the state machine was hydrated to READY/DEGRADED but the service worker\n    // has restarted and needs to restore the session.\n    if (event === 'STARTUP') {\n      if (data?.hasApiKey) {\n        // If we're already in INITIALIZING, stay there to avoid duplicate initialization\n        if (this.currentState === ServiceWorkerState.INITIALIZING) {\n          return ServiceWorkerState.INITIALIZING;\n        }\n        // From any other state, transition to INITIALIZING to restore session\n        return ServiceWorkerState.INITIALIZING;\n      } else {\n        // No API key, go to IDLE\n        return ServiceWorkerState.IDLE;\n      }\n    }\n\n    switch (this.currentState) {\n    case ServiceWorkerState.IDLE:\n      if (event === 'API_KEY_SET') {\n        return ServiceWorkerState.INITIALIZING;\n      }\n      break;\n\n    case ServiceWorkerState.INITIALIZING:\n      if (event === 'INIT_SUCCESS') {\n        return ServiceWorkerState.READY;\n      }\n      if (event === 'INIT_FAILURE') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.READY:\n      if (event === 'WS_DISCONNECTED') {\n        return ServiceWorkerState.DEGRADED;\n      }\n      if (event === 'WS_PERMANENT_ERROR') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.DEGRADED:\n      if (event === 'WS_CONNECTED') {\n        return ServiceWorkerState.READY;\n      }\n      if (event === 'WS_PERMANENT_ERROR') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.ERROR:\n      if (event === 'API_KEY_SET') {\n        return ServiceWorkerState.INITIALIZING;\n      }\n      break;\n    }\n\n    // No valid transition found, stay in current state\n    return this.currentState;\n  }\n\n  /**\n   * Handle entering a new state\n   * \n   * This is where side effects happen (calling callbacks).\n   */\n  private async onStateEnter(\n    state: ServiceWorkerState,\n    previousState: ServiceWorkerState,\n    data?: any\n  ): Promise<void> {\n    debugLogger.general('DEBUG', `[StateMachine] Entering state`, { state, previousState });\n\n    // Update extension tooltip to show current state\n    updateExtensionTooltip(this.getStateDescription());\n\n    switch (state) {\n    case ServiceWorkerState.IDLE:\n      // Clean slate - clear all data\n      if (this.callbacks.onClearData) {\n        await this.callbacks.onClearData();\n      }\n      if (this.callbacks.onDisconnectWebSocket) {\n        this.callbacks.onDisconnectWebSocket();\n      }\n      break;\n\n    case ServiceWorkerState.INITIALIZING:\n      // Start initialization process\n      if (this.callbacks.onInitialize) {\n        try {\n          await this.callbacks.onInitialize(data);\n          // Initialization succeeded - transition to READY\n          await this.transition('INIT_SUCCESS');\n        } catch (error) {\n          // Initialization failed - transition to ERROR\n          debugLogger.general('ERROR', '[StateMachine] Initialization failed', null, error as Error);\n          await this.transition('INIT_FAILURE');\n        }\n      }\n      break;\n\n    case ServiceWorkerState.READY:\n      // Stop polling if we were in DEGRADED mode\n      if (previousState === ServiceWorkerState.DEGRADED && this.callbacks.onStopPolling) {\n        this.callbacks.onStopPolling();\n      }\n      // Connect WebSocket if coming from INITIALIZING\n      if (previousState === ServiceWorkerState.INITIALIZING && this.callbacks.onConnectWebSocket) {\n        this.callbacks.onConnectWebSocket();\n      }\n      break;\n\n    case ServiceWorkerState.DEGRADED:\n      // When we ENTER the DEGRADED state, we start polling\n      debugLogger.general('WARN', 'Entering DEGRADED state. Starting polling fallback.');\n      chrome.alarms.create('pollingFallback', { periodInMinutes: 1 });\n      // Call the callback for consistency\n      if (this.callbacks.onStartPolling) {\n        this.callbacks.onStartPolling();\n      }\n      break;\n\n    case ServiceWorkerState.ERROR:\n      // Show error notification\n      if (this.callbacks.onShowError) {\n        this.callbacks.onShowError('Service worker encountered an error');\n      }\n      break;\n    }\n  }\n\n  /**\n   * Handle exiting a state\n   * \n   * Optional cleanup logic when leaving a state.\n   */\n  private async onStateExit(\n    state: ServiceWorkerState,\n    nextState: ServiceWorkerState\n  ): Promise<void> {\n    debugLogger.general('DEBUG', `[StateMachine] Exiting state`, { state, nextState });\n\n    // When we EXIT the DEGRADED state, we must stop polling\n    if (state === ServiceWorkerState.DEGRADED) {\n      debugLogger.general('INFO', 'Exiting DEGRADED state. Stopping polling fallback.');\n      chrome.alarms.clear('pollingFallback');\n      if (this.callbacks.onStopPolling) {\n        this.callbacks.onStopPolling();\n      }\n    }\n  }\n\n  /**\n   * Get a human-readable description of the current state\n   */\n  public getStateDescription(): string {\n    switch (this.currentState) {\n    case ServiceWorkerState.IDLE:\n      return 'Idle - No API key configured';\n    case ServiceWorkerState.INITIALIZING:\n      return 'Initializing - Fetching session data';\n    case ServiceWorkerState.READY:\n      return 'Ready - Connected via WebSocket';\n    case ServiceWorkerState.DEGRADED:\n      return 'Degraded - Using polling fallback';\n    case ServiceWorkerState.ERROR:\n      return 'Error - Unrecoverable error occurred';\n    default:\n      return 'Unknown state';\n    }\n  }\n}\n\n", "/**\n * Message sender validation for security\n * Prevents external extensions/pages from sending privileged messages\n */\n\nimport { debugLogger } from '../logging';\n\n/**\n * Validate that message sender is from this extension\n */\nexport function isValidSender(sender: chrome.runtime.MessageSender): boolean {\n  // Must have a valid sender object\n  if (!sender) {\n    debugLogger.general('WARN', 'Message received with no sender');\n    return false;\n  }\n\n  // Must be from this extension\n  if (sender.id !== chrome.runtime.id) {\n    debugLogger.general('WARN', 'Message received from external extension', {\n      senderId: sender.id,\n      expectedId: chrome.runtime.id\n    });\n    return false;\n  }\n\n  // Must be from an extension page (not a content script)\n  if (sender.url) {\n    const extensionUrl = chrome.runtime.getURL('');\n    if (!sender.url.startsWith(extensionUrl)) {\n      debugLogger.general('WARN', 'Message received from non-extension URL', {\n        senderUrl: sender.url,\n        expectedPrefix: extensionUrl\n      });\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * List of privileged actions that require sender validation\n */\nconst PRIVILEGED_ACTIONS = new Set([\n  'apiKeyChanged',\n  'logout',\n  'settingsChanged',\n  'deviceNicknameChanged',\n  'autoOpenLinksChanged',\n  'encryptionPasswordChanged',\n  'debugModeChanged',\n  'pushNote',\n  'pushLink',\n  'pushFile'\n]);\n\n/**\n * Check if an action requires privileged access\n */\nexport function isPrivilegedAction(action: string): boolean {\n  return PRIVILEGED_ACTIONS.has(action);\n}\n\n/**\n * Validate sender for privileged actions\n * Returns true if valid, false if should be rejected\n */\nexport function validatePrivilegedMessage(\n  action: string,\n  sender: chrome.runtime.MessageSender\n): boolean {\n  if (!isPrivilegedAction(action)) {\n    // Non-privileged actions don't need validation\n    return true;\n  }\n\n  if (!isValidSender(sender)) {\n    debugLogger.general('ERROR', 'Rejected privileged action from invalid sender', {\n      action,\n      senderId: sender?.id,\n      senderUrl: sender?.url\n    });\n    return false;\n  }\n\n  return true;\n}\n\n", "/**\n * Background Service Worker - Main Entry Point\n * Pushbullet Chrome Extension (Manifest V3)\n */\n\nimport { debugLogger, debugConfigManager, globalErrorTracker } from '../lib/logging';\nimport { performanceMonitor } from '../lib/perf';\nimport { initTracker, wsStateMonitor } from '../lib/monitoring';\nimport { WebSocketClient } from '../app/ws/client';\nimport { sessionCache, initializeSessionCache, refreshSessionCache, initializationState } from '../app/session';\nimport { fetchDevices, updateDeviceNickname } from '../app/api/client';\nimport { ensureConfigLoaded } from '../app/reconnect';\nimport { PushbulletCrypto } from '../lib/crypto';\nimport { storageRepository } from '../infrastructure/storage/storage.repository';\nimport { globalEventBus } from '../lib/events/event-bus';\nimport { ServiceWorkerStateMachine, ServiceWorkerState } from './state-machine';\nimport {\n  getApiKey,\n  setApiKey,\n  getDeviceIden,\n  setDeviceIden,\n  getDeviceNickname,\n  setDeviceNickname,\n  getAutoOpenLinks,\n  setAutoOpenLinks,\n  setNotificationTimeout,\n  setWebSocketClient,\n  WEBSOCKET_URL\n} from './state';\nimport {\n  refreshPushes,\n  showPushNotification,\n  checkPollingMode,\n  stopPollingMode,\n  performPollingFetch,\n  performWebSocketHealthCheck,\n  updatePopupConnectionState,\n  setupContextMenu,\n  pushLink,\n  pushNote,\n  updateConnectionIcon,\n  updateExtensionTooltip\n} from './utils';\nimport { validatePrivilegedMessage } from '../lib/security/message-validation';\nimport type { Push } from '../types/domain';\nimport { isLinkPush } from '../types/domain';\n\n// Load debug configuration\ndebugConfigManager.loadConfig();\n\n// Store notification data for detail view\n// SECURITY FIX (M-06): Limit store size to prevent memory leak\nconst notificationDataStore = new Map<string, Push>();\nconst MAX_NOTIFICATION_STORE_SIZE = 100;\n\n/**\n * Add notification to store with size limit\n */\nexport function addToNotificationStore(id: string, push: Push): void {\n  // Remove oldest entries if at capacity\n  if (notificationDataStore.size >= MAX_NOTIFICATION_STORE_SIZE) {\n    const firstKey = notificationDataStore.keys().next().value;\n    if (firstKey) {\n      notificationDataStore.delete(firstKey);\n    }\n  }\n  notificationDataStore.set(id, push);\n}\n\n/**\n * Get notification store (for passing to utils)\n */\nexport function getNotificationStore(): Map<string, Push> {\n  return notificationDataStore;\n}\n\n/**\n * Attempts to get the API key from storage with retries.\n *\n * RACE CONDITION FIX: The chrome.storage API can be transiently unavailable\n * immediately after a service worker restart, returning empty results even when\n * data exists. This function implements a retry mechanism to handle this MV3\n * lifecycle issue.\n *\n * @param attempts - Number of retry attempts (default: 3)\n * @param delay - Delay in milliseconds between attempts (default: 100)\n * @returns The API key string, or null if not found after all retries\n */\nasync function getApiKeyWithRetries(attempts = 3, delay = 100): Promise<string | null> {\n  for (let i = 0; i < attempts; i++) {\n    try {\n      const apiKey = await storageRepository.getApiKey();\n      if (apiKey) {\n        debugLogger.storage('INFO', `API key found on attempt ${i + 1}/${attempts}`);\n        return apiKey;\n      }\n      // API key is null - could be genuinely missing or storage not ready yet\n      debugLogger.storage('DEBUG', `API key not found on attempt ${i + 1}/${attempts}, will retry`);\n    } catch (error) {\n      debugLogger.storage('WARN', `Error getting API key on attempt ${i + 1}/${attempts}`, null, error as Error);\n    }\n\n    // Wait before the next attempt (but not after the last attempt)\n    if (i < attempts - 1) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  debugLogger.storage('WARN', `API key not found after ${attempts} retry attempts - assuming no key configured`);\n  return null;\n}\n\n// Initialize WebSocket client\nlet websocketClient: WebSocketClient | null = null;\n\n// MV3 LIFECYCLE TRACKING: Recovery timer for measuring WebSocket reconnection time\nlet recoveryTimerStart: number = 0;\n\n// Initialize State Machine\n// ARCHITECTURAL CHANGE: Centralized lifecycle management\n// All service worker state is now managed by the state machine\n// STATE MACHINE HYDRATION: The state machine is created asynchronously to allow\n// it to hydrate its state from storage, ensuring continuity across service worker restarts\nlet stateMachine: ServiceWorkerStateMachine;\n\n// Define the callbacks once for reuse\nconst stateMachineCallbacks = {\n  onInitialize: async (data: any) => {\n    // Initialize session cache\n    const apiKey = data?.apiKey || getApiKey();\n    if (apiKey) {\n      // Pass connectWebSocket so it can be called upon successful initialization\n      await initializeSessionCache('state-machine', connectWebSocket, {\n        setApiKey,\n        setDeviceIden,\n        setAutoOpenLinks,\n        setNotificationTimeout,\n        setDeviceNickname\n      });\n    }\n  },\n\n  onStartPolling: () => {\n    checkPollingMode();\n  },\n  onStopPolling: () => {\n    stopPollingMode();\n  },\n  onShowError: (error: string) => {\n    debugLogger.general('ERROR', '[StateMachine] Error state', { error });\n    updateConnectionIcon('disconnected');\n  },\n  onClearData: async () => {\n    // Clear session cache\n    sessionCache.userInfo = null;\n    sessionCache.devices = [];\n    sessionCache.recentPushes = [];\n    sessionCache.lastUpdated = null;\n  },\n  onDisconnectWebSocket: () => {\n    disconnectWebSocket();\n  }\n};\n\n// Create a promise that resolves when the state machine is ready\n// This ensures startup listeners wait for hydration to complete before attempting transitions\nconst stateMachineReady = ServiceWorkerStateMachine.create(stateMachineCallbacks).then(sm => {\n  stateMachine = sm;\n  debugLogger.general('INFO', '[Background] State machine initialized and ready', {\n    currentState: stateMachine.getCurrentState()\n  });\n});\n\n/**\n * ICON PERSISTENCE FIX: Restore visual state from storage\n *\n * Reads the last known state from storage and updates the icon badge\n * and tooltip to match. This ensures UI state persists across restarts.\n *\n * This function should be called at the very beginning of onInstalled\n * and onStartup listeners to restore the visual state before any other\n * initialization occurs.\n */\nasync function restoreVisualState(): Promise<void> {\n  try {\n    const { lastKnownState, lastKnownStateDescription } = await chrome.storage.local.get([\n      'lastKnownState',\n      'lastKnownStateDescription'\n    ]);\n\n    if (lastKnownState) {\n      debugLogger.general('INFO', 'Restoring visual state from storage', { state: lastKnownState });\n\n      // Restore tooltip\n      if (lastKnownStateDescription) {\n        updateExtensionTooltip(lastKnownStateDescription);\n      }\n\n      // Restore icon badge color based on state\n      switch (lastKnownState as ServiceWorkerState) {\n      case ServiceWorkerState.READY:\n        updateConnectionIcon('connected');\n        break;\n      case ServiceWorkerState.INITIALIZING:\n        updateConnectionIcon('connecting');\n        break;\n      case ServiceWorkerState.ERROR:\n      case ServiceWorkerState.DEGRADED:\n      case ServiceWorkerState.IDLE:\n        updateConnectionIcon('disconnected'); // This will set the badge to red\n        break;\n      default:\n        updateConnectionIcon('disconnected');\n      }\n    }\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to restore visual state', null, error as Error);\n  }\n}\n\n/**\n * Connect to WebSocket\n */\nfunction connectWebSocket(): void {\n  // MV3 LIFECYCLE TRACKING: Start recovery timer\n  recoveryTimerStart = Date.now();\n\n  // Set connecting status\n  updateConnectionIcon('connecting');\n\n  // SECURITY FIX (H-02): Dispose existing socket before creating new one\n  if (websocketClient) {\n    debugLogger.websocket('INFO', 'Disposing existing WebSocket before reconnecting');\n    websocketClient.disconnect();\n    websocketClient = null;\n  }\n\n  // RACE CONDITION FIX: Remove all previous event listeners to prevent listener leaks\n  // When connectWebSocket is called multiple times (during reconnection attempts),\n  // old listeners accumulate, causing duplicate event handling and multiple notifications\n  // for the same push. This cleanup ensures only one set of listeners is active.\n  debugLogger.websocket('DEBUG', 'Cleaning up old event listeners before reconnecting');\n  globalEventBus.removeAllListeners('websocket:tickle:push');\n  globalEventBus.removeAllListeners('websocket:tickle:device');\n  globalEventBus.removeAllListeners('websocket:push');\n  globalEventBus.removeAllListeners('websocket:connected');\n  globalEventBus.removeAllListeners('websocket:disconnected');\n  globalEventBus.removeAllListeners('websocket:polling:check');\n  globalEventBus.removeAllListeners('websocket:polling:stop');\n  globalEventBus.removeAllListeners('websocket:state');\n\n  websocketClient = new WebSocketClient(WEBSOCKET_URL, getApiKey);\n  setWebSocketClient(websocketClient);\n\n  // Set up event listeners using event bus\n  // ARCHITECTURAL CHANGE: Using event-driven architecture instead of direct handler calls\n  // This decouples the WebSocketClient from the background script\n\n  globalEventBus.on('websocket:tickle:push', async () => {\n    await refreshPushes(notificationDataStore);\n  });\n\n  globalEventBus.on('websocket:tickle:device', async () => {\n    const apiKey = getApiKey();\n    if (apiKey) {\n      const devices = await fetchDevices(apiKey);\n      sessionCache.devices = devices;\n      sessionCache.lastUpdated = Date.now();\n\n      chrome.runtime.sendMessage({\n        action: 'sessionDataUpdated',\n        devices: devices,\n        userInfo: sessionCache.userInfo,\n        recentPushes: sessionCache.recentPushes,\n        autoOpenLinks: sessionCache.autoOpenLinks,\n        deviceNickname: sessionCache.deviceNickname\n      }).catch(() => {});\n    }\n  });\n\n  globalEventBus.on('websocket:push', async (push: Push) => {\n    // RACE CONDITION FIX: Ensure configuration is loaded before processing push\n    await ensureConfigLoaded();\n\n    // Track push received\n    performanceMonitor.recordPushReceived();\n\n    let decryptedPush = push;\n\n    // Check if push is encrypted\n    if ('encrypted' in push && push.encrypted && 'ciphertext' in push) {\n      try {\n        // Get encryption password from storage repository\n        const password = await storageRepository.getEncryptionPassword();\n\n        if (password && sessionCache.userInfo) {\n          debugLogger.general('INFO', 'Decrypting encrypted push', {\n            pushIden: push.iden\n          });\n\n          const decrypted = await PushbulletCrypto.decryptPush(\n                push as any,\n                password,\n                sessionCache.userInfo.iden\n          );\n\n          decryptedPush = decrypted as Push;\n          debugLogger.general('INFO', 'Push decrypted successfully', {\n            pushType: decryptedPush.type\n          });\n        } else {\n          debugLogger.general('WARN', 'Cannot decrypt push - no encryption password set');\n        }\n      } catch (error) {\n        debugLogger.general('ERROR', 'Failed to decrypt push', {\n          error: (error as Error).message\n        }, error as Error);\n      }\n    }\n\n    // --- FILTERING LOGIC: Only process displayable push types ---\n    const displayableTypes = ['mirror', 'note', 'link'];\n    \n    if (!displayableTypes.includes(decryptedPush.type)) {\n      // Log for debugging purposes and ignore the push\n      debugLogger.general('INFO', 'Ignoring non-displayable push of type', {\n        pushType: decryptedPush.type,\n        pushIden: decryptedPush.iden\n      });\n      return;\n    }\n\n    // Log that we're processing a displayable push\n    debugLogger.general('INFO', 'Processing displayable push of type', {\n      pushType: decryptedPush.type,\n      pushIden: decryptedPush.iden\n    });\n\n    // Update cache (prepend)\n    if (sessionCache.recentPushes) {\n      sessionCache.recentPushes.unshift(decryptedPush);\n      sessionCache.lastUpdated = Date.now();\n\n      chrome.runtime.sendMessage({\n        action: 'pushesUpdated',\n        pushes: sessionCache.recentPushes\n      }).catch(() => {});\n    }\n\n    // FIX: Don't await - let notifications show immediately without blocking\n    // This allows multiple notifications to appear concurrently\n    showPushNotification(decryptedPush, notificationDataStore).catch((error) => {\n      debugLogger.general('ERROR', 'Failed to show notification', null, error);\n      performanceMonitor.recordNotificationFailed();\n    });\n\n    // Auto-open links if setting is enabled\n    const autoOpenLinks = getAutoOpenLinks();\n    if (autoOpenLinks && isLinkPush(decryptedPush)) {\n      debugLogger.general('INFO', 'Auto-opening link push', {\n        pushIden: decryptedPush.iden,\n        url: decryptedPush.url\n      });\n\n      chrome.tabs.create({\n        url: decryptedPush.url,\n        active: false // Open in background to avoid disrupting user\n      }).catch((error) => {\n        debugLogger.general('ERROR', 'Failed to auto-open link', {\n          url: decryptedPush.url\n        }, error);\n      });\n    }\n  });\n\n  globalEventBus.on('websocket:connected', async () => {\n    // MV3 LIFECYCLE TRACKING: Calculate and store recovery time\n    const recoveryTime = Date.now() - recoveryTimerStart;\n    debugLogger.performance('INFO', 'WebSocket recovery time', { duration: recoveryTime });\n    const { recoveryTimings = [] } = await chrome.storage.local.get('recoveryTimings');\n    recoveryTimings.push(recoveryTime);\n    // Keep only the last 20 timings for averaging\n    await chrome.storage.local.set({ recoveryTimings: recoveryTimings.slice(-20) });\n\n    // Trigger state machine transition\n    stateMachine.transition('WS_CONNECTED');\n    updateConnectionIcon('connected');\n  });\n\n  globalEventBus.on('websocket:disconnected', () => {\n    // Trigger state machine transition\n    stateMachine.transition('WS_DISCONNECTED');\n    updateConnectionIcon('disconnected');\n  });\n\n  globalEventBus.on('websocket:polling:check', () => {\n    checkPollingMode();\n  });\n\n  globalEventBus.on('websocket:polling:stop', () => {\n    stopPollingMode();\n  });\n\n  globalEventBus.on('websocket:state', (state: string) => {\n    updatePopupConnectionState(state);\n  });\n\n  websocketClient.connect();\n}\n\n/**\n * Disconnect WebSocket\n */\nfunction disconnectWebSocket(): void {\n  if (websocketClient) {\n    websocketClient.disconnect();\n  }\n}\n\n// ============================================================================\n// Chrome Event Listeners\n// ============================================================================\n\n/**\n * Extension installed/updated\n */\nchrome.runtime.onInstalled.addListener(async () => {\n  // MV3 LIFECYCLE TRACKING: Increment restart counter\n  const { restarts = 0 } = await chrome.storage.local.get('restarts');\n  await chrome.storage.local.set({ restarts: restarts + 1 });\n\n  // ICON PERSISTENCE FIX: Restore visual state FIRST before any other initialization\n  await restoreVisualState();\n\n  debugLogger.general('INFO', 'Pushbullet extension installed/updated', {\n    reason: 'onInstalled',\n    timestamp: new Date().toISOString()\n  });\n\n  // Set initial icon to disconnected (with small delay to ensure Chrome is ready)\n  setTimeout(() => updateConnectionIcon('disconnected'), 100);\n\n  initTracker.recordInitialization('onInstalled');\n  setupContextMenu();\n\n  // Create periodic log flush alarm\n  chrome.alarms.create('logFlush', { periodInMinutes: 1 });\n\n  // STATE MACHINE HYDRATION: Wait for state machine to be ready before attempting transitions\n  // This ensures the state machine has loaded its persisted state from storage\n  await stateMachineReady;\n\n  // STARTUP AMNESIA FIX + STORAGE RACE CONDITION FIX:\n  // Read API key from storage with retry logic to handle chrome.storage being unavailable\n  // immediately after service worker restart. This ensures both the state machine transition\n  // and onInitialize callback work correctly even when storage is transiently unavailable.\n  try {\n    const apiKey = await getApiKeyWithRetries();\n    if (apiKey) {\n      setApiKey(apiKey);\n    }\n    await stateMachine.transition('STARTUP', { hasApiKey: !!apiKey });\n  } catch (error) {\n    debugLogger.storage('ERROR', 'Failed to read API key on startup', null, error as Error);\n    await stateMachine.transition('STARTUP', { hasApiKey: false });\n  }\n});\n\n/**\n * Browser startup\n */\nchrome.runtime.onStartup.addListener(async () => {\n  // MV3 LIFECYCLE TRACKING: Increment restart counter\n  const { restarts = 0 } = await chrome.storage.local.get('restarts');\n  await chrome.storage.local.set({ restarts: restarts + 1 });\n\n  // ICON PERSISTENCE FIX: Restore visual state FIRST before any other initialization\n  await restoreVisualState();\n\n  debugLogger.general('INFO', 'Browser started - reinitializing Pushbullet extension', {\n    reason: 'onStartup',\n    timestamp: new Date().toISOString()\n  });\n\n  // Set initial icon to disconnected (with small delay to ensure Chrome is ready)\n  setTimeout(() => updateConnectionIcon('disconnected'), 100);\n\n  initTracker.recordInitialization('onStartup');\n  setupContextMenu();\n\n  // Create periodic log flush alarm\n  chrome.alarms.create('logFlush', { periodInMinutes: 1 });\n\n  // STATE MACHINE HYDRATION: Wait for state machine to be ready before attempting transitions\n  // This ensures the state machine has loaded its persisted state from storage\n  await stateMachineReady;\n\n  // STARTUP AMNESIA FIX + STORAGE RACE CONDITION FIX:\n  // Read API key from storage with retry logic to handle chrome.storage being unavailable\n  // immediately after service worker restart. This ensures both the state machine transition\n  // and onInitialize callback work correctly even when storage is transiently unavailable.\n  try {\n    const apiKey = await getApiKeyWithRetries();\n    if (apiKey) {\n      setApiKey(apiKey);\n    }\n    await stateMachine.transition('STARTUP', { hasApiKey: !!apiKey });\n  } catch (error) {\n    debugLogger.storage('ERROR', 'Failed to read API key on startup', null, error as Error);\n    await stateMachine.transition('STARTUP', { hasApiKey: false });\n  }\n});\n\n/**\n * Notification click listener\n */\nchrome.notifications.onClicked.addListener((notificationId) => {\n  debugLogger.notifications('INFO', 'Notification clicked', { notificationId });\n\n  // Get push data from store\n  const pushData = notificationDataStore.get(notificationId);\n\n  if (pushData) {\n    // Open notification detail page in a new window\n    chrome.windows.create({\n      url: `notification-detail.html?id=${encodeURIComponent(notificationId)}`,\n      type: 'popup',\n      width: 600,\n      height: 500,\n      focused: true\n    });\n  }\n\n  // Clear the notification\n  chrome.notifications.clear(notificationId);\n});\n\n/**\n * Alarm listener\n */\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  if (alarm.name === 'logFlush') {\n    // Flush logs to persistent storage\n    debugLogger.flush().then(() => {\n      console.log('[Logger] Log buffer flushed to persistent storage.');\n    });\n  } else if (alarm.name === 'websocketReconnect' && getApiKey()) {\n    debugLogger.websocket('INFO', 'Reconnection alarm triggered', {\n      alarmName: alarm.name,\n      hasApiKey: !!getApiKey(),\n      scheduledTime: alarm.scheduledTime ? new Date(alarm.scheduledTime).toISOString() : 'unknown'\n    });\n    connectWebSocket();\n  } else if (alarm.name === 'websocketReconnect') {\n    debugLogger.websocket('WARN', 'Reconnection alarm triggered but no API key available');\n  } else if (alarm.name === 'websocketHealthCheck') {\n    // SERVICE WORKER AMNESIA FIX: Ensure config is loaded before performing health check\n    await ensureConfigLoaded();\n    performWebSocketHealthCheck(websocketClient, connectWebSocket);\n    // MV3 LIFECYCLE TRACKING: Record last seen alive timestamp\n    chrome.storage.local.set({ lastSeenAlive: Date.now() });\n  } else if (alarm.name === 'pollingFallback') {\n    performPollingFetch();\n  }\n});\n\n/**\n * Context menu click handler\n */\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  // RACE CONDITION FIX: Ensure configuration is loaded before processing context menu action\n  await ensureConfigLoaded();\n\n  if (!getApiKey()) {\n    chrome.notifications.create('pushbullet-no-api-key', {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title: 'Pushbullet',\n      message: 'Please set your API key in the extension popup'\n    });\n    return;\n  }\n\n  switch (info.menuItemId) {\n  case 'push-link':\n    if (info.linkUrl && tab) {\n      pushLink(info.linkUrl, tab.title);\n    }\n    break;\n  case 'push-page':\n    if (tab && tab.url) {\n      pushLink(tab.url, tab.title);\n    }\n    break;\n  case 'push-selection':\n    if (info.selectionText && tab) {\n      pushNote('Selection from ' + (tab.title || 'page'), info.selectionText);\n    }\n    break;\n  case 'push-image':\n    if (info.srcUrl && tab) {\n      pushLink(info.srcUrl, 'Image from ' + (tab.title || 'page'));\n    }\n    break;\n  }\n});\n\n\n\n/**\n * Message listener for popup communication\n */\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  // SECURITY FIX (C-04): Validate sender for privileged actions\n  // Prevents external extensions/pages from sending privileged messages\n  if (!validatePrivilegedMessage(message.action, sender)) {\n    debugLogger.general('ERROR', 'Rejected privileged message from untrusted sender', {\n      action: message.action,\n      senderId: sender?.id,\n      senderUrl: sender?.url\n    });\n    sendResponse({ success: false, error: 'Unauthorized' });\n    return false;\n  } else if (message.action === 'log') {\n    // Handler for centralized logging from other scripts (e.g., popup)\n    if (message.payload) {\n      const { level, message: logMessage, data } = message.payload;\n      const prefix = '[POPUP]'; // Add a prefix to identify the source\n\n      switch (level) {\n      case 'ERROR':\n        debugLogger.general('ERROR', `${prefix} ${logMessage}`, data);\n        break;\n      case 'WARN':\n        debugLogger.general('WARN', `${prefix} ${logMessage}`, data);\n        break;\n      case 'INFO':\n      default:\n        debugLogger.general('INFO', `${prefix} ${logMessage}`, data);\n        break;\n      }\n    }\n    // Return false because we are not sending a response asynchronously.\n    return false;\n  }\n\n  if (message.action === 'getSessionData') {\n    // SERVICE WORKER AMNESIA FIX: Check storage directly, not the in-memory variable\n    // After service worker restart, in-memory variables are null, but storage persists.\n    // This ensures we detect wake-ups reliably by using storage as the source of truth.\n    (async () => {\n      try {\n        // RACE CONDITION FIX: Ensure configuration is loaded before processing\n        await ensureConfigLoaded();\n\n        // Check storage directly, not the in-memory variable\n        const storedApiKey = await storageRepository.getApiKey();\n\n        // Detect wake-up: if we have a key in storage but the session is not loaded in memory\n        if (storedApiKey && !sessionCache.isAuthenticated) {\n          debugLogger.general('WARN', 'Service worker wake-up detected - reloading session from storage.');\n\n          // Await the full initialization process\n          await initializeSessionCache('onMessageWakeup', connectWebSocket, {\n            setApiKey,\n            setDeviceIden,\n            setAutoOpenLinks,\n            setNotificationTimeout,\n            setDeviceNickname\n          });\n        }\n\n        // Now, respond with the (potentially restored) session data\n        sendResponse({\n          isAuthenticated: sessionCache.isAuthenticated,\n          userInfo: sessionCache.userInfo,\n          devices: sessionCache.devices,\n          recentPushes: sessionCache.recentPushes,\n          autoOpenLinks: getAutoOpenLinks(),\n          deviceNickname: getDeviceNickname(),\n          websocketConnected: websocketClient ? websocketClient.isConnected() : false\n        });\n      } catch (error) {\n        debugLogger.general('ERROR', 'Error handling getSessionData after wake-up', null, error as Error);\n        sendResponse({ isAuthenticated: false, error: (error as Error).message });\n      }\n    })();\n\n    return true; // Return true to indicate an asynchronous response.\n  } else if (message.action === 'apiKeyChanged') {\n    // Update API key\n    setApiKey(message.apiKey);\n\n    // Build promise chain\n    let savePromise = storageRepository.setApiKey(message.apiKey);\n\n    // Update device nickname if provided\n    if (message.deviceNickname) {\n      savePromise = savePromise.then(() => {\n        setDeviceNickname(message.deviceNickname);\n        sessionCache.deviceNickname = message.deviceNickname;\n        return storageRepository.setDeviceNickname(message.deviceNickname);\n      });\n    }\n\n    // ARCHITECTURAL CHANGE: Use state machine instead of direct initialization\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\n    savePromise.then(() => stateMachineReady).then(() => {\n      return stateMachine.transition('API_KEY_SET', { apiKey: message.apiKey });\n    }).then(() => {\n      // Send response with session data after state machine completes\n      sendResponse({\n        success: true,\n        isAuthenticated: stateMachine.isInState(ServiceWorkerState.READY) || stateMachine.isInState(ServiceWorkerState.DEGRADED),\n        userInfo: sessionCache.userInfo,\n        devices: sessionCache.devices,\n        recentPushes: sessionCache.recentPushes,\n        autoOpenLinks: sessionCache.autoOpenLinks,\n        deviceNickname: sessionCache.deviceNickname,\n        websocketConnected: websocketClient ? websocketClient.isConnected() : false\n      });\n    }).catch((error) => {\n      debugLogger.general('ERROR', 'Error saving API key', null, error);\n      sendResponse({ success: false, error: error.message });\n    });\n\n    return true; // Keep message channel open for async response\n  } else if (message.action === 'logout') {\n    // ARCHITECTURAL CHANGE: Use state machine for logout\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\n    stateMachineReady.then(() => {\n      return stateMachine.transition('LOGOUT');\n    }).then(() => {\n      // Clear storage via repository\n      return storageRepository.setApiKey(null);\n    }).then(() => {\n      return storageRepository.setDeviceIden(null);\n    }).then(() => {\n      sendResponse({ success: true });\n    }).catch((error) => {\n      debugLogger.general('ERROR', 'Error during logout', null, error);\n      sendResponse({ success: false, error: error.message });\n    });\n\n    return true; // Async response\n  } else if (message.action === 'refreshSession') {\n    // RACE CONDITION FIX: Ensure configuration is loaded before processing\n    (async () => {\n      await ensureConfigLoaded();\n\n      const apiKey = getApiKey();\n      if (apiKey) {\n        refreshSessionCache(apiKey).then(() => {\n          sendResponse({\n            isAuthenticated: true,\n            userInfo: sessionCache.userInfo,\n            devices: sessionCache.devices,\n            recentPushes: sessionCache.recentPushes,\n            autoOpenLinks: sessionCache.autoOpenLinks,\n            deviceNickname: sessionCache.deviceNickname\n          });\n        }).catch((error) => {\n          debugLogger.general('ERROR', 'Error refreshing session', null, error);\n          sendResponse({ isAuthenticated: false });\n        });\n      } else {\n        sendResponse({ isAuthenticated: false });\n      }\n    })();\n\n    return true; // Async response\n  } else if (message.action === 'settingsChanged') {\n    const promises: Promise<void>[] = [];\n\n    // BONUS FIX: Handle device nickname updates from \"Save All Settings\" button\n    if (message.settings?.deviceNickname) {\n      const newNickname = message.settings.deviceNickname;\n      const apiKey = getApiKey();\n      const deviceIden = getDeviceIden();\n\n      // Trigger API update if we have the required credentials\n      if (apiKey && deviceIden) {\n        promises.push(\n          updateDeviceNickname(apiKey, deviceIden, newNickname).then(() => {\n            // Only update state and storage after API success\n            setDeviceNickname(newNickname);\n            sessionCache.deviceNickname = newNickname;\n            return storageRepository.setDeviceNickname(newNickname);\n          })\n        );\n      } else {\n        // No API credentials, just update local state and storage\n        setDeviceNickname(newNickname);\n        sessionCache.deviceNickname = newNickname;\n        promises.push(storageRepository.setDeviceNickname(newNickname));\n      }\n    }\n\n    if (message.autoOpenLinks !== undefined) {\n      setAutoOpenLinks(message.autoOpenLinks);\n      sessionCache.autoOpenLinks = message.autoOpenLinks;\n      promises.push(storageRepository.setAutoOpenLinks(message.autoOpenLinks));\n    }\n\n    if (message.notificationTimeout !== undefined) {\n      setNotificationTimeout(message.notificationTimeout);\n      promises.push(storageRepository.setNotificationTimeout(message.notificationTimeout));\n    }\n\n    Promise.all(promises).then(() => {\n      sendResponse({ success: true });\n    }).catch((error) => {\n      debugLogger.general('ERROR', 'Error saving settings', null, error);\n      sendResponse({ success: false, error: error.message });\n    });\n\n    return true; // Async response\n  } else if (message.action === 'updateDeviceNickname') {\n    // RACE CONDITION FIX: Ensure configuration is loaded before processing\n    (async () => {\n      await ensureConfigLoaded();\n\n      const apiKey = getApiKey();\n      const deviceIden = getDeviceIden();\n\n      if (apiKey && deviceIden && message.nickname) {\n        updateDeviceNickname(apiKey, deviceIden, message.nickname).then(async () => {\n          setDeviceNickname(message.nickname);\n          sessionCache.deviceNickname = message.nickname;\n          await storageRepository.setDeviceNickname(message.nickname);\n\n          sendResponse({ success: true });\n        }).catch((error) => {\n          debugLogger.general('ERROR', 'Error updating device nickname', null, error);\n          sendResponse({ success: false, error: error.message });\n        });\n      } else {\n        sendResponse({ success: false, error: 'Missing required parameters' });\n      }\n    })();\n\n    return true; // Async response\n  } else if (message.action === 'getDebugSummary') {\n    // Return debug summary for debug dashboard\n    (async () => {\n      // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\n      await stateMachineReady;\n\n      const logData = debugLogger.exportLogs();\n      const wsState = wsStateMonitor.getStateReport();\n      const perfData = performanceMonitor.exportPerformanceData();\n      const perfSummary = perfData.summary;\n\n      // Format websocket state for dashboard compatibility\n      const websocketState = {\n        current: {\n          stateText: websocketClient ? (websocketClient.isConnected() ? 'Connected' : 'Disconnected') : 'Not initialized',\n          readyState: wsState.currentState,\n          stateMachineState: stateMachine.getCurrentState(),\n          stateMachineDescription: stateMachine.getStateDescription()\n        },\n        lastCheck: wsState.lastCheck,\n        historyLength: wsState.historyLength\n      };\n\n      // Map performance data to match frontend expectations\n      // The frontend expects: { websocket, qualityMetrics, notifications }\n      // The backend provides: { summary: { websocket, health, quality, metrics, notifications } }\n      const performanceForDashboard = {\n        websocket: perfSummary.websocket,\n        qualityMetrics: {\n          // Map health checks\n          healthChecksPassed: perfSummary.health?.success || 0,\n          healthChecksFailed: perfSummary.health?.failure || 0,\n          // Map quality metrics\n          disconnectionCount: perfSummary.quality?.disconnections || 0,\n          consecutiveFailures: perfSummary.quality?.consecutiveFailures || 0,\n          // These metrics don't exist in the backend yet, so they'll be undefined\n          averageLatency: undefined,\n          minLatency: undefined,\n          maxLatency: undefined,\n          connectionUptime: 0,\n          currentUptime: 0\n        },\n        notifications: perfSummary.notifications\n      };\n\n      // MV3 LIFECYCLE TRACKING: Gather metrics for dashboard\n      const { restarts = 0, recoveryTimings = [] } = await chrome.storage.local.get(['restarts', 'recoveryTimings']);\n      const avgRecoveryTime = recoveryTimings.length > 0\n        ? recoveryTimings.reduce((a: number, b: number) => a + b, 0) / recoveryTimings.length\n        : 0;\n\n      const mv3LifecycleStats = {\n        restarts: restarts,\n        wakeUpTriggers: initTracker.exportData().stats, // We already track this!\n        avgRecoveryTime: avgRecoveryTime.toFixed(0) + ' ms',\n        // Add more stats like downtime here in the future\n      };\n\n      const summary = {\n        config: debugConfigManager.getConfig(),\n        logs: logData.logs, // Array of log entries\n        totalLogs: logData.summary.totalLogs,\n        performance: performanceForDashboard,\n        websocketState: websocketState,\n        initializationStats: initTracker.exportData(),\n        mv3LifecycleStats: mv3LifecycleStats, // Add the new data object\n        errors: {\n          total: logData.summary.errors,\n          last24h: logData.summary.errors, // Add last24h for dashboard\n          critical: []\n        }\n      };\n\n      sendResponse({ success: true, summary });\n    })();\n\n    return true; // Async response\n  } else if (message.action === 'clearAllLogs') {\n    // Clear all logs from memory and persistent storage\n    debugLogger.clearLogs().then(() => {\n      sendResponse({ success: true });\n    });\n    return true; // Async response\n  } else if (message.action === 'updateDebugConfig') {\n    // Update debug configuration\n    if (message.config) {\n      debugConfigManager.updateConfig(message.config).then(() => {\n        sendResponse({ success: true });\n      }).catch((error) => {\n        debugLogger.general('ERROR', 'Failed to update debug config', null, error);\n        sendResponse({ success: false, error: error.message });\n      });\n    } else {\n      sendResponse({ success: false, error: 'No config provided' });\n    }\n    return true; // Async response\n  } else if (message.action === 'exportDebugData') {\n    // This handler gathers all debug data for exporting\n    debugLogger.general('INFO', 'Exporting full debug data');\n\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\n    (async () => {\n      await stateMachineReady;\n\n      const logData = debugLogger.exportLogs();\n      const errorSummary = globalErrorTracker.getErrorSummary();\n\n      const dataToExport = {\n        timestamp: new Date().toISOString(),\n        version: chrome.runtime.getManifest().version,\n        debugLogs: logData,\n        performanceData: performanceMonitor.exportPerformanceData(),\n        systemInfo: {\n          websocketState: wsStateMonitor.getStateReport(),\n          initializationData: initTracker.exportData(),\n          stateMachine: {\n            currentState: stateMachine.getCurrentState(),\n            description: stateMachine.getStateDescription(),\n          },\n        },\n        errorData: {\n          summary: errorSummary,\n          recent: globalErrorTracker.exportErrorData().errors,\n        },\n        sessionCache: {\n          isAuthenticated: sessionCache.isAuthenticated,\n          lastUpdated: sessionCache.lastUpdated ? new Date(sessionCache.lastUpdated).toISOString() : 'never',\n          userInfo: sessionCache.userInfo ? { email: sessionCache.userInfo.email?.substring(0, 3) + '***' } : null,\n          deviceCount: sessionCache.devices?.length || 0,\n          pushCount: sessionCache.recentPushes?.length || 0\n        }\n      };\n\n      sendResponse({ success: true, data: dataToExport });\n    })();\n\n    return true; // Async response\n  } else if (message.action === 'getNotificationData') {\n    // Return notification data for detail view\n    const pushData = notificationDataStore.get(message.notificationId);\n    if (pushData) {\n      sendResponse({ success: true, push: pushData });\n    } else {\n      sendResponse({ success: false, error: 'Notification not found' });\n    }\n    return false; // Synchronous response\n  } else if (message.action === 'sendPush') {\n    // Handle push sending from popup\n    // SERVICE WORKER AMNESIA FIX: Ensure configuration is loaded before attempting to send push\n    (async () => {\n      try {\n        // Ensure core configuration is loaded from storage if service worker just woke up\n        await ensureConfigLoaded();\n\n        const apiKey = getApiKey();\n        if (!apiKey) {\n          sendResponse({ success: false, error: 'Not logged in. Please try again.' });\n          return;\n        }\n\n        const pushData = message.pushData;\n        if (!pushData || !pushData.type) {\n          sendResponse({ success: false, error: 'Invalid push data' });\n          return;\n        }\n\n        // Send push via API\n        const response = await fetch('https://api.pushbullet.com/v2/pushes', {\n          method: 'POST',\n          headers: {\n            'Access-Token': apiKey,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(pushData)\n        });\n\n        if (!response.ok) {\n          const errorText = await response.text();\n          let errorMessage = 'Failed to send push';\n          try {\n            const errorData = JSON.parse(errorText) as { error?: { message?: string } };\n            if (errorData.error?.message) {\n              errorMessage = errorData.error.message;\n            }\n          } catch {\n            // Use default\n          }\n          throw new Error(errorMessage);\n        }\n\n        // Refresh pushes after sending\n        await refreshPushes(notificationDataStore);\n\n        sendResponse({ success: true });\n      } catch (error) {\n        debugLogger.general('ERROR', 'Failed to send push', { pushType: message.pushData?.type }, error as Error);\n        sendResponse({ success: false, error: (error as Error).message });\n      }\n    })();\n\n    return true; // Async response\n  }\n\n  return false;\n});\n\n// Export debug info function for console access\n(globalThis as any).exportDebugInfo = function() {\n  return {\n    debugLogs: debugLogger.exportLogs(),\n    performanceData: performanceMonitor.exportPerformanceData(),\n    websocketState: wsStateMonitor.getStateReport(),\n    initializationData: initTracker.exportData(),\n    sessionCache: {\n      isAuthenticated: sessionCache.isAuthenticated,\n      lastUpdated: sessionCache.lastUpdated ? new Date(sessionCache.lastUpdated).toISOString() : 'never',\n      userInfo: sessionCache.userInfo ? { email: sessionCache.userInfo.email?.substring(0, 3) + '***' } : null,\n      deviceCount: sessionCache.devices?.length || 0,\n      pushCount: sessionCache.recentPushes?.length || 0\n    },\n    websocketConnected: websocketClient ? websocketClient.isConnected() : false,\n    initializationState: {\n      inProgress: initializationState.inProgress,\n      completed: initializationState.completed,\n      timestamp: initializationState.timestamp ? new Date(initializationState.timestamp).toISOString() : null,\n      hasError: !!initializationState.error\n    }\n  };\n};\n\ndebugLogger.general('INFO', 'Background service worker initialized', {\n  timestamp: new Date().toISOString()\n});\n\n"],
  "mappings": ";;;AAcA,MAAM,cAAc;AACpB,MAAM,sBAAsB;AAWrB,MAAM,eAA4B;AAAA,IACvC,SAAS;AAAA,IACT,YAAY;AAAA,MACV,WAAW;AAAA,MACX,eAAe;AAAA,MACf,KAAK;AAAA,MACL,SAAS;AAAA,MACT,SAAS;AAAA,MACT,aAAa;AAAA,MACb,OAAO;AAAA,IACT;AAAA,IACA,UAAU;AAAA,IACV,eAAe;AAAA,IACf,cAAc;AAAA,EAChB;AAWO,MAAM,cAAN,MAAkB;AAAA,IACf,OAAmB,CAAC;AAAA,IACpB,YAAY,KAAK,IAAI;AAAA,IACrB,qBAAqB,oBAAI,IAAoB;AAAA;AAAA;AAAA;AAAA;AAAA,IAMrD,MAAM,YAA2B;AAC/B,UAAI;AACF,cAAM,SAAS,MAAM,OAAO,QAAQ,MAAM,IAAI,WAAW;AACzD,YAAI,OAAO,WAAW,KAAK,MAAM,QAAQ,OAAO,WAAW,CAAC,GAAG;AAC7D,eAAK,OAAO,OAAO,WAAW;AAC9B,kBAAQ;AAAA,YACN,uBAAuB,KAAK,KAAK,MAAM;AAAA,UACzC;AAAA,QACF;AAAA,MACF,SAASA,QAAO;AACd,gBAAQ,MAAM,sCAAsCA,MAAK;AAAA,MAC3D;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,MAAM,QAAuB;AAC3B,UAAI;AAEF,YAAI,KAAK,KAAK,SAAS,qBAAqB;AAC1C,eAAK,OAAO,KAAK,KAAK,MAAM,KAAK,KAAK,SAAS,mBAAmB;AAAA,QACpE;AACA,cAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,CAAC,WAAW,GAAG,KAAK,KAAK,CAAC;AAAA,MAC7D,SAASA,QAAO;AAEd,gBAAQ,MAAM,6CAA6CA,MAAK;AAAA,MAClE;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,MAAM,YAA2B;AAC/B,WAAK,OAAO,CAAC;AACb,YAAM,KAAK,MAAM;AACjB,WAAK,IAAI,WAAW,QAAQ,0CAA0C;AAAA,IACxE;AAAA,IAEQ,SAAS,MAAwB;AACvC,UAAI,CAAC,aAAa,aAAc,QAAO;AACvC,UAAI,OAAO,SAAS,UAAU;AAC5B,YAAI,KAAK,SAAS,MAAM,mBAAmB,KAAK,IAAI,GAAG;AACrD,iBAAO,KAAK,UAAU,GAAG,CAAC,IAAI,QAAQ,KAAK,UAAU,KAAK,SAAS,CAAC;AAAA,QACtE;AACA,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,OAAO,SAAS,UAAU;AACpC,cAAM,YAAiD,MAAM,QAAQ,IAAI,IACrE,CAAC,IACD,CAAC;AACL,mBAAW,OAAO,MAAiC;AACjD,cACE,IAAI,YAAY,EAAE,SAAS,OAAO,KAClC,IAAI,YAAY,EAAE,SAAS,KAAK,KAChC,IAAI,YAAY,EAAE,SAAS,UAAU,GACrC;AACA,YAAC,UAAkB,GAAG,IAAI,KAAK,SAAU,KAAa,GAAG,CAAC;AAAA,UAC5D,OAAO;AACL,YAAC,UAAkB,GAAG,IAAK,KAAa,GAAG;AAAA,UAC7C;AAAA,QACF;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA,IAEQ,eAAuB;AAC7B,YAAM,MAAM,oBAAI,KAAK;AACrB,YAAM,UAAU,KAAK,IAAI,IAAI,KAAK;AAClC,aAAO,GAAG,IAAI,YAAY,CAAC,MAAM,OAAO;AAAA,IAC1C;AAAA;AAAA;AAAA;AAAA,IAKQ,qBAAqB,MAAuB;AAClD,UAAI,OAAO,SAAS,YAAY,SAAS,MAAM;AAC7C,YAAI;AACF,iBAAO,KAAK,UAAU,MAAM,MAAM,CAAC;AAAA,QACrC,QAAQ;AACN,iBAAO,OAAO,IAAI;AAAA,QACpB;AAAA,MACF;AACA,aAAO,OAAO,QAAQ,MAAM;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAKQ,sBAAsBA,QAA6B;AACzD,UAAI,CAACA,OAAO,QAAO;AAEnB,UAAIA,kBAAiB,OAAO;AAC1B,eAAO,GAAGA,OAAM,IAAI,KAAKA,OAAM,OAAO;AAAA,MACxC;AAGA,UAAI;AACF,eAAO,KAAK,UAAUA,QAAO,MAAM,CAAC;AAAA,MACtC,QAAQ;AACN,eAAO,OAAOA,MAAK;AAAA,MACrB;AAAA,IACF;AAAA,IAEA,IACE,UACA,OACA,SACA,OAAgB,MAChBA,SAAsB,MACtB;AACA,UAAI,CAAC,aAAa,WAAW,CAAC,aAAa,WAAW,QAAQ,EAAG;AACjE,YAAM,YAAY,KAAK,aAAa;AACpC,YAAM,QAAkB;AAAA,QACtB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,OAAO,KAAK,SAAS,IAAI,IAAI;AAAA,QACnC,OAAOA,SACH;AAAA,UACA,MAAMA,OAAM;AAAA,UACZ,SAASA,OAAM;AAAA,UACf,OAAQA,OAAc;AAAA,QACxB,IACE;AAAA,MACN;AACA,UAAIA,UAAS,UAAU,SAAS;AAC9B,2BAAmB;AAAA,UACjBA;AAAA,UACA,EAAE,UAAU,SAAS,MAAM,OAAO,KAAK,SAAS,IAAI,IAAI,KAAK;AAAA,UAC7D;AAAA,QACF;AAAA,MACF;AACA,WAAK,KAAK,KAAK,KAAK;AAGpB,YAAM,SAAS,IAAI,QAAQ,IAAI,KAAK,KAAK,SAAS;AAClD,YAAM,OAAO,GAAG,MAAM,IAAI,OAAO;AACjC,YAAM,YAAY,OAAO,KAAK,SAAS,IAAI,IAAI;AAC/C,cAAQ,OAAO;AAAA,QACf,KAAK;AACH,cAAI,aAAaA,QAAO;AACtB,oBAAQ,MAAM,IAAI;AAClB,oBAAQ,MAAM,WAAW,KAAK,qBAAqB,SAAS,CAAC;AAC7D,oBAAQ,MAAM,YAAY,KAAK,sBAAsBA,MAAK,CAAC;AAAA,UAC7D,WAAW,WAAW;AACpB,oBAAQ,MAAM,IAAI;AAClB,oBAAQ,MAAM,WAAW,KAAK,qBAAqB,SAAS,CAAC;AAAA,UAC/D,WAAWA,QAAO;AAChB,oBAAQ,MAAM,IAAI;AAClB,oBAAQ,MAAM,YAAY,KAAK,sBAAsBA,MAAK,CAAC;AAAA,UAC7D,OAAO;AACL,oBAAQ,MAAM,IAAI;AAAA,UACpB;AACA;AAAA,QACF,KAAK;AACH,cAAI,WAAW;AACb,oBAAQ,KAAK,IAAI;AACjB,oBAAQ,KAAK,WAAW,KAAK,qBAAqB,SAAS,CAAC;AAAA,UAC9D,OAAO;AACL,oBAAQ,KAAK,IAAI;AAAA,UACnB;AACA;AAAA,QACF,KAAK;AACH,cAAI,WAAW;AACb,oBAAQ,KAAK,IAAI;AACjB,oBAAQ,KAAK,WAAW,KAAK,qBAAqB,SAAS,CAAC;AAAA,UAC9D,OAAO;AACL,oBAAQ,KAAK,IAAI;AAAA,UACnB;AACA;AAAA,QACF;AACE,cAAI,WAAW;AACb,oBAAQ,IAAI,IAAI;AAChB,oBAAQ,IAAI,WAAW,SAAS;AAAA,UAClC,OAAO;AACL,oBAAQ,IAAI,IAAI;AAAA,UAClB;AAAA,MACF;AAAA,IACF;AAAA,IAEA,UAAU,OAAiB,SAAiB,MAAgBA,QAAe;AACzE,WAAK,IAAI,aAAa,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IAC3D;AAAA,IACA,cACE,OACA,SACA,MACAA,QACA;AACA,WAAK,IAAI,iBAAiB,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IAC/D;AAAA,IACA,IAAI,OAAiB,SAAiB,MAAgBA,QAAe;AACnE,WAAK,IAAI,OAAO,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IACrD;AAAA,IACA,QAAQ,OAAiB,SAAiB,MAAgBA,QAAe;AACvE,WAAK,IAAI,WAAW,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IACzD;AAAA,IACA,QAAQ,OAAiB,SAAiB,MAAgBA,QAAe;AACvE,WAAK,IAAI,WAAW,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IACzD;AAAA,IACA,YAAY,OAAiB,SAAiB,MAAgBA,QAAe;AAC3E,WAAK,IAAI,eAAe,OAAO,SAAS,MAAMA,UAAS,IAAI;AAAA,IAC7D;AAAA,IACA,MAAM,SAAiB,MAAgBA,QAAe;AACpD,WAAK,IAAI,SAAS,SAAS,SAAS,MAAMA,UAAS,IAAI;AAAA,IACzD;AAAA,IAEA,WAAW,MAAc;AACvB,WAAK,mBAAmB,IAAI,MAAM,KAAK,IAAI,CAAC;AAC5C,WAAK,YAAY,SAAS,kBAAkB,IAAI,EAAE;AAAA,IACpD;AAAA,IACA,SAAS,MAA6B;AACpC,YAAM,QAAQ,KAAK,mBAAmB,IAAI,IAAI;AAC9C,UAAI,OAAO;AACT,cAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,aAAK,mBAAmB,OAAO,IAAI;AACnC,aAAK,YAAY,QAAQ,gBAAgB,IAAI,IAAI;AAAA,UAC/C,UAAU,GAAG,QAAQ;AAAA,QACvB,CAAC;AACD,eAAO;AAAA,MACT;AACA,WAAK,YAAY,QAAQ,oBAAoB,IAAI,EAAE;AACnD,aAAO;AAAA,IACT;AAAA,IACA,cAAc,QAAQ,IAAI,WAA+B,MAAM;AAC7D,UAAI,OAAO,KAAK;AAChB,UAAI,SAAU,QAAO,KAAK,OAAO,CAAC,MAAM,EAAE,aAAa,QAAQ;AAC/D,aAAO,KAAK,MAAM,CAAC,KAAK;AAAA,IAC1B;AAAA,IACA,aAAa;AACX,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,MAAM,KAAK;AAAA,QACX,SAAS;AAAA,UACP,WAAW,KAAK,KAAK;AAAA,UACrB,YACE,OAAO,KAAK,aAAa,UAAU,EACnC,OAAO,CAAC,KAA6B,QAAQ;AAC7C,gBAAI,GAAG,IAAI,KAAK,KAAK,OAAO,CAAC,MAAM,EAAE,aAAa,GAAG,EAAE;AACvD,mBAAO;AAAA,UACT,GAAG,CAAC,CAAC;AAAA,UACL,QAAQ,KAAK,KAAK,OAAO,CAAC,MAAM,EAAE,UAAU,OAAO,EAAE;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEO,MAAM,cAAc,IAAI,YAAY;AAI3C,cAAY,UAAU;AAEf,MAAM,qBAAN,MAAyB;AAAA,IAC9B,MAAM,aAAa;AACjB,UAAI;AACF,oBAAY,QAAQ,SAAS,0CAA0C;AACvE,cAAM,SAAS,MAAM,IAAI,QAAa,CAAC,YAAY;AACjD,iBAAO,QAAQ,MAAM,IAAI,CAAC,aAAa,GAAG,CAAC,UAAU,QAAQ,KAAK,CAAC;AAAA,QACrE,CAAC;AACD,YAAI,OAAO,aAAa;AACtB,iBAAO,OAAO,cAAc,OAAO,WAAmC;AACtE,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,OAAO;AACL,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,SAASA,QAAY;AACnB,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACAA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,MAAM,aAAa;AACjB,UAAI;AACF,oBAAY,QAAQ,SAAS,uCAAuC;AACpE,cAAM,IAAI,QAAQ,CAAC,YAAY;AAC7B,iBAAO,QAAQ,MAAM;AAAA,YAAI,EAAE,aAAa,aAAa;AAAA,YAAG,MACtD,QAAQ,IAAI;AAAA,UACd;AAAA,QACF,CAAC;AACD,oBAAY,QAAQ,QAAQ,sCAAsC;AAAA,MACpE,SAASA,QAAY;AACnB,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACAA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,aAAa,SAA+B;AAC1C,aAAO,OAAO,cAAc,OAAO;AACnC,WAAK,KAAK,WAAW;AACrB,kBAAY,QAAQ,QAAQ,+BAA+B,OAAO;AAAA,IACpE;AAAA,IACA,eAAe,UAAuB;AACpC,UACE,OAAO,UAAU,eAAe,KAAK,aAAa,YAAY,QAAQ,GACtE;AACA,qBAAa,WAAW,QAAQ,IAAI,CAAC,aAAa,WAAW,QAAQ;AACrE,aAAK,KAAK,WAAW;AACrB,oBAAY,QAAQ,QAAQ,kBAAkB,QAAQ,YAAY;AAAA,UAChE;AAAA,UACA,SAAS,aAAa,WAAW,QAAQ;AAAA,QAC3C,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,YAAY,OAAiB;AAC3B,YAAM,QAAoB,CAAC,SAAS,QAAQ,QAAQ,OAAO;AAC3D,UAAI,MAAM,SAAS,KAAK,GAAG;AACzB,qBAAa,WAAW;AACxB,aAAK,KAAK,WAAW;AACrB,oBAAY,QAAQ,QAAQ,0BAA0B,KAAK,EAAE;AAAA,MAC/D;AAAA,IACF;AAAA,IACA,YAAyB;AACvB,aAAO,EAAE,GAAG,aAAa;AAAA,IAC3B;AAAA,IACA,cAAc;AACZ,YAAM,MAAmB;AAAA,QACvB,SAAS;AAAA,QACT,YAAY;AAAA,UACV,WAAW;AAAA,UACX,eAAe;AAAA,UACf,KAAK;AAAA,UACL,SAAS;AAAA,UACT,SAAS;AAAA,UACT,aAAa;AAAA,UACb,OAAO;AAAA,QACT;AAAA,QACA,UAAU;AAAA,QACV,eAAe;AAAA,QACf,cAAc;AAAA,MAChB;AACA,aAAO,OAAO,cAAc,GAAG;AAC/B,WAAK,KAAK,WAAW;AACrB,kBAAY,QAAQ,QAAQ,uCAAuC;AAAA,IACrE;AAAA,EACF;AAEO,MAAM,qBAAqB,IAAI,mBAAmB;AACzD,OAAK,mBAAmB,WAAW;AAE5B,MAAM,qBAAN,MAAyB;AAAA,IACtB,SAOH,CAAC;AAAA,IACE,cAAc,oBAAI,IAAoB;AAAA,IACtC,iBAAwB,CAAC;AAAA,IAEjC,WAAWA,QAAc,UAAe,CAAC,GAAG,WAAW,WAAW;AAChE,YAAM,QAAQ;AAAA,QACZ,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC;AAAA,QACA,SAASA,OAAM;AAAA,QACf,MAAMA,OAAM;AAAA,QACZ,OAAQA,OAAc;AAAA,QACtB;AAAA,MACF;AACA,WAAK,OAAO,KAAK,KAAK;AACtB,YAAM,SAAS,KAAK,YAAY,IAAI,QAAQ,KAAK,KAAK;AACtD,WAAK,YAAY,IAAI,UAAU,KAAK;AACpC,UAAI,SAAS,EAAG,MAAK,eAAe,KAAK,KAAK;AAAA,IAChD;AAAA,IACA,kBAAkB;AAChB,YAAM,QAAgC,CAAC;AACvC,WAAK,YAAY,QAAQ,CAAC,GAAG,MAAO,MAAM,CAAC,IAAI,CAAE;AACjD,aAAO;AAAA,QACL,OAAO,KAAK,OAAO;AAAA,QACnB,YAAY;AAAA,QACZ,UAAU,KAAK,eAAe;AAAA,MAChC;AAAA,IACF;AAAA,IACA,kBAAkB;AAChB,aAAO,EAAE,QAAQ,KAAK,OAAO,MAAM,IAAI,GAAG,SAAS,KAAK,gBAAgB,EAAE;AAAA,IAC5E;AAAA,EACF;AAEO,MAAM,qBAAqB,IAAI,mBAAmB;AAGzD,MAAI;AACF,SAAK,iBAAiB,SAAS,CAAC,UAAsB;AACpD,yBAAmB;AAAA,QAChB,MAAc,SAAS,IAAI,MAAM,MAAM,OAAO;AAAA,QAC/C;AAAA,UACE,UAAU,MAAM;AAAA,UAChB,QAAQ,MAAM;AAAA,UACd,OAAO,MAAM;AAAA,UACb,MAAM;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,QAAQ;AAAA,EAER;AACA,MAAI;AACF,SAAK;AAAA,MACH;AAAA,MACA,CAAC,UAAiC;AAChC,2BAAmB;AAAA,UAChB,MAAc,UAAU,IAAI,MAAM,6BAA6B;AAAA,UAChE,EAAE,MAAM,oBAAoB;AAAA,UAC5B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,QAAQ;AAAA,EAER;;;ACxeO,MAAM,qBAAN,MAAyB;AAAA,IACtB,UAAU,oBAAI,IAAoB;AAAA,IAClC,uBAA4D,CAAC;AAAA,IAC7D,mBAAmB,EAAE,oBAAoB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,oBAAoB,MAAuB,eAAe,EAAE;AAAA,IACtM,sBAAsB,EAAE,gBAAgB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,cAAc,EAAE;AAAA,IAC5G,eAAe,EAAE,SAAS,GAAG,SAAS,GAAG,WAAW,KAAsB;AAAA,IAC1E,UAAU,EAAE,gBAAgB,GAAG,iBAAiB,GAAG,qBAAqB,EAAE;AAAA,IAC1E,SAAiC,CAAC;AAAA,IAE1C,OAAO,QAAgB,QAAQ,GAAG;AAAE,YAAM,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK;AAAG,WAAK,QAAQ,IAAI,QAAQ,MAAM,KAAK;AAAA,IAAG;AAAA,IACtH,MAAM,MAAc;AAAE,WAAK,OAAO,IAAI,IAAI,KAAK,IAAI;AAAA,IAAG;AAAA,IACtD,IAAI,MAAc;AAAE,UAAI,KAAK,OAAO,IAAI,GAAG;AAAE,cAAM,IAAI,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI;AAAG,eAAO,KAAK,OAAO,IAAI;AAAG,aAAK,OAAO,SAAS,IAAI,IAAI,CAAC;AAAG,eAAO;AAAA,MAAG;AAAE,aAAO;AAAA,IAAM;AAAA,IAC3K,0BAA0B,SAAkB;AAAE,WAAK,iBAAiB;AAAsB,UAAI,SAAS;AAAE,aAAK,iBAAiB;AAAyB,aAAK,iBAAiB,qBAAqB,KAAK,IAAI;AAAG,aAAK,QAAQ,sBAAsB;AAAA,MAAG;AAAA,IAAE;AAAA,IACvP,uBAAuB,WAAW,MAAM,YAAY,OAAO;AAAE,UAAI,SAAU,MAAK,iBAAiB;AAAoB,UAAI,UAAW,MAAK,iBAAiB;AAAA,IAAqB;AAAA,IAC/K,8BAA8B;AAAE,WAAK,iBAAiB;AAAwB,WAAK,QAAQ;AAAA,IAAuB;AAAA,IAClH,2BAA2B;AAAE,WAAK,aAAa;AAAW,WAAK,aAAa,YAAY,KAAK,IAAI;AAAG,WAAK,QAAQ,sBAAsB;AAAA,IAAG;AAAA,IAC1I,2BAA2B;AAAE,WAAK,aAAa;AAAW,WAAK,aAAa,YAAY,KAAK,IAAI;AAAG,WAAK,QAAQ;AAAA,IAAuB;AAAA,IACxI,sBAAsB;AAAE,WAAK,QAAQ;AAAA,IAAkB;AAAA,IACvD,uBAAuB;AAAE,WAAK,QAAQ;AAAA,IAAmB;AAAA,IACzD,mBAAmB,OAAe;AAAE,WAAK,qBAAqB,KAAK,EAAE,IAAI,KAAK,IAAI,GAAG,MAAM,CAAC;AAAG,UAAI,KAAK,qBAAqB,SAAS,IAAK,MAAK,qBAAqB,MAAM;AAAA,IAAG;AAAA,IAC9K,qBAAqB;AAAE,WAAK,oBAAoB;AAAA,IAAkB;AAAA,IAClE,4BAA4B;AAAE,WAAK,oBAAoB;AAAA,IAAwB;AAAA,IAC/E,2BAA2B;AAAE,WAAK,oBAAoB;AAAA,IAAuB;AAAA,IAC7E,wBAAwB;AAAE,WAAK,oBAAoB;AAAA,IAAgB;AAAA,IACnE,wBAAwB;AAAE,aAAO,EAAE,WAAW,KAAK,kBAAkB,QAAQ,KAAK,cAAc,SAAS,KAAK,SAAS,eAAe,KAAK,qBAAqB,SAAS,OAAO,YAAY,KAAK,OAAO,EAA4B;AAAA,IAAG;AAAA,IACvO,oBAAoB;AAAE,aAAO,KAAK;AAAA,IAAS;AAAA,IAC3C,wBAAwB;AAAE,aAAO,EAAE,SAAS,KAAK,sBAAsB,GAAG,UAAU,KAAK,qBAAqB,MAAM,IAAI,EAAE;AAAA,IAAG;AAAA,EAC/H;AAEO,MAAM,qBAAqB,IAAI,mBAAmB;;;AC7BlD,MAAM,wBAAN,MAA4B;AAAA,IACzB,kBAAgE,CAAC;AAAA,IACjE,QAAgC,EAAE,aAAa,GAAG,WAAW,GAAG,SAAS,GAAG,WAAW,GAAG,QAAQ,EAAE;AAAA,IAE5G,qBAAqB,QAAgB;AACnC,WAAK,gBAAgB,KAAK,EAAE,QAAQ,YAAW,oBAAI,KAAK,GAAE,YAAY,EAAE,CAAC;AACzE,UAAI,KAAK,MAAM,MAAM,MAAM,OAAW,MAAK,MAAM,MAAM;AAAA,IACzD;AAAA,IACA,aAAa;AAAE,aAAO,EAAE,iBAAiB,KAAK,gBAAgB,MAAM,IAAI,GAAG,OAAO,EAAE,GAAG,KAAK,MAAM,EAAE;AAAA,IAAG;AAAA,EACzG;AAEO,MAAM,cAAc,IAAI,sBAAsB;AAE9C,MAAM,wBAAN,MAA4B;AAAA,IACzB,eAAoF,CAAC;AAAA,IACrF,iBAAiB,KAAK,IAAI;AAAA,IAC1B,qBAA4D;AAAA,IAC5D,kBAAkB,EAAE,aAAa,KAAM;AAAA,IAE/C,kBAAkB,UAAkB;AAClC,YAAM,MAAM,KAAK,IAAI;AACrB,YAAM,OAAO,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAC3D,YAAM,WAAW,OAAO,MAAM,KAAK,YAAY;AAC/C,WAAK,aAAa,KAAK,EAAE,WAAW,KAAK,OAAO,UAAU,SAAS,CAAC;AACpE,UAAI,KAAK,aAAa,SAAS,IAAK,MAAK,aAAa,MAAM;AAAA,IAC9D;AAAA,IACA,iBAAiB;AACf,YAAM,eAAgB,WAAmB,aAAa,OAAQ,WAAmB,UAAU,eAAe,WACtG,CAAC,cAAc,QAAQ,WAAW,QAAQ,EAAG,WAAmB,UAAU,UAAU,IAAI;AAC5F,aAAO,EAAE,cAAc,WAAW,IAAI,KAAK,KAAK,cAAc,EAAE,YAAY,GAAG,eAAe,KAAK,aAAa,OAAO;AAAA,IACzH;AAAA,IACA,kBAAkB;AAChB,UAAI,KAAK,mBAAoB;AAC7B,WAAK,qBAAqB,YAAY,MAAM;AAC1C,aAAK,iBAAiB,KAAK,IAAI;AAC/B,cAAM,QAAS,WAAmB,YAAa,WAAmB,UAAU,aAAa;AACzF,YAAI;AAAE,UAAC,WAAmB,aAAa,UAAU,SAAS,yBAAyB,EAAE,MAAM,CAAC;AAAA,QAAG,QAAQ;AAAA,QAAa;AAAA,MACtH,GAAG,GAAK;AAAA,IACV;AAAA,IACA,iBAAiB;AAAE,UAAI,KAAK,oBAAoB;AAAE,sBAAc,KAAK,kBAAkB;AAAG,aAAK,qBAAqB;AAAA,MAAM;AAAA,IAAE;AAAA,EAC9H;AAEO,MAAM,iBAAiB,IAAI,sBAAsB;;;AC6NjD,WAAS,WAAW,MAA8B;AACvD,WAAO,KAAK,SAAS;AAAA,EACvB;;;AClQO,WAAS,8BACd,gBACA,SACA,UACA,WACM;AAEN,UAAM,UAAU,OAAO,QAAQ,OAAO,mBAAmB;AAGzD,UAAM,cAA8D;AAAA,MAClE,MAAM;AAAA,MACN;AAAA;AAAA,MACA,OAAO,QAAQ,SAAS;AAAA,MACxB,SAAS,QAAQ,WAAW;AAAA,MAC5B,UAAU,QAAQ,YAAY;AAAA,IAChC;AAGA,gBAAY,cAAc,SAAS,2CAA2C;AAAA,MAC5E;AAAA,MACA;AAAA,MACA,OAAO,YAAY;AAAA,MACnB,eAAe,YAAY,SAAS,UAAU;AAAA,IAChD,CAAC;AAED,WAAO,cAAc,OAAO,gBAAgB,aAAa,CAAC,cAAc;AAEtE,UAAI,OAAO,QAAQ,WAAW;AAC5B,oBAAY,cAAc,SAAS,+BAA+B;AAAA,UAChE,OAAO,OAAO,QAAQ,UAAU;AAAA,UAChC;AAAA,QACF,CAAC;AAAA,MACH;AAEA,UAAI,SAAU,UAAS,SAAS;AAGhC,UAAI;AACF,cAAM,UAAU,cAAc,SAAY,YAAY;AACtD,YAAI,OAAO,YAAY,YAAY,UAAU,GAAG;AAC9C,qBAAW,MAAM;AACf,mBAAO,cAAc,MAAM,aAAa,gBAAgB,MAAM;AAAA,YAAC,CAAC;AAAA,UAClE,GAAG,OAAO;AAAA,QACZ;AAAA,MACF,SAASC,QAAO;AACd,oBAAY,cAAc,SAAS,sCAAsC;AAAA,UACvE,OAAQA,OAAgB;AAAA,QAC1B,GAAGA,MAAc;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AAgDO,WAAS,4BAA4B,WAAwE;AAClH,UAAM,QAAQ;AACd,UAAM,UAAU,sCAAsC,UAAU,IAAI,MAAM,UAAU,UAAU,EAAE,GAAG,KAAK;AAExG;AAAA,MACE;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA,QACT;AAAA,QACA;AAAA,QACA,UAAU;AAAA,MACZ;AAAA,MACA,MAAM;AAAA,MAAC;AAAA,IACT;AAEA,QAAI;AACF,aAAO,OAAO,wBAAwB,EAAE,OAAO,UAAU,CAAC;AAC1D,aAAO,OAAO,aAAa,EAAE,MAAM,MAAM,CAAC;AAAA,IAC5C,QAAQ;AAAA,IAER;AAAA,EACF;AAKO,WAAS,kBAAwB;AACtC,QAAI;AACF,aAAO,OAAO,aAAa,EAAE,MAAM,GAAG,CAAC;AAAA,IACzC,QAAQ;AAAA,IAER;AAAA,EACF;;;AC3GA,MAAM,WAAN,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA,IAKL,YAAY,oBAAI,IAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAenD,GAAG,OAAe,UAA0B;AAC1C,UAAI,CAAC,KAAK,UAAU,IAAI,KAAK,GAAG;AAC9B,aAAK,UAAU,IAAI,OAAO,oBAAI,IAAI,CAAC;AAAA,MACrC;AACA,WAAK,UAAU,IAAI,KAAK,EAAG,IAAI,QAAQ;AAAA,IACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAeA,IAAI,OAAe,UAA0B;AAC3C,YAAM,iBAAiB,KAAK,UAAU,IAAI,KAAK;AAC/C,UAAI,gBAAgB;AAClB,uBAAe,OAAO,QAAQ;AAE9B,YAAI,eAAe,SAAS,GAAG;AAC7B,eAAK,UAAU,OAAO,KAAK;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,KAAK,OAAe,MAAkB;AACpC,YAAM,iBAAiB,KAAK,UAAU,IAAI,KAAK;AAC/C,UAAI,gBAAgB;AAElB,uBAAe,QAAQ,cAAY;AACjC,cAAI;AACF,qBAAS,IAAI;AAAA,UACf,SAASC,QAAO;AAEd,oBAAQ,MAAM,gCAAgC,KAAK,MAAMA,MAAK;AAAA,UAChE;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBA,KAAK,OAAe,UAA0B;AAC5C,YAAM,cAAc,CAAC,SAAe;AAClC,iBAAS,IAAI;AACb,aAAK,IAAI,OAAO,WAAW;AAAA,MAC7B;AACA,WAAK,GAAG,OAAO,WAAW;AAAA,IAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAiBA,mBAAmB,OAAsB;AACvC,UAAI,OAAO;AACT,aAAK,UAAU,OAAO,KAAK;AAAA,MAC7B,OAAO;AACL,aAAK,UAAU,MAAM;AAAA,MACvB;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcA,cAAc,OAAuB;AACnC,YAAM,iBAAiB,KAAK,UAAU,IAAI,KAAK;AAC/C,aAAO,iBAAiB,eAAe,OAAO;AAAA,IAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAaA,aAAuB;AACrB,aAAO,MAAM,KAAK,KAAK,UAAU,KAAK,CAAC;AAAA,IACzC;AAAA,EACF;AAqBO,MAAM,iBAAiB,IAAI,SAAS;;;ACnLpC,MAAM,kBAAN,MAAsB;AAAA,IAK3B,YACU,cACAC,YACR;AAFQ;AACA,uBAAAA;AAAA,IACP;AAAA,IAPK,SAA2B;AAAA,IAC3B,oBAAoB;AAAA,IACpB,mBAAyD;AAAA;AAAA;AAAA;AAAA,IAUjE,YAA8B;AAC5B,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA,IAKA,gBAA+B;AAC7B,aAAO,KAAK,SAAS,KAAK,OAAO,aAAa;AAAA,IAChD;AAAA;AAAA;AAAA;AAAA,IAKA,cAAuB;AACrB,aACE,KAAK,WAAW,QAAQ,KAAK,OAAO;AAAA,IAExC;AAAA;AAAA;AAAA;AAAA,IAKA,UAAgB;AACd,UAAI;AACF,cAAMC,UAAS,KAAK,UAAU;AAC9B,YAAI,CAACA,SAAQ;AACX,sBAAY,UAAU,QAAQ,wCAAwC;AACtE;AAAA,QACF;AAGA,YAAI,KAAK,UAAU,KAAK,OAAO,6BAAoC;AACjE,sBAAY,UAAU,SAAS,wBAAwB;AACvD;AAAA,QACF;AAGA,cAAM,MAAM,KAAK,eAAeA;AAGhC,oBAAY,UAAU,QAAQ,oCAAoC;AAAA,UAChE,SAAS,KAAK;AAAA,UACd,cAAcA,QAAO;AAAA,UACrB,cAAcA,QAAO,UAAU,GAAG,CAAC,IAAI;AAAA,UACvC,gBAAgB,IAAI;AAAA,UACpB,YAAY,KAAK,eAAe;AAAA,QAClC,CAAC;AACD,oBAAY,UAAU,QAAQ,2BAA2B;AAAA,UACvD,KAAK,KAAK,eAAe;AAAA,UACzB,mBAAmB,KAAK;AAAA,UACxB,oBAAoB,KAAK,SACrB,KAAK,OAAO,aACZ;AAAA,UACJ,eAAe,CAAC,CAACA;AAAA,QACnB,CAAC;AACD,aAAK,oBAAoB;AAGzB,oBAAY,UAAU,SAAS,oCAAoC;AAAA,UACjE,KAAK,KAAK,eAAe;AAAA,UACzB,qBAAqB,CAAC,CAAC,KAAK;AAAA,UAC5B,oBAAoB,KAAK,SAAS,KAAK,OAAO,aAAa;AAAA,QAC7D,CAAC;AAED,YAAI;AACF,eAAK,SAAS,IAAI,UAAU,GAAG;AAC/B,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,cACE,KAAK,KAAK,eAAe;AAAA,cACzB,YAAY,KAAK,OAAO;AAAA,cACxB,WAAW,IAAI;AAAA,YACjB;AAAA,UACF;AAAA,QACF,SAAS,aAAa;AACpB,sBAAY,UAAU,SAAS,qCAAqC;AAAA,YAClE,KAAK,KAAK,eAAe;AAAA,YACzB,OACE,uBAAuB,QACnB,YAAY,UACZ,OAAO,WAAW;AAAA,YACxB,WAAW,aAAa,aAAa;AAAA,YACrC,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACpC,CAAC;AAED,eAAK,SAAS;AACd,gBAAM;AAAA,QACR;AAEA,oBAAY,UAAU,SAAS,uCAAuC;AAAA,UACpE,KAAK,KAAK,eAAe;AAAA,UACzB,YAAY,KAAK,OAAO;AAAA,UACxB,cAAc,CAAC,CAAC,KAAK;AAAA,QACvB,CAAC;AAED,aAAK,OAAO,SAAS,MAAM;AACzB,sBAAY,UAAU,QAAQ,oCAAoC;AAAA,YAChE,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACpC,CAAC;AACD,6BAAmB,0BAA0B,IAAI;AACjD,yBAAe,gBAAgB;AAG/B,yBAAe,KAAK,wBAAwB;AAE5C,cAAI;AACF,4BAAgB;AAAA,UAClB,QAAQ;AAAA,UAER;AAEA,iBAAO,OAAO,MAAM,sBAAsB,MAAM;AAAA,UAAC,CAAC;AAElD,cAAI,KAAK,kBAAkB;AACzB,yBAAa,KAAK,gBAAgB;AAClC,iBAAK,mBAAmB;AAAA,UAC1B;AAGA,yBAAe,KAAK,qBAAqB;AAGzC,yBAAe,KAAK,mBAAmB,WAAW;AAAA,QACpD;AAEA,aAAK,OAAO,YAAY,OAAO,UAAU;AACvC,cAAI;AACF,kBAAM,OAAyB,KAAK,MAAM,MAAM,IAAI;AACpD,wBAAY,UAAU,SAAS,8BAA8B;AAAA,cAC3D,MAAM,KAAK;AAAA,cACX,SAAS,aAAa,OAAO,KAAK,UAAU;AAAA,cAC5C,SAAS,UAAU,OAAO,CAAC,CAAC,KAAK,OAAO;AAAA,YAC1C,CAAC;AAED,oBAAQ,KAAK,MAAM;AAAA,cACnB,KAAK;AACH,oBAAI,KAAK,YAAY,QAAQ;AAE3B,iCAAe,KAAK,uBAAuB;AAAA,gBAC7C,WAAW,KAAK,YAAY,UAAU;AAEpC,iCAAe,KAAK,yBAAyB;AAAA,gBAC/C;AACA;AAAA,cAEF,KAAK;AACH,oBAAI,UAAU,QAAQ,KAAK,MAAM;AAE/B,iCAAe,KAAK,kBAAkB,KAAK,IAAI;AAAA,gBACjD,OAAO;AACL,8BAAY;AAAA,oBACV;AAAA,oBACA;AAAA,kBACF;AAAA,gBACF;AACA;AAAA,cAEF,KAAK;AACH,4BAAY;AAAA,kBACV;AAAA,kBACA;AAAA,kBACA;AAAA,oBACE,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,kBACpC;AAAA,gBACF;AACA;AAAA;AAAA;AAAA,cAKF;AACE,4BAAY;AAAA,kBACV;AAAA,kBACA;AAAA,kBACA;AAAA,oBACE,MAAO,KAAa;AAAA,kBACtB;AAAA,gBACF;AACA;AAAA,YACF;AAAA,UACF,SAASC,QAAO;AACd,wBAAY;AAAA,cACV;AAAA,cACA;AAAA,cACA;AAAA,cACAA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,aAAK,OAAO,UAAU,CAACA,WAAU;AAK/B,gBAAM,gBAAgB,KAAK;AAC3B,gBAAM,eAAe,CAAC,CAAC;AACvB,gBAAM,cAAc,eAChB,cAAc,aACd;AACJ,gBAAM,eAAe,eACjB,cAAc,oCACd;AACJ,gBAAM,cAAc,eAChB,cAAc,8BACd;AAEJ,gBAAM,YAAY;AAAA,YAChB,MAAOA,OAAc,QAAQ;AAAA,YAC7B,QAASA,OAAc,SAAS,cAAc;AAAA,YAC9C,YAAY;AAAA,YACZ;AAAA,YACA,KAAK,KAAK;AAAA,YACV,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,YAClC,mBAAmB,KAAK;AAAA;AAAA,YAExB;AAAA,YACA;AAAA,YACA,mBAAmB;AAAA,cACjB,WAAYA,OAAc;AAAA,cAC1B,SAAUA,OAAc;AAAA,cACxB,YAAaA,OAAc;AAAA,cAC3B,eAAgBA,OAAc,gBAC1B,cACA;AAAA,YACN;AAAA,UACF;AAEA,sBAAY,UAAU,SAAS,4BAA4B,SAAS;AAGpE,gBAAM,iBAAiB,IAAI;AAAA,YACzB,+BAA+B,UAAU,IAAI,aAAa,eAAe,WAAW,MAAM,YAAY,WAAW;AAAA,UACnH;AACA,yBAAe,OAAO;AACtB,6BAAmB;AAAA,YACjB;AAAA,YACA;AAAA,cACE,UAAU;AAAA,cACV,SAAS;AAAA,cACT,MAAM;AAAA,YACR;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAEA,aAAK,OAAO,UAAU,CAAC,UAAU;AAC/B,gBAAM,YAAuB;AAAA,YAC3B,MAAM,MAAM;AAAA,YACZ,QAAQ,MAAM,UAAU;AAAA,YACxB,UAAU,MAAM;AAAA,UAClB;AAEA,sBAAY,UAAU,QAAQ,+BAA+B;AAAA,YAC3D,GAAG;AAAA,YACH,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,YAClC,mBAAmB,KAAK;AAAA,UAC1B,CAAC;AAGD,yBAAe,KAAK,0BAA0B;AAAA,YAC5C,MAAM,MAAM;AAAA,YACZ,QAAQ,MAAM;AAAA,YACd,UAAU,MAAM;AAAA,UAClB,CAAC;AAGD,yBAAe,KAAK,mBAAmB,cAAc;AAGrD,cACE,MAAM,SAAS,QACf,MAAM,SAAS,QACd,MAAM,QAAQ,OAAQ,MAAM,OAAO,KACpC;AACA,wBAAY;AAAA,cACV;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,gBAAI;AACF,0CAA4B,SAAS;AAAA,YACvC,QAAQ;AAAA,YAER;AACA;AAAA,UACF;AAGA,eAAK;AACL,6BAAmB,4BAA4B;AAE/C,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,cACE,SAAS,KAAK;AAAA,cACd,eAAe,IAAI,KAAK,KAAK,IAAI,IAAI,GAAK,EAAE,YAAY;AAAA,YAC1D;AAAA,UACF;AAEA,iBAAO,OAAO,OAAO,sBAAsB;AAAA,YACzC,MAAM,KAAK,IAAI,IAAI;AAAA,UACrB,CAAC;AAAA,QACH;AAAA,MACF,SAASA,QAAO;AACd,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,YACE,KAAK,KAAK,eAAe;AAAA,YACzB,WAAW,CAAC,CAAC,KAAK,UAAU;AAAA,UAC9B;AAAA,UACAA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,aAAmB;AACjB,UAAI,KAAK,QAAQ;AACf,YAAI;AACF,sBAAY,UAAU,QAAQ,2BAA2B;AAAA,YACvD,YAAY,KAAK,OAAO;AAAA,UAC1B,CAAC;AAED,eAAK,OAAO,MAAM;AAClB,eAAK,SAAS;AAEd,yBAAe,eAAe;AAAA,QAChC,SAASA,QAAO;AACd,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,YACAA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,uBAA+B;AAC7B,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA,IAKA,yBAA+B;AAC7B,WAAK,oBAAoB;AAAA,IAC3B;AAAA,EACF;;;ACjZA,MAAM,eAAe;AACrB,MAAM,aAAa,GAAG,YAAY;AAClC,MAAM,cAAc,GAAG,YAAY;AACnC,MAAM,gBAAgB,GAAG,YAAY;AAIrC,WAAS,YAAYC,SAA6B;AAChD,WAAO,EAAE,gBAAgBA,QAAO;AAAA,EAClC;AAEA,iBAAsB,cAAcA,SAA+B;AACjE,UAAM,YAAY,KAAK,IAAI;AAC3B,gBAAY,IAAI,QAAQ,sBAAsB,EAAE,KAAK,eAAe,WAAW,CAAC,CAACA,SAAQ,YAAW,oBAAI,KAAK,GAAE,YAAY,EAAE,CAAC;AAE9H,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,eAAe,EAAE,SAAS,YAAYA,OAAM,EAAE,CAAC;AAC5E,YAAM,WAAW,KAAK,IAAI,IAAI;AAE9B,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,eAAe;AACnE,cAAMC,SAAQ,IAAI,MAAM,8BAA8B,SAAS,MAAM,IAAI,SAAS,UAAU,MAAM,SAAS,EAAE;AAC7G,oBAAY,IAAI,SAAS,0BAA0B;AAAA,UACjD,KAAK;AAAA,UACL,QAAQ,SAAS;AAAA,UACjB,YAAY,SAAS;AAAA,UACrB,UAAU,GAAG,QAAQ;AAAA,UACrB;AAAA,QACF,GAAGA,MAAK;AACR,cAAMA;AAAA,MACR;AAEA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,kBAAY,IAAI,QAAQ,kCAAkC;AAAA,QACxD,KAAK;AAAA,QACL,QAAQ,SAAS;AAAA,QACjB,UAAU,GAAG,QAAQ;AAAA,QACrB,WAAW,KAAK,QAAQ,KAAK,MAAM,UAAU,GAAG,CAAC,IAAI,QAAQ;AAAA,QAC7D,UAAU,KAAK,QAAQ;AAAA,MACzB,CAAC;AACD,aAAO;AAAA,IACT,SAASA,QAAO;AACd,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,kBAAY,IAAI,SAAS,yBAAyB;AAAA,QAChD,KAAK;AAAA,QACL,UAAU,GAAG,QAAQ;AAAA,QACrB,OAAQA,OAAgB;AAAA,MAC1B,GAAGA,MAAc;AACjB,YAAMA;AAAA,IACR;AAAA,EACF;AAEA,iBAAsB,aAAaD,SAAmC;AACpE,UAAM,YAAY,KAAK,IAAI;AAC3B,gBAAY,IAAI,QAAQ,oBAAoB,EAAE,KAAK,aAAa,WAAW,CAAC,CAACA,SAAQ,YAAW,oBAAI,KAAK,GAAE,YAAY,EAAE,CAAC;AAE1H,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,aAAa,EAAE,SAAS,YAAYA,OAAM,EAAE,CAAC;AAC1E,YAAM,WAAW,KAAK,IAAI,IAAI;AAE9B,UAAI,CAAC,SAAS,IAAI;AAChB,cAAMC,SAAQ,IAAI,MAAM,4BAA4B,SAAS,MAAM,IAAI,SAAS,UAAU,EAAE;AAC5F,oBAAY,IAAI,SAAS,wBAAwB;AAAA,UAC/C,KAAK;AAAA,UACL,QAAQ,SAAS;AAAA,UACjB,YAAY,SAAS;AAAA,UACrB,UAAU,GAAG,QAAQ;AAAA,QACvB,GAAGA,MAAK;AACR,cAAMA;AAAA,MACR;AAEA,YAAM,OAAwB,MAAM,SAAS,KAAK;AAClD,YAAM,gBAAgB,KAAK,QAAQ,OAAO,YAAU,OAAO,MAAM;AACjE,kBAAY,IAAI,QAAQ,gCAAgC;AAAA,QACtD,KAAK;AAAA,QACL,QAAQ,SAAS;AAAA,QACjB,UAAU,GAAG,QAAQ;AAAA,QACrB,cAAc,KAAK,QAAQ;AAAA,QAC3B,eAAe,cAAc;AAAA,MAC/B,CAAC;AACD,aAAO;AAAA,IACT,SAASA,QAAO;AACd,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,kBAAY,IAAI,SAAS,uBAAuB;AAAA,QAC9C,KAAK;AAAA,QACL,UAAU,GAAG,QAAQ;AAAA,QACrB,OAAQA,OAAgB;AAAA,MAC1B,GAAGA,MAAc;AACjB,YAAMA;AAAA,IACR;AAAA,EACF;AAEA,iBAAsB,kBAAkBD,SAAiC;AACvE,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,MAAM,GAAG,UAAU;AACzB,gBAAY,IAAI,QAAQ,0BAA0B,EAAE,KAAK,WAAW,CAAC,CAACA,SAAQ,YAAW,oBAAI,KAAK,GAAE,YAAY,EAAE,CAAC;AAEnH,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK,EAAE,SAAS,YAAYA,OAAM,EAAE,CAAC;AAClE,YAAM,WAAW,KAAK,IAAI,IAAI;AAE9B,UAAI,CAAC,SAAS,IAAI;AAChB,cAAMC,SAAQ,IAAI,MAAM,2BAA2B,SAAS,MAAM,IAAI,SAAS,UAAU,EAAE;AAC3F,oBAAY,IAAI,SAAS,uBAAuB;AAAA,UAC9C;AAAA,UACA,QAAQ,SAAS;AAAA,UACjB,YAAY,SAAS;AAAA,UACrB,UAAU,GAAG,QAAQ;AAAA,QACvB,GAAGA,MAAK;AACR,cAAMA;AAAA,MACR;AAEA,YAAM,OAAuB,MAAM,SAAS,KAAK;AACjD,YAAM,iBAAiB,KAAK,OAAO,OAAO,UAAQ;AAChD,cAAM,aACH,WAAW,QAAQ,KAAK,SACxB,UAAU,QAAQ,KAAK,QACvB,SAAS,QAAQ,KAAK,OACtB,eAAe,QAAQ,KAAK,aAC5B,cAAc,QAAQ,KAAK;AAC9B,eAAO,cAAc,CAAC,KAAK;AAAA,MAC7B,CAAC;AACD,kBAAY,IAAI,QAAQ,+BAA+B;AAAA,QACrD;AAAA,QACA,QAAQ,SAAS;AAAA,QACjB,UAAU,GAAG,QAAQ;AAAA,QACrB,aAAa,KAAK,OAAO;AAAA,QACzB,gBAAgB,eAAe;AAAA,QAC/B,WAAW,eAAe,IAAI,OAAK,EAAE,IAAI,EAAE,KAAK,IAAI;AAAA,MACtD,CAAC;AACD,aAAO;AAAA,IACT,SAASA,QAAO;AACd,YAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,kBAAY,IAAI,SAAS,sBAAsB;AAAA,QAC7C;AAAA,QACA,UAAU,GAAG,QAAQ;AAAA,QACrB,OAAQA,OAAgB;AAAA,MAC1B,GAAGA,MAAc;AACjB,YAAMA;AAAA,IACR;AAAA,EACF;AAEA,iBAAsB,eACpBD,SACAE,aACAC,iBACuD;AACvD,gBAAY,QAAQ,QAAQ,wCAAwC;AAAA,MAClE,WAAW,CAAC,CAACH;AAAA,MACb,mBAAmBE;AAAA,MACnB,gBAAAC;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAGD,UAAM,SAAS,MAAM,IAAI,QAAoD,aAAW;AACtF,aAAO,QAAQ,MAAM,IAAI,CAAC,8BAA8B,GAAG,CAAC,UAAU,QAAQ,KAAY,CAAC;AAAA,IAC7F,CAAC;AAED,QAAI,OAAO,8BAA8B;AACvC,kBAAY,QAAQ,QAAQ,kEAAkE;AAC9F,aAAO,IAAI,QAAQ,aAAW;AAC5B,cAAM,WAAW,CAAC,YAA6D;AAC7E,cAAI,QAAQ,gCAAgC,CAAC,QAAQ,6BAA6B,UAAU;AAC1F,mBAAO,QAAQ,UAAU,eAAe,QAAQ;AAChD,wBAAY,QAAQ,QAAQ,kDAAkD;AAC9E,oBAAQ,EAAE,YAAYD,eAAc,IAAI,aAAa,MAAM,CAAC;AAAA,UAC9D;AAAA,QACF;AACA,eAAO,QAAQ,UAAU,YAAY,QAAQ;AAAA,MAC/C,CAAC;AAAA,IACH;AAEA,QAAI;AACF,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,8BAA8B,KAAK,CAAC;AAGrE,YAAM,gBAAgB,MAAM,IAAI,QAAiC,aAAW;AAC1E,eAAO,QAAQ,MAAM,IAAI,CAAC,YAAY,GAAG,CAAC,UAAU,QAAQ,KAAY,CAAC;AAAA,MAC3E,CAAC;AAED,UAAI,cAAc,YAAY;AAC5B,cAAM,eAAe,cAAc;AACnC,oBAAY,QAAQ,QAAQ,6BAA6B,EAAE,YAAY,cAAc,gBAAAC,gBAAe,CAAC;AAErG,YAAI;AACF,gBAAM,qBAAqBH,SAAQ,cAAcG,eAAc;AAC/D,gBAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,8BAA8B,MAAM,CAAC;AACtE,iBAAO,EAAE,YAAY,cAAc,aAAa,MAAM;AAAA,QACxD,SAASF,QAAO;AACd,sBAAY,QAAQ,QAAQ,sDAAsD;AAAA,YAChF,OAAQA,OAAgB;AAAA,YACxB,YAAY;AAAA,UACd,CAAC;AACD,gBAAM,OAAO,QAAQ,MAAM,OAAO,CAAC,YAAY,CAAC;AAAA,QAClD;AAAA,MACF;AAGA,kBAAY,QAAQ,QAAQ,8CAA8C,EAAE,gBAAAE,iBAAgB,KAAK,YAAY,CAAC;AAE9G,YAAM,mBAAmB;AAAA,QACvB,UAAUA;AAAA,QACV,OAAO;AAAA,QACP,cAAc;AAAA,QACd,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR;AAEA,kBAAY,IAAI,QAAQ,uCAAuC;AAAA,QAC7D,KAAK;AAAA,QACL,QAAQ;AAAA,QACR,YAAY;AAAA,MACd,CAAC;AAED,YAAM,YAAY,KAAK,IAAI;AAC3B,YAAM,WAAW,MAAM,MAAM,aAAa;AAAA,QACxC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,GAAG,YAAYH,OAAM;AAAA,UACrB,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU,gBAAgB;AAAA,MACvC,CAAC;AAED,YAAM,WAAW,KAAK,IAAI,IAAI;AAE9B,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,eAAe;AACnE,cAAMC,SAAQ,IAAI,MAAM,8BAA8B,SAAS,MAAM,IAAI,SAAS,UAAU,MAAM,SAAS,EAAE;AAC7G,oBAAY,IAAI,SAAS,8BAA8B;AAAA,UACrD,KAAK;AAAA,UACL,QAAQ,SAAS;AAAA,UACjB,YAAY,SAAS;AAAA,UACrB,UAAU,GAAG,QAAQ;AAAA,UACrB;AAAA,QACF,GAAGA,MAAK;AACR,cAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,8BAA8B,MAAM,CAAC;AACtE,cAAMA;AAAA,MACR;AAEA,YAAM,SAAiB,MAAM,SAAS,KAAK;AAC3C,YAAM,gBAAgB,OAAO;AAE7B,kBAAY,IAAI,QAAQ,kCAAkC;AAAA,QACxD,KAAK;AAAA,QACL,QAAQ,SAAS;AAAA,QACjB,UAAU,GAAG,QAAQ;AAAA,QACrB,YAAY;AAAA,QACZ,gBAAgB,OAAO;AAAA,MACzB,CAAC;AAGD,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,YAAY,cAAc,CAAQ;AACnE,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,8BAA8B,MAAM,CAAQ;AAE7E,kBAAY,QAAQ,QAAQ,iCAAiC;AAAA,QAC3D,YAAY;AAAA,QACZ,gBAAgB,OAAO;AAAA,MACzB,CAAC;AAED,aAAO,EAAE,YAAY,eAAe,aAAa,MAAM;AAAA,IACzD,SAASA,QAAO;AACd,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,8BAA8B,MAAM,CAAC;AACtE,kBAAY,QAAQ,SAAS,oCAAoC;AAAA,QAC/D,cAAeA,OAAgB;AAAA,QAC/B,YAAaA,OAAgB;AAAA,MAC/B,CAAC;AACD,YAAMA;AAAA,IACR;AAAA,EACF;AAEA,iBAAsB,qBACpBD,SACAE,aACA,aACe;AACf,gBAAY,QAAQ,QAAQ,4BAA4B;AAAA,MACtD,YAAAA;AAAA,MACA;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAED,QAAI;AACF,YAAM,MAAM,GAAG,WAAW,IAAIA,WAAU;AACxC,YAAM,YAAY,KAAK,IAAI;AAE3B,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,GAAG,YAAYF,OAAM;AAAA,UACrB,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,UAAU,YAAY,CAAC;AAAA,MAChD,CAAC;AAED,YAAM,WAAW,KAAK,IAAI,IAAI;AAE9B,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,eAAe;AACnE,cAAMC,SAAQ,IAAI,MAAM,qCAAqC,SAAS,MAAM,IAAI,SAAS,UAAU,MAAM,SAAS,EAAE;AACpH,oBAAY,IAAI,SAAS,iCAAiC;AAAA,UACxD;AAAA,UACA,QAAQ,SAAS;AAAA,UACjB,YAAY,SAAS;AAAA,UACrB,UAAU,GAAG,QAAQ;AAAA,UACrB;AAAA,QACF,GAAGA,MAAK;AACR,cAAMA;AAAA,MACR;AAEA,YAAM,SAAiB,MAAM,SAAS,KAAK;AAC3C,kBAAY,IAAI,QAAQ,wCAAwC;AAAA,QAC9D;AAAA,QACA,QAAQ,SAAS;AAAA,QACjB,UAAU,GAAG,QAAQ;AAAA,QACrB,YAAAC;AAAA,QACA,aAAa,OAAO;AAAA,MACtB,CAAC;AAAA,IACH,SAASD,QAAO;AACd,kBAAY,QAAQ,SAAS,0CAA0C;AAAA,QACrE,cAAeA,OAAgB;AAAA,QAC/B,YAAaA,OAAgB;AAAA,MAC/B,CAAC;AACD,YAAMA;AAAA,IACR;AAAA,EACF;;;ACjRO,MAAM,0BAAN,MAA2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMhE,MAAM,YAAoC;AACxC,YAAM,SAAS,MAAM,OAAO,QAAQ,MAAM,IAAI,CAAC,QAAQ,CAAC;AACxD,aAAO,OAAO,UAAU;AAAA,IAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,MAAM,UAAU,KAAmC;AACjD,UAAI,QAAQ,MAAM;AAChB,cAAM,OAAO,QAAQ,MAAM,OAAO,CAAC,QAAQ,CAAC;AAAA,MAC9C,OAAO;AACL,cAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,QAAQ,IAAI,CAAC;AAAA,MAChD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,gBAAwC;AAC5C,YAAM,SAAS,MAAM,OAAO,QAAQ,MAAM,IAAI,CAAC,YAAY,CAAC;AAC5D,aAAO,OAAO,cAAc;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,cAAc,MAAoC;AACtD,UAAI,SAAS,MAAM;AACjB,cAAM,OAAO,QAAQ,MAAM,OAAO,CAAC,YAAY,CAAC;AAAA,MAClD,OAAO;AACL,cAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,YAAY,KAAK,CAAC;AAAA,MACrD;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,oBAA4C;AAChD,YAAM,SAAS,MAAM,OAAO,QAAQ,KAAK,IAAI,CAAC,gBAAgB,CAAC;AAC/D,aAAO,OAAO,kBAAkB;AAAA,IAClC;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,kBAAkB,UAAiC;AACvD,YAAM,OAAO,QAAQ,KAAK,IAAI,EAAE,gBAAgB,SAAS,CAAC;AAAA,IAC5D;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,mBAAqC;AACzC,YAAM,SAAS,MAAM,OAAO,QAAQ,KAAK,IAAI,CAAC,eAAe,CAAC;AAC9D,aAAO,OAAO,kBAAkB,SAAY,OAAO,gBAAgB;AAAA,IACrE;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,iBAAiB,SAAiC;AACtD,YAAM,OAAO,QAAQ,KAAK,IAAI,EAAE,eAAe,QAAQ,CAAC;AAAA,IAC1D;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,yBAA0C;AAC9C,YAAM,SAAS,MAAM,OAAO,QAAQ,KAAK,IAAI,CAAC,qBAAqB,CAAC;AACpE,aAAO,OAAO,wBAAwB,SAAY,OAAO,sBAAsB;AAAA,IACjF;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,uBAAuB,SAAgC;AAC3D,YAAM,OAAO,QAAQ,KAAK,IAAI,EAAE,qBAAqB,QAAQ,CAAC;AAAA,IAChE;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,wBAAgD;AACpD,YAAM,SAAS,MAAM,OAAO,QAAQ,MAAM,IAAI,CAAC,oBAAoB,CAAC;AACpE,aAAO,OAAO,sBAAsB;AAAA,IACtC;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,sBAAsB,UAAwC;AAClE,UAAI,aAAa,MAAM;AACrB,cAAM,OAAO,QAAQ,MAAM,OAAO,CAAC,oBAAoB,CAAC;AAAA,MAC1D,OAAO;AACL,cAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,oBAAoB,SAAS,CAAC;AAAA,MACjE;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,0BAA4C;AAChD,YAAM,SAAS,MAAM,OAAO,QAAQ,MAAM,IAAI,CAAC,sBAAsB,CAAC;AACtE,aAAO,OAAO,wBAAwB;AAAA,IACxC;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,wBAAwB,QAAgC;AAC5D,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,sBAAsB,OAAO,CAAC;AAAA,IACjE;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,6BAA4C;AAChD,YAAM,OAAO,QAAQ,MAAM,OAAO,CAAC,sBAAsB,CAAC;AAAA,IAC5D;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,QAAuB;AAC3B,YAAM,QAAQ,IAAI;AAAA,QAChB,OAAO,QAAQ,KAAK,MAAM;AAAA,QAC1B,OAAO,QAAQ,MAAM,MAAM;AAAA,MAC7B,CAAC;AAAA,IACH;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,MAAM,OAAO,MAA+B;AAC1C,YAAM,QAAQ,IAAI;AAAA,QAChB,OAAO,QAAQ,KAAK,OAAO,IAAI;AAAA,QAC/B,OAAO,QAAQ,MAAM,OAAO,IAAI;AAAA,MAClC,CAAC;AAAA,IACH;AAAA,EACF;AAMO,MAAM,oBAAoB,IAAI,wBAAwB;;;AC3MtD,MAAM,eAA6B;AAAA,IACxC,UAAU;AAAA,IACV,SAAS,CAAC;AAAA,IACV,cAAc,CAAC;AAAA,IACf,iBAAiB;AAAA,IACjB,aAAa;AAAA,IACb,eAAe;AAAA,IACf,gBAAgB;AAAA,EAClB;AAGO,MAAM,sBAA2C;AAAA,IACtD,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,OAAO;AAAA,IACP,WAAW;AAAA,EACb;AAIA,MAAI,cAA6C;AAajD,iBAAsB,uBACpB,SAAS,WACT,oBACA,cAOwB;AAGxB,QAAI,oBAAoB,cAAc,aAAa;AACjD,kBAAY;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,UACE;AAAA,UACA,wBAAwB;AAAA,QAC1B;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,QAAI,oBAAoB,WAAW;AACjC,kBAAY,QAAQ,QAAQ,iCAAiC;AAAA,QAC3D;AAAA,QACA,mBAAmB,oBAAoB;AAAA,MACzC,CAAC;AACD,aAAO;AAAA,IACT;AAEA,wBAAoB,aAAa;AAGjC,mBAAe,YAAY;AACzB,UAAI;AACF,oBAAY,QAAQ,QAAQ,8BAA8B;AAAA,UACxD;AAAA,UACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QACpC,CAAC;AAGD,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,QACF;AAGA,cAAM,cAAc,MAAM,kBAAkB,UAAU;AACtD,cAAM,kBAAkB,MAAM,kBAAkB,cAAc;AAE9D,YAAI,cAAc;AAChB,uBAAa,UAAU,WAAW;AAClC,uBAAa,cAAc,eAAe;AAAA,QAC5C;AAGA,cAAM,qBAAqB,MAAM,kBAAkB,iBAAiB;AACpE,cAAM,2BACJ,MAAM,kBAAkB,uBAAuB;AACjD,cAAM,sBACH,MAAM,kBAAkB,kBAAkB,KAAM;AAEnD,YAAI,cAAc;AAChB,uBAAa,iBAAiB,kBAAkB;AAChD,uBAAa,uBAAuB,wBAAwB;AAC5D,uBAAa,kBAAkB,mBAAmB;AAAA,QACpD;AAEA,qBAAa,gBAAgB;AAC7B,qBAAa,iBAAiB;AAE9B,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,YACE,WAAW,CAAC,CAAC;AAAA,YACb,eAAe,CAAC,CAAC;AAAA,YACjB,eAAe;AAAA,YACf,gBAAgB;AAAA,YAChB,qBAAqB;AAAA,UACvB;AAAA,QACF;AAEA,oBAAY,QAAQ,SAAS,kBAAkB;AAAA,UAC7C,WAAW,CAAC,CAAC;AAAA,UACb,cAAc,cAAc,YAAY,SAAS;AAAA,QACnD,CAAC;AAED,YAAI,aAAa;AACf,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,UACF;AAGA,gBAAM,WAAW,MAAM,cAAc,WAAW;AAChD,uBAAa,WAAW;AAGxB,gBAAM,UAAU,MAAM,aAAa,WAAW;AAC9C,uBAAa,UAAU;AAGvB,gBAAM,SAAS,MAAM,kBAAkB,WAAW;AAClD,uBAAa,eAAe;AAG5B,uBAAa,kBAAkB;AAC/B,uBAAa,cAAc,KAAK,IAAI;AAEpC,sBAAY,QAAQ,QAAQ,wCAAwC;AAAA,YAClE,aAAa,CAAC,CAAC,aAAa;AAAA,YAC5B,aAAa,aAAa,QAAQ;AAAA,YAClC,WAAW,aAAa,aAAa;AAAA,YACrC,aAAa,IAAI,KAAK,aAAa,WAAW,EAAE,YAAY;AAAA,UAC9D,CAAC;AAGD,gBAAM,eAAe,aAAa,iBAAiB,mBAAmB;AAGtE,cAAI,oBAAoB;AACtB,wBAAY,QAAQ,QAAQ,4CAA4C;AACxE,+BAAmB;AAAA,UACrB;AAGA,iBAAO,OAAO,OAAO,wBAAwB,EAAE,iBAAiB,EAAE,CAAC;AACnE,sBAAY,QAAQ,SAAS,wCAAwC;AAAA,YACnE,UAAU;AAAA,UACZ,CAAC;AAAA,QACH,OAAO;AACL,sBAAY;AAAA,YACV;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAEA,4BAAoB,YAAY;AAChC,4BAAoB,YAAY,KAAK,IAAI;AACzC,oBAAY,QAAQ,QAAQ,yCAAyC;AAAA,UACnE;AAAA,UACA,WAAW,IAAI,KAAK,oBAAoB,SAAS,EAAE,YAAY;AAAA,QACjE,CAAC;AAED,eAAO;AAAA,MACT,SAASG,QAAO;AACd,4BAAoB,QAAQA;AAC5B,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,YACE,OACGA,OAAgB,WAChBA,OAAgB,QACjB;AAAA,UACJ;AAAA,UACAA;AAAA,QACF;AACA,qBAAa,kBAAkB;AAC/B,cAAMA;AAAA,MACR,UAAE;AACA,4BAAoB,aAAa;AAEjC,sBAAc;AAAA,MAChB;AAAA,IACF,GAAG;AAEH,WAAO;AAAA,EACT;AAEA,iBAAsB,oBAAoB,aAAoC;AAC5E,gBAAY,QAAQ,QAAQ,4BAA4B;AAAA,MACtD,WAAW,CAAC,CAAC;AAAA,MACb,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAED,QAAI;AACF,UAAI,aAAa;AACf,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,QACF;AAGA,oBAAY,QAAQ,SAAS,sBAAsB;AACnD,cAAM,WAAW,MAAM,cAAc,WAAW;AAChD,qBAAa,WAAW;AAGxB,oBAAY,QAAQ,SAAS,oBAAoB;AACjD,cAAM,UAAU,MAAM,aAAa,WAAW;AAC9C,qBAAa,UAAU;AAGvB,oBAAY,QAAQ,SAAS,0BAA0B;AACvD,cAAM,SAAS,MAAM,kBAAkB,WAAW;AAClD,qBAAa,eAAe;AAG5B,qBAAa,kBAAkB;AAC/B,qBAAa,cAAc,KAAK,IAAI;AAEpC,oBAAY,QAAQ,QAAQ,wCAAwC;AAAA,UAClE,aAAa,CAAC,CAAC,aAAa;AAAA,UAC5B,aAAa,aAAa,QAAQ;AAAA,UAClC,WAAW,aAAa,aAAa;AAAA,UACrC,aAAa,IAAI,KAAK,aAAa,WAAW,EAAE,YAAY;AAAA,QAC9D,CAAC;AAAA,MACH,OAAO;AACL,oBAAY;AAAA,UACV;AAAA,UACA;AAAA,QACF;AACA,qBAAa,kBAAkB;AAAA,MACjC;AAAA,IACF,SAASA,QAAO;AACd,kBAAY;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,UACE,OAAQA,OAAgB;AAAA,QAC1B;AAAA,QACAA;AAAA,MACF;AACA,YAAMA;AAAA,IACR;AAAA,EACF;;;ACjQA,iBAAsB,mBACpB,cAOA,cAOe;AACf,QAAI;AACF,UAAI,CAAC,gBAAgB,CAAC,cAAc;AAElC;AAAA,MACF;AAGA,YAAM,cAAc,CAAC,aAAa,UAAU;AAC5C,YAAM,kBAAkB,CAAC,aAAa,cAAc;AACpD,YAAM,gBAAgB,aAAa,kBAAkB,MAAM,QAAQ,aAAa,kBAAkB,MAAM;AACxG,YAAM,gBAAgB,aAAa,iBAAiB,MAAM,QAAQ,aAAa,iBAAiB,MAAM;AACtG,YAAM,eAAe,aAAa,uBAAuB,MAAM,QAAQ,aAAa,uBAAuB,MAAM;AAGjH,UAAI,aAAa;AACf,YAAI;AACF,gBAAMC,UAAS,MAAM,kBAAkB,UAAU;AACjD,cAAIA,SAAQ;AACV,yBAAa,UAAUA,OAAM;AAAA,UAC/B;AAAA,QACF,QAAQ;AAAA,QAER;AAAA,MACF;AAGA,UAAI,iBAAiB;AACnB,YAAI;AACF,gBAAMC,cAAa,MAAM,kBAAkB,cAAc;AACzD,cAAIA,aAAY;AACd,yBAAa,cAAcA,WAAU;AAAA,UACvC;AAAA,QACF,QAAQ;AAAA,QAER;AAAA,MACF;AAGA,UAAI,eAAe;AACjB,YAAI;AACF,gBAAMC,kBAAiB,MAAM,kBAAkB,kBAAkB;AACjE,cAAIA,oBAAmB,QAAQA,oBAAmB,QAAW;AAC3D,yBAAa,kBAAkBA,eAAc;AAAA,UAC/C;AAAA,QACF,QAAQ;AAAA,QAER;AAAA,MACF;AAGA,UAAI,eAAe;AACjB,YAAI;AACF,gBAAMC,iBAAgB,MAAM,kBAAkB,iBAAiB;AAC/D,cAAIA,mBAAkB,QAAQA,mBAAkB,QAAW;AACzD,yBAAa,iBAAiBA,cAAa;AAAA,UAC7C;AAAA,QACF,QAAQ;AAAA,QAER;AAAA,MACF;AAGA,UAAI,cAAc;AAChB,YAAI;AACF,gBAAMC,uBAAsB,MAAM,kBAAkB,uBAAuB;AAC3E,cAAIA,yBAAwB,QAAQA,yBAAwB,QAAW;AACrE,yBAAa,uBAAuBA,oBAAmB;AAAA,UACzD;AAAA,QACF,QAAQ;AAAA,QAER;AAAA,MACF;AAGA,UAAI;AACF,oBAAY,QAAQ,SAAS,gCAAgC;AAAA,UAC3D,WAAW,CAAC,CAAC,aAAa,UAAU;AAAA,UACpC,eAAe,CAAC,CAAC,aAAa,cAAc;AAAA,UAC5C,eAAe,aAAa,iBAAiB;AAAA,UAC7C,qBAAqB,aAAa,uBAAuB;AAAA,UACzD,gBAAgB,aAAa,kBAAkB;AAAA,QACjD,CAAC;AAAA,MACH,QAAQ;AAAA,MAER;AAAA,IACF,SAAS,GAAG;AACV,UAAI;AACF,oBAAY,QAAQ,QAAQ,2CAA2C;AAAA,UACrE,OAAO,KAAM,EAAY;AAAA,QAC3B,CAAC;AAAA,MACH,QAAQ;AAAA,MAER;AAAA,IACF;AAAA,EACF;;;ACpHO,MAAM,mBAAN,MAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO5B,aAAa,UAAU,UAAkB,UAAsC;AAE7E,UAAI,CAAC,WAAW,UAAU,CAAC,OAAO,QAAQ;AACxC,cAAM,IAAI,MAAM,0DAA0D;AAAA,MAC5E;AAGA,YAAM,UAAU,IAAI,YAAY;AAChC,YAAM,gBAAgB,QAAQ,OAAO,QAAQ;AAG7C,YAAM,cAAc,MAAM,OAAO,OAAO;AAAA,QACtC;AAAA,QACA;AAAA,QACA,EAAE,MAAM,SAAS;AAAA,QACjB;AAAA,QACA,CAAC,cAAc,WAAW;AAAA,MAC5B;AAGA,YAAM,OAAO,QAAQ,OAAO,QAAQ;AAGpC,YAAM,MAAM,MAAM,OAAO,OAAO;AAAA,QAC9B;AAAA,UACE,MAAM;AAAA,UACN;AAAA,UACA,YAAY;AAAA,UACZ,MAAM;AAAA,QACR;AAAA,QACA;AAAA,QACA,EAAE,MAAM,WAAW,QAAQ,IAAI;AAAA,QAC/B;AAAA,QACA,CAAC,SAAS;AAAA,MACZ;AAEA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,aAAa,eAAe,gBAAwB,KAAkC;AACpF,UAAI;AAEF,cAAM,gBAAgB,KAAK,cAAc,cAAc;AAIvD,cAAM,UAAU,cAAc,CAAC;AAE/B,YAAI,YAAY,IAAI;AAClB,gBAAM,IAAI,MAAM,mCAAmC,OAAO,EAAE;AAAA,QAC9D;AAEA,cAAM,MAAM,cAAc,MAAM,GAAG,EAAE;AACrC,cAAM,KAAK,cAAc,MAAM,IAAI,EAAE;AACrC,cAAM,aAAa,cAAc,MAAM,EAAE;AAGzC,cAAM,WAAW,IAAI,WAAW,WAAW,SAAS,IAAI,MAAM;AAC9D,iBAAS,IAAI,UAAU;AACvB,iBAAS,IAAI,KAAK,WAAW,MAAM;AAGnC,cAAM,YAAY,MAAM,OAAO,OAAO;AAAA,UACpC;AAAA,YACE,MAAM;AAAA,YACN;AAAA,YACA,WAAW;AAAA;AAAA,UACb;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAGA,cAAM,UAAU,IAAI,YAAY;AAChC,cAAM,gBAAgB,QAAQ,OAAO,SAAS;AAG9C,eAAO,KAAK,MAAM,aAAa;AAAA,MACjC,QAAQ;AAEN,gBAAQ,MAAM,8CAA8C;AAC5D,cAAM,IAAI,MAAM,4DAA4D;AAAA,MAC9E;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,OAAO,cAAc,QAA4B;AAC/C,YAAM,eAAe,KAAK,MAAM;AAChC,YAAM,QAAQ,IAAI,WAAW,aAAa,MAAM;AAChD,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAM,CAAC,IAAI,aAAa,WAAW,CAAC;AAAA,MACtC;AACA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASA,aAAa,YAAY,eAAqB,UAAkB,UAAiC;AAC/F,UAAI,CAAC,cAAc,aAAa,CAAC,cAAc,YAAY;AACzD,cAAM,IAAI,MAAM,uBAAuB;AAAA,MACzC;AAGA,YAAM,MAAM,MAAM,KAAK,UAAU,UAAU,QAAQ;AAGnD,YAAM,gBAAgB,MAAM,KAAK,eAAe,cAAc,YAAY,GAAG;AAG7E,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAI;AAAA,QACJ,WAAW;AAAA;AAAA,MACb;AAAA,IACF;AAAA,EACF;;;AC5IO,MAAMC,gBAAe;AACrB,MAAMC,cAAa,GAAGD,aAAY;AAClC,MAAME,eAAc,GAAGF,aAAY;AACnC,MAAMG,iBAAgB,GAAGH,aAAY;AACrC,MAAM,gBAAgB;AAG7B,MAAI,SAAwB;AAC5B,MAAI,aAA4B;AAChC,MAAI,iBAAiB;AACrB,MAAI,gBAAgB;AACpB,MAAI,sBAAsB;AAC1B,MAAI,kBAA0C;AAC9C,MAAI,cAAc;AAoBX,WAAS,YAA2B;AACzC,WAAO;AAAA,EACT;AAEO,WAAS,UAAU,KAA0B;AAClD,aAAS;AAAA,EACX;AAEO,WAAS,gBAA+B;AAC7C,WAAO;AAAA,EACT;AAEO,WAAS,cAAc,MAA2B;AACvD,iBAAa;AAAA,EACf;AAEO,WAAS,oBAA4B;AAC1C,WAAO;AAAA,EACT;AAEO,WAAS,kBAAkB,UAAwB;AACxD,qBAAiB;AAAA,EACnB;AAEO,WAAS,mBAA4B;AAC1C,WAAO;AAAA,EACT;AAEO,WAAS,iBAAiB,OAAsB;AACrD,oBAAgB;AAAA,EAClB;AAMO,WAAS,uBAAuB,SAAuB;AAC5D,0BAAsB;AAAA,EACxB;AAMO,WAAS,mBAAmB,QAAsC;AACvE,sBAAkB;AAAA,EACpB;AAEO,WAAS,gBAAyB;AACvC,WAAO;AAAA,EACT;AAEO,WAAS,eAAe,MAAqB;AAClD,kBAAc;AAAA,EAChB;;;ACxEA,MAAI,yBAAyB;AAoB7B,WAAS,aAAa,MAAsB;AAC1C,QAAI,CAAC,KAAM,QAAO;AAGlB,QAAI,YAAY,KAAK,QAAQ,YAAY,EAAE;AAG3C,gBAAY,UAAU,QAAQ,iBAAiB,EAAE;AACjD,gBAAY,UAAU,QAAQ,eAAe,EAAE;AAG/C,gBAAY,UAAU,KAAK,EAAE,UAAU,GAAG,GAAI;AAE9C,WAAO;AAAA,EACT;AAMA,WAAS,YAAY,KAAqB;AACxC,QAAI,CAAC,IAAK,QAAO;AAEjB,QAAI;AACF,YAAM,SAAS,IAAI,IAAI,GAAG;AAE1B,UAAI,OAAO,aAAa,WAAW,OAAO,aAAa,UAAU;AAC/D,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,QAAQ;AACN,kBAAY,QAAQ,QAAQ,wBAAwB,EAAE,IAAI,CAAC;AAC3D,aAAO;AAAA,IACT;AAAA,EACF;AAQA,WAAS,kBAAkB,WAA4B;AACrD,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AAEA,QAAI;AACF,YAAM,MAAM,IAAI,IAAI,SAAS;AAE7B,aAAO,IAAI,SAAS,SAAS,iBAAiB,KACvC,IAAI,aAAa,+BACjB,IAAI,aAAa,+BACjB,IAAI,aAAa,+BACjB,IAAI,aAAa;AAAA,IAC1B,QAAQ;AACN,kBAAY,QAAQ,QAAQ,wCAAwC,EAAE,KAAK,UAAU,CAAC;AACtF,aAAO;AAAA,IACT;AAAA,EACF;AAKO,WAAS,uBAAuB,kBAAgC;AACrE,QAAI;AACF,aAAO,OAAO,SAAS,EAAE,OAAO,iBAAiB,CAAC;AAClD,kBAAY,QAAQ,SAAS,6BAA6B,EAAE,iBAAiB,CAAC;AAAA,IAChF,SAASI,QAAO;AACd,kBAAY,QAAQ,SAAS,6BAA6B;AAAA,QACxD;AAAA,QACA,OAAQA,OAAgB;AAAA,MAC1B,CAAC;AAAA,IACH;AAAA,EACF;AAMO,WAAS,qBAAqB,QAAgC;AACnE,QAAI;AAEF,YAAM,YAAY,WAAW,cAAc,WACzC,WAAW,eAAe,WACxB;AAGJ,YAAM,aAAa,WAAW,cAAc;AAAA;AAAA,QAC1C,WAAW,eAAe;AAAA;AAAA,UACxB;AAAA;AAAA;AAEJ,aAAO,OAAO,aAAa,EAAE,MAAM,UAAU,CAAC;AAC9C,aAAO,OAAO,wBAAwB,EAAE,OAAO,WAAW,CAAC;AAE3D,kBAAY,QAAQ,SAAS,mCAAmC,EAAE,QAAQ,WAAW,WAAW,CAAC;AAAA,IACnG,QAAQ;AACN,kBAAY,QAAQ,SAAS,2BAA2B;AAAA,QACtD;AAAA,QACA,OAAQ,MAAgB;AAAA,MAC1B,CAAC;AAAA,IACH;AAAA,EACF;AAKA,iBAAsB,cAAcC,wBAA0D;AAI5F,UAAM,mBAAmB;AAEzB,UAAMC,UAAS,UAAU;AACzB,QAAI,CAACA,SAAQ;AACX,kBAAY,QAAQ,QAAQ,oCAAoC;AAChE;AAAA,IACF;AAEA,QAAI;AACF,kBAAY,QAAQ,SAAS,4BAA4B;AAGzD,YAAM,eAAe,IAAI,IAAI,aAAa,aAAa,IAAI,OAAK,EAAE,IAAI,CAAC;AAEvE,YAAM,SAAS,MAAM,kBAAkBA,OAAM;AAG7C,YAAM,YAAY,OAAO,OAAO,OAAK,CAAC,aAAa,IAAI,EAAE,IAAI,CAAC;AAE9D,kBAAY,QAAQ,QAAQ,iCAAiC;AAAA,QAC3D,aAAa,OAAO;AAAA,QACpB,WAAW,UAAU;AAAA,MACvB,CAAC;AAGD,mBAAa,eAAe;AAC5B,mBAAa,cAAc,KAAK,IAAI;AAGpC,iBAAW,QAAQ,WAAW;AAC5B,oBAAY,QAAQ,QAAQ,iDAAiD;AAAA,UAC3E,UAAU,KAAK;AAAA,UACf,UAAU,KAAK;AAAA,QACjB,CAAC;AAED,6BAAqB,MAAMD,sBAAqB,EAAE,MAAM,CAACD,WAAU;AACjE,sBAAY,QAAQ,SAAS,+BAA+B,EAAE,UAAU,KAAK,KAAK,GAAGA,MAAK;AAAA,QAC5F,CAAC;AAGD,cAAMG,iBAAgB,iBAAiB;AACvC,YAAIA,kBAAiB,WAAW,IAAI,GAAG;AACrC,sBAAY,QAAQ,QAAQ,sCAAsC;AAAA,YAChE,UAAU,KAAK;AAAA,YACf,KAAM,KAAkB;AAAA,UAC1B,CAAC;AAED,iBAAO,KAAK,OAAO;AAAA,YACjB,KAAM,KAAkB;AAAA,YACxB,QAAQ;AAAA;AAAA,UACV,CAAC,EAAE,MAAM,CAACH,WAAU;AAClB,wBAAY,QAAQ,SAAS,wCAAwC;AAAA,cACnE,KAAM,KAAkB;AAAA,YAC1B,GAAGA,MAAK;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF;AAGA,aAAO,QAAQ,YAAY;AAAA,QACzB,QAAQ;AAAA,QACR;AAAA,MACF,CAAC,EAAE,MAAM,MAAM;AAAA,MAEf,CAAC;AAAA,IACH,SAASA,QAAO;AACd,kBAAY,QAAQ,SAAS,4BAA4B,MAAMA,MAAc;AAAA,IAC/E;AAAA,EACF;AAKA,MAAI,UAAU;AAKd,iBAAsB,qBAAqB,MAAYC,wBAA0D;AAC/G,QAAI;AACF,YAAM,iBAAiB,mBAAmB,SAAS,IAAI,KAAK,IAAI,CAAC;AACjE,YAAM,cAAc;AAAA,QAClB,SAAS,OAAO,QAAQ,OAAO,mBAAmB;AAAA,MACpD;AAEA,UAAI,sBAAgE;AAAA,QAClE,GAAG;AAAA,QACH,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS;AAAA,MACX;AAGA,UAAI,KAAK,aAAa,gBAAgB,MAAM;AAC1C,8BAAsB;AAAA,UACpB,GAAG;AAAA,UACH,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS;AAAA,QACX;AACA,oBAAY,cAAc,QAAQ,2CAA2C;AAAA,MAC/E,WAAY,KAAa,SAAS,iBAAkB,KAAa,iBAAkB,KAAa,cAAc,SAAS,GAAG;AAExH,cAAM,MAAO,KAAa,cAAc,CAAC;AACzC,8BAAsB;AAAA,UACpB,GAAG;AAAA,UACH,MAAM;AAAA,UACN,OAAO,IAAI,SAAS;AAAA,UACpB,SAAS,IAAI,QAAQ;AAAA,UACrB,UAAU,IAAI,aAAa;AAAA;AAAA,QAC7B;AACA,oBAAY,cAAc,QAAQ,oCAAoC;AAAA,MACxE,OAAO;AAEL,YAAI,QAAQ;AACZ,YAAI,UAAU;AAEd,YAAI,KAAK,SAAS,QAAQ;AACxB,kBAAQ,KAAK,SAAS;AACtB,oBAAU,KAAK,QAAQ;AAEvB,gCAAsB;AAAA,YACpB,GAAG;AAAA,YACH,MAAM;AAAA,YACN;AAAA,YACA;AAAA,UACF;AAAA,QACF,WAAW,KAAK,SAAS,QAAQ;AAC/B,kBAAQ,KAAK,SAAS,KAAK,OAAO;AAClC,oBAAU,KAAK,OAAO;AAEtB,gCAAsB;AAAA,YACpB,GAAG;AAAA,YACH,MAAM;AAAA,YACN;AAAA,YACA;AAAA,UACF;AAAA,QACF,WAAW,KAAK,SAAS,QAAQ;AAE/B,sBAAY,cAAc,SAAS,sCAAsC,EAAE,KAAK,CAAC;AAEjF,cAAI,YAAY;AAChB,cAAI,cAAc;AAElB,cAAK,KAAa,OAAO;AACvB,wBAAa,KAAa;AAC1B,0BAAe,KAAa,QAAQ,UAAW,KAAa,SAAS;AAAA,UACvE,OAAO;AACL,wBAAY,aAAc,KAAa,aAAa,cAAc;AAClE,0BAAe,KAAa,QAAS,KAAa,aAAa;AAAA,UACjE;AAGA,gBAAM,WAAY,KAAa;AAC/B,gBAAM,UAAW,KAAa;AAG9B,cAAI,aAAa;AACjB,cAAI,YAAY,kBAAkB,QAAQ,GAAG;AAC3C,yBAAa;AAAA,UACf,WAAW,WAAW,kBAAkB,OAAO,KAAM,KAAa,WAAW,WAAW,QAAQ,GAAG;AACjG,yBAAa;AAAA,UACf;AAEA,cAAI,YAAY;AAEd,kCAAsB;AAAA,cACpB,GAAG;AAAA,cACH,MAAM;AAAA,cACN,OAAO;AAAA,cACP,SAAS;AAAA,cACT,UAAU;AAAA,YACZ;AACA,wBAAY,cAAc,QAAQ,oDAAoD;AAAA,cACpF,UAAW,KAAa;AAAA,cACxB;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AAEL,kCAAsB;AAAA,cACpB,GAAG;AAAA,cACH,MAAM;AAAA,cACN,OAAO;AAAA,cACP,SAAS;AAAA,YACX;AACA,gBAAI,YAAY,CAAC,kBAAkB,QAAQ,GAAG;AAC5C,0BAAY,cAAc,QAAQ,qDAAqD;AAAA,gBACrF;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF,WAAW,KAAK,SAAS,UAAU;AACjC,gBAAM,cAAc,KAAK,SAAS,KAAK,oBAAoB;AAC3D,gBAAM,gBAAgB,KAAK,QAAQ;AAGnC,gBAAM,iBAAkB,KAAa;AACrC,cAAI,kBAAkB,kBAAkB,cAAc,GAAG;AACvD,kCAAsB;AAAA,cACpB,GAAG;AAAA,cACH,MAAM;AAAA,cACN,OAAO;AAAA,cACP,SAAS;AAAA,cACT,UAAU;AAAA,YACZ;AACA,wBAAY,cAAc,QAAQ,wDAAwD,EAAE,UAAU,KAAK,KAAK,CAAC;AAAA,UACnH,OAAO;AAEL,kCAAsB;AAAA,cACpB,GAAG;AAAA,cACH,MAAM;AAAA,cACN,OAAO;AAAA,cACP,SAAS;AAAA,YACX;AACA,gBAAI,gBAAgB;AAClB,0BAAY,cAAc,QAAQ,uDAAuD,EAAE,UAAU,eAAe,CAAC;AAAA,YACvH;AAAA,UACF;AAAA,QACF,OAAO;AAEL,gBAAM,eAAe;AACrB,gBAAM,iBAAiB,OAAO,KAAK,IAAI;AAEvC,gCAAsB;AAAA,YACpB,GAAG;AAAA,YACH,MAAM;AAAA,YACN,OAAO;AAAA,YACP,SAAS;AAAA,UACX;AACA,sBAAY,cAAc,QAAQ,8BAA8B,EAAE,UAAU,KAAK,KAAK,CAAC;AAAA,QACzF;AAAA,MACF;AAGA,YAAM,2BAA2E;AAAA,QAC/E,MAAM,oBAAoB,QAAQ;AAAA,QAClC,OAAO,oBAAoB,SAAS;AAAA,QACpC,SAAS,oBAAoB,WAAW;AAAA,QACxC,SAAS,oBAAoB,WAAW,OAAO,QAAQ,OAAO,mBAAmB;AAAA,MACnF;AAGA,UAAI,oBAAoB,UAAU;AAChC,iCAAyB,WAAW,oBAAoB;AAAA,MAC1D;AAEA,YAAM,OAAO,cAAc,OAAO,gBAAgB,wBAAwB;AAE1E,UAAIA,wBAAuB;AACzB,QAAAA,uBAAsB,IAAI,gBAAgB,IAAI;AAAA,MAChD;AAEA,yBAAmB,0BAA0B;AAC7C,kBAAY,cAAc,QAAQ,6BAA6B,EAAE,gBAAgB,UAAU,KAAK,KAAK,CAAC;AAAA,IAExG,SAASD,QAAO;AACd,yBAAmB,yBAAyB;AAC5C,kBAAY,cAAc,SAAS,oCAAoC,EAAE,UAAU,KAAK,KAAK,GAAGA,MAAc;AAAA,IAChH;AAAA,EACF;AAKO,WAAS,mBAAyB;AACvC,UAAM,iBAAiB,mBAAmB,kBAAkB;AAE5D,QAAI,eAAe,uBAAuB,KAAK,CAAC,cAAc,GAAG;AAC/D,kBAAY,QAAQ,QAAQ,qDAAqD;AAAA,QAC/E,qBAAqB,eAAe;AAAA,MACtC,CAAC;AAED,qBAAe,IAAI;AAGnB,aAAO,OAAO,OAAO,mBAAmB,EAAE,iBAAiB,EAAE,CAAC;AAE9D,kBAAY,QAAQ,QAAQ,0BAA0B,EAAE,UAAU,WAAW,CAAC;AAAA,IAChF;AAAA,EACF;AAKO,WAAS,kBAAwB;AACtC,QAAI,cAAc,GAAG;AACnB,kBAAY,QAAQ,QAAQ,+CAA+C;AAC3E,qBAAe,KAAK;AACpB,aAAO,OAAO,MAAM,iBAAiB;AAAA,IACvC;AAAA,EACF;AAKA,iBAAsB,sBAAqC;AACzD,UAAME,UAAS,UAAU;AACzB,QAAI,CAACA,SAAQ;AACX,kBAAY,QAAQ,QAAQ,2CAA2C;AACvE;AAAA,IACF;AAEA,gBAAY,QAAQ,SAAS,4BAA4B;AAAA,MACvD,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAED,QAAI;AAEF,YAAM,SAAS,MAAM,kBAAkBA,OAAM;AAG7C,YAAM,aAAa,OAAO,CAAC;AAC3B,UAAI,cAAc,aAAa,aAAa,CAAC,GAAG,SAAS,WAAW,MAAM;AACxE,oBAAY,QAAQ,QAAQ,iCAAiC;AAAA,UAC3D,QAAQ,WAAW;AAAA,UACnB,UAAU,WAAW;AAAA,QACvB,CAAC;AAGD,qBAAa,eAAe;AAG5B,eAAO,QAAQ,YAAY;AAAA,UACzB,QAAQ;AAAA,UACR;AAAA,QACF,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,MACnB;AAAA,IACF,SAASF,QAAO;AACd,kBAAY,QAAQ,SAAS,wBAAwB,MAAMA,MAAc;AAAA,IAC3E;AAAA,EACF;AAKO,WAAS,4BAA4B,UAAe,WAA6B;AACtF,UAAME,UAAS,UAAU;AAGzB,QAAIA,YAAW,CAAC,YAAY,CAAC,SAAS,YAAY,IAAI;AACpD,kBAAY,UAAU,QAAQ,iDAAiD;AAAA,QAC7E,cAAc,CAAC,CAAC;AAAA,QAChB,aAAa,WAAW,SAAS,YAAY,IAAI;AAAA,MACnD,CAAC;AAED,yBAAmB,yBAAyB;AAC5C,gBAAU;AAAA,IACZ,WAAW,YAAY,SAAS,YAAY,GAAG;AAC7C,kBAAY,UAAU,SAAS,2CAA2C;AAC1E,yBAAmB,yBAAyB;AAAA,IAC9C,OAAO;AACL,kBAAY,UAAU,SAAS,mCAAmC;AAAA,IACpE;AAAA,EACF;AAKO,WAAS,2BAA2B,OAAqB;AAC9D,WAAO,QAAQ,YAAY;AAAA,MACzB,QAAQ;AAAA,MACR;AAAA,IACF,CAAC,EAAE,MAAM,MAAM;AAAA,IAEf,CAAC;AAAA,EACH;AAMO,WAAS,mBAAyB;AAEvC,QAAI,wBAAwB;AAC1B,kBAAY,QAAQ,QAAQ,kDAAkD;AAC9E;AAAA,IACF;AAEA,6BAAyB;AAEzB,QAAI;AACF,aAAO,aAAa,UAAU,MAAM;AAElC,YAAI,OAAO,QAAQ,WAAW;AAC5B,sBAAY,QAAQ,SAAS,2CAA2C;AAAA,YACtE,OAAO,OAAO,QAAQ,UAAU;AAAA,UAClC,CAAC;AACD,mCAAyB;AACzB;AAAA,QACF;AAGA,YAAI;AACF,iBAAO,aAAa,OAAO;AAAA,YACzB,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,UAAU,CAAC,MAAM;AAAA,UACnB,CAAC;AACD,cAAI,OAAO,QAAQ,WAAW;AAC5B,wBAAY,QAAQ,SAAS,mCAAmC;AAAA,cAC9D,OAAO,OAAO,QAAQ,UAAU;AAAA,YAClC,CAAC;AAAA,UACH;AAEA,iBAAO,aAAa,OAAO;AAAA,YACzB,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,UAAU,CAAC,MAAM;AAAA,UACnB,CAAC;AACD,cAAI,OAAO,QAAQ,WAAW;AAC5B,wBAAY,QAAQ,SAAS,mCAAmC;AAAA,cAC9D,OAAO,OAAO,QAAQ,UAAU;AAAA,YAClC,CAAC;AAAA,UACH;AAEA,iBAAO,aAAa,OAAO;AAAA,YACzB,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,UAAU,CAAC,WAAW;AAAA,UACxB,CAAC;AACD,cAAI,OAAO,QAAQ,WAAW;AAC5B,wBAAY,QAAQ,SAAS,wCAAwC;AAAA,cACnE,OAAO,OAAO,QAAQ,UAAU;AAAA,YAClC,CAAC;AAAA,UACH;AAEA,iBAAO,aAAa,OAAO;AAAA,YACzB,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,UAAU,CAAC,OAAO;AAAA,UACpB,CAAC;AACD,cAAI,OAAO,QAAQ,WAAW;AAC5B,wBAAY,QAAQ,SAAS,oCAAoC;AAAA,cAC/D,OAAO,OAAO,QAAQ,UAAU;AAAA,YAClC,CAAC;AAAA,UACH;AAEA,sBAAY,QAAQ,QAAQ,mCAAmC;AAAA,QACjE,UAAE;AAEA,mCAAyB;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH,SAASF,QAAO;AACd,kBAAY,QAAQ,SAAS,iCAAiC,MAAMA,MAAc;AAClF,+BAAyB;AAAA,IAC3B;AAAA,EACF;AAKA,iBAAsB,SAAS,KAAa,OAA+B;AACzE,UAAME,UAAS,UAAU;AACzB,QAAI,CAACA,SAAQ;AACX,kBAAY,QAAQ,QAAQ,+BAA+B;AAC3D;AAAA,IACF;AAGA,UAAM,eAAe,YAAY,GAAG;AACpC,UAAM,iBAAiB,aAAa,SAAS,MAAM;AAEnD,QAAI,CAAC,cAAc;AACjB,kBAAY,QAAQ,SAAS,wBAAwB,EAAE,IAAI,CAAC;AAC5D;AAAA,IACF;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,wCAAwC;AAAA,QACnE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgBA;AAAA,UAChB,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,MAAM;AAAA,UACN,OAAO;AAAA,UACP,KAAK;AAAA,QACP,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,wBAAwB,SAAS,MAAM,EAAE;AAAA,MAC3D;AAEA,kBAAY,QAAQ,QAAQ,4BAA4B,EAAE,KAAK,MAAM,CAAC;AAEtE;AAAA,QACE;AAAA,QACA;AAAA,UACE,MAAM;AAAA,UACN,SAAS;AAAA,UACT,OAAO;AAAA,UACP,SAAS,SAAS;AAAA,QACpB;AAAA,MACF;AAAA,IACF,SAASF,QAAO;AACd,kBAAY,QAAQ,SAAS,uBAAuB,EAAE,KAAK,MAAM,GAAGA,MAAc;AAAA,IACpF;AAAA,EACF;AAKA,iBAAsB,SAAS,OAAe,MAA6B;AACzE,UAAME,UAAS,UAAU;AACzB,QAAI,CAACA,SAAQ;AACX,kBAAY,QAAQ,QAAQ,+BAA+B;AAC3D;AAAA,IACF;AAGA,UAAM,iBAAiB,aAAa,KAAK;AACzC,UAAM,gBAAgB,aAAa,IAAI;AAEvC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,wCAAwC;AAAA,QACnE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgBA;AAAA,UAChB,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,MAAM;AAAA,UACN,OAAO;AAAA,UACP,MAAM;AAAA,QACR,CAAC;AAAA,MACH,CAAC;AAED,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,wBAAwB,SAAS,MAAM,EAAE;AAAA,MAC3D;AAEA,kBAAY,QAAQ,QAAQ,4BAA4B,EAAE,MAAM,CAAC;AAEjE;AAAA,QACE;AAAA,QACA;AAAA,UACE,MAAM;AAAA,UACN,SAAS;AAAA,UACT,OAAO;AAAA,UACP,SAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF,SAASF,QAAO;AACd,kBAAY,QAAQ,SAAS,uBAAuB,EAAE,MAAM,GAAGA,MAAc;AAAA,IAC/E;AAAA,EACF;;;ACrqBO,MAAK,qBAAL,kBAAKI,wBAAL;AACL,IAAAA,oBAAA,UAAO;AACP,IAAAA,oBAAA,kBAAe;AACf,IAAAA,oBAAA,WAAQ;AACR,IAAAA,oBAAA,cAAW;AACX,IAAAA,oBAAA,WAAQ;AALE,WAAAA;AAAA,KAAA;AA6CL,MAAM,4BAAN,MAAM,2BAA0B;AAAA,IAC7B,eAAmC;AAAA,IACnC;AAAA,IAEA,YAAY,WAAkC;AACpD,WAAK,YAAY;AACjB,kBAAY,QAAQ,QAAQ,8BAA8B,EAAE,cAAc,KAAK,aAAa,CAAC;AAAA,IAC/F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,aAAoB,OAAO,WAAsE;AAC/F,YAAM,WAAW,IAAI,2BAA0B,SAAS;AAExD,UAAI;AACF,cAAM,EAAE,eAAe,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI,gBAAgB;AAE1E,YAAI,kBAAkB,OAAO,OAAO,kBAAkB,EAAE,SAAS,cAAc,GAAG;AAChF,mBAAS,eAAe;AACxB,sBAAY,QAAQ,QAAQ,8CAA8C;AAAA,YACxE,eAAe,SAAS;AAAA,UAC1B,CAAC;AAAA,QACH,OAAO;AACL,sBAAY,QAAQ,QAAQ,2DAA2D;AAAA,YACrF,cAAc,SAAS;AAAA,UACzB,CAAC;AAAA,QACH;AAAA,MACF,SAASC,QAAO;AACd,oBAAY,QAAQ,SAAS,8DAA8D,MAAMA,MAAc;AAC/G,iBAAS,eAAe;AAAA,MAC1B;AAEA,aAAO;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKO,kBAAsC;AAC3C,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA,IAKO,UAAU,OAAoC;AACnD,aAAO,KAAK,iBAAiB;AAAA,IAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,MAAa,WAAW,OAA2B,MAA2B;AAC5E,YAAM,YAAY,KAAK,aAAa,OAAO,IAAI;AAE/C,UAAI,cAAc,KAAK,cAAc;AACnC,oBAAY,QAAQ,QAAQ,6BAA6B;AAAA,UACvD,MAAM,KAAK;AAAA,UACX;AAAA,UACA,IAAI;AAAA,QACN,CAAC;AAGD,cAAM,KAAK,YAAY,KAAK,cAAc,SAAS;AAGnD,cAAM,gBAAgB,KAAK;AAC3B,aAAK,eAAe;AAGpB,cAAM,KAAK,aAAa,KAAK,cAAc,eAAe,IAAI;AAK9D,YAAI;AACF,gBAAM,OAAO,QAAQ,MAAM,IAAI;AAAA,YAC7B,gBAAgB,KAAK;AAAA,YACrB,2BAA2B,KAAK,oBAAoB;AAAA,UACtD,CAAC;AACD,sBAAY,QAAQ,SAAS,iDAAiD,EAAE,OAAO,KAAK,aAAa,CAAC;AAAA,QAC5G,SAASA,QAAO;AACd,sBAAY,QAAQ,SAAS,0CAA0C,MAAMA,MAAc;AAAA,QAC7F;AAAA,MACF,OAAO;AACL,oBAAY,QAAQ,SAAS,gCAAgC;AAAA,UAC3D,OAAO,KAAK;AAAA,UACZ;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOQ,aAAa,OAA2B,MAAgC;AAE9E,UAAI,UAAU,UAAU;AACtB,eAAO;AAAA,MACT;AAMA,UAAI,UAAU,WAAW;AACvB,YAAI,MAAM,WAAW;AAEnB,cAAI,KAAK,iBAAiB,mCAAiC;AACzD,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT,OAAO;AAEL,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,cAAQ,KAAK,cAAc;AAAA,QAC3B,KAAK;AACH,cAAI,UAAU,eAAe;AAC3B,mBAAO;AAAA,UACT;AACA;AAAA,QAEF,KAAK;AACH,cAAI,UAAU,gBAAgB;AAC5B,mBAAO;AAAA,UACT;AACA,cAAI,UAAU,gBAAgB;AAC5B,mBAAO;AAAA,UACT;AACA;AAAA,QAEF,KAAK;AACH,cAAI,UAAU,mBAAmB;AAC/B,mBAAO;AAAA,UACT;AACA,cAAI,UAAU,sBAAsB;AAClC,mBAAO;AAAA,UACT;AACA;AAAA,QAEF,KAAK;AACH,cAAI,UAAU,gBAAgB;AAC5B,mBAAO;AAAA,UACT;AACA,cAAI,UAAU,sBAAsB;AAClC,mBAAO;AAAA,UACT;AACA;AAAA,QAEF,KAAK;AACH,cAAI,UAAU,eAAe;AAC3B,mBAAO;AAAA,UACT;AACA;AAAA,MACF;AAGA,aAAO,KAAK;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,MAAc,aACZ,OACA,eACA,MACe;AACf,kBAAY,QAAQ,SAAS,iCAAiC,EAAE,OAAO,cAAc,CAAC;AAGtF,6BAAuB,KAAK,oBAAoB,CAAC;AAEjD,cAAQ,OAAO;AAAA,QACf,KAAK;AAEH,cAAI,KAAK,UAAU,aAAa;AAC9B,kBAAM,KAAK,UAAU,YAAY;AAAA,UACnC;AACA,cAAI,KAAK,UAAU,uBAAuB;AACxC,iBAAK,UAAU,sBAAsB;AAAA,UACvC;AACA;AAAA,QAEF,KAAK;AAEH,cAAI,KAAK,UAAU,cAAc;AAC/B,gBAAI;AACF,oBAAM,KAAK,UAAU,aAAa,IAAI;AAEtC,oBAAM,KAAK,WAAW,cAAc;AAAA,YACtC,SAASA,QAAO;AAEd,0BAAY,QAAQ,SAAS,wCAAwC,MAAMA,MAAc;AACzF,oBAAM,KAAK,WAAW,cAAc;AAAA,YACtC;AAAA,UACF;AACA;AAAA,QAEF,KAAK;AAEH,cAAI,kBAAkB,6BAA+B,KAAK,UAAU,eAAe;AACjF,iBAAK,UAAU,cAAc;AAAA,UAC/B;AAEA,cAAI,kBAAkB,qCAAmC,KAAK,UAAU,oBAAoB;AAC1F,iBAAK,UAAU,mBAAmB;AAAA,UACpC;AACA;AAAA,QAEF,KAAK;AAEH,sBAAY,QAAQ,QAAQ,qDAAqD;AACjF,iBAAO,OAAO,OAAO,mBAAmB,EAAE,iBAAiB,EAAE,CAAC;AAE9D,cAAI,KAAK,UAAU,gBAAgB;AACjC,iBAAK,UAAU,eAAe;AAAA,UAChC;AACA;AAAA,QAEF,KAAK;AAEH,cAAI,KAAK,UAAU,aAAa;AAC9B,iBAAK,UAAU,YAAY,qCAAqC;AAAA,UAClE;AACA;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,MAAc,YACZ,OACA,WACe;AACf,kBAAY,QAAQ,SAAS,gCAAgC,EAAE,OAAO,UAAU,CAAC;AAGjF,UAAI,UAAU,2BAA6B;AACzC,oBAAY,QAAQ,QAAQ,oDAAoD;AAChF,eAAO,OAAO,MAAM,iBAAiB;AACrC,YAAI,KAAK,UAAU,eAAe;AAChC,eAAK,UAAU,cAAc;AAAA,QAC/B;AAAA,MACF;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKO,sBAA8B;AACnC,cAAQ,KAAK,cAAc;AAAA,QAC3B,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AACH,iBAAO;AAAA,QACT;AACE,iBAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;;;AC5VO,WAAS,cAAc,QAA+C;AAE3E,QAAI,CAAC,QAAQ;AACX,kBAAY,QAAQ,QAAQ,iCAAiC;AAC7D,aAAO;AAAA,IACT;AAGA,QAAI,OAAO,OAAO,OAAO,QAAQ,IAAI;AACnC,kBAAY,QAAQ,QAAQ,4CAA4C;AAAA,QACtE,UAAU,OAAO;AAAA,QACjB,YAAY,OAAO,QAAQ;AAAA,MAC7B,CAAC;AACD,aAAO;AAAA,IACT;AAGA,QAAI,OAAO,KAAK;AACd,YAAM,eAAe,OAAO,QAAQ,OAAO,EAAE;AAC7C,UAAI,CAAC,OAAO,IAAI,WAAW,YAAY,GAAG;AACxC,oBAAY,QAAQ,QAAQ,2CAA2C;AAAA,UACrE,WAAW,OAAO;AAAA,UAClB,gBAAgB;AAAA,QAClB,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAKA,MAAM,qBAAqB,oBAAI,IAAI;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAKM,WAAS,mBAAmB,QAAyB;AAC1D,WAAO,mBAAmB,IAAI,MAAM;AAAA,EACtC;AAMO,WAAS,0BACd,QACA,QACS;AACT,QAAI,CAAC,mBAAmB,MAAM,GAAG;AAE/B,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,cAAc,MAAM,GAAG;AAC1B,kBAAY,QAAQ,SAAS,kDAAkD;AAAA,QAC7E;AAAA,QACA,UAAU,QAAQ;AAAA,QAClB,WAAW,QAAQ;AAAA,MACrB,CAAC;AACD,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;;;ACvCA,qBAAmB,WAAW;AAI9B,MAAM,wBAAwB,oBAAI,IAAkB;AACpD,MAAM,8BAA8B;AAK7B,WAAS,uBAAuB,IAAY,MAAkB;AAEnE,QAAI,sBAAsB,QAAQ,6BAA6B;AAC7D,YAAM,WAAW,sBAAsB,KAAK,EAAE,KAAK,EAAE;AACrD,UAAI,UAAU;AACZ,8BAAsB,OAAO,QAAQ;AAAA,MACvC;AAAA,IACF;AACA,0BAAsB,IAAI,IAAI,IAAI;AAAA,EACpC;AAKO,WAAS,uBAA0C;AACxD,WAAO;AAAA,EACT;AAcA,iBAAe,qBAAqB,WAAW,GAAG,QAAQ,KAA6B;AACrF,aAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AACjC,UAAI;AACF,cAAMC,UAAS,MAAM,kBAAkB,UAAU;AACjD,YAAIA,SAAQ;AACV,sBAAY,QAAQ,QAAQ,4BAA4B,IAAI,CAAC,IAAI,QAAQ,EAAE;AAC3E,iBAAOA;AAAA,QACT;AAEA,oBAAY,QAAQ,SAAS,gCAAgC,IAAI,CAAC,IAAI,QAAQ,cAAc;AAAA,MAC9F,SAASC,QAAO;AACd,oBAAY,QAAQ,QAAQ,oCAAoC,IAAI,CAAC,IAAI,QAAQ,IAAI,MAAMA,MAAc;AAAA,MAC3G;AAGA,UAAI,IAAI,WAAW,GAAG;AACpB,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,KAAK,CAAC;AAAA,MACzD;AAAA,IACF;AAEA,gBAAY,QAAQ,QAAQ,2BAA2B,QAAQ,8CAA8C;AAC7G,WAAO;AAAA,EACT;AAGA,MAAIC,mBAA0C;AAG9C,MAAI,qBAA6B;AAOjC,MAAI;AAGJ,MAAM,wBAAwB;AAAA,IAC5B,cAAc,OAAO,SAAc;AAEjC,YAAMF,UAAS,MAAM,UAAU,UAAU;AACzC,UAAIA,SAAQ;AAEV,cAAM,uBAAuB,iBAAiB,kBAAkB;AAAA,UAC9D;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IAEA,gBAAgB,MAAM;AACpB,uBAAiB;AAAA,IACnB;AAAA,IACA,eAAe,MAAM;AACnB,sBAAgB;AAAA,IAClB;AAAA,IACA,aAAa,CAACC,WAAkB;AAC9B,kBAAY,QAAQ,SAAS,8BAA8B,EAAE,OAAAA,OAAM,CAAC;AACpE,2BAAqB,cAAc;AAAA,IACrC;AAAA,IACA,aAAa,YAAY;AAEvB,mBAAa,WAAW;AACxB,mBAAa,UAAU,CAAC;AACxB,mBAAa,eAAe,CAAC;AAC7B,mBAAa,cAAc;AAAA,IAC7B;AAAA,IACA,uBAAuB,MAAM;AAC3B,0BAAoB;AAAA,IACtB;AAAA,EACF;AAIA,MAAM,oBAAoB,0BAA0B,OAAO,qBAAqB,EAAE,KAAK,QAAM;AAC3F,mBAAe;AACf,gBAAY,QAAQ,QAAQ,oDAAoD;AAAA,MAC9E,cAAc,aAAa,gBAAgB;AAAA,IAC7C,CAAC;AAAA,EACH,CAAC;AAYD,iBAAe,qBAAoC;AACjD,QAAI;AACF,YAAM,EAAE,gBAAgB,0BAA0B,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI;AAAA,QACnF;AAAA,QACA;AAAA,MACF,CAAC;AAED,UAAI,gBAAgB;AAClB,oBAAY,QAAQ,QAAQ,uCAAuC,EAAE,OAAO,eAAe,CAAC;AAG5F,YAAI,2BAA2B;AAC7B,iCAAuB,yBAAyB;AAAA,QAClD;AAGA,gBAAQ,gBAAsC;AAAA,UAC9C;AACE,iCAAqB,WAAW;AAChC;AAAA,UACF;AACE,iCAAqB,YAAY;AACjC;AAAA,UACF;AAAA,UACA;AAAA,UACA;AACE,iCAAqB,cAAc;AACnC;AAAA,UACF;AACE,iCAAqB,cAAc;AAAA,QACrC;AAAA,MACF;AAAA,IACF,SAASA,QAAO;AACd,kBAAY,QAAQ,SAAS,kCAAkC,MAAMA,MAAc;AAAA,IACrF;AAAA,EACF;AAKA,WAAS,mBAAyB;AAEhC,yBAAqB,KAAK,IAAI;AAG9B,yBAAqB,YAAY;AAGjC,QAAIC,kBAAiB;AACnB,kBAAY,UAAU,QAAQ,kDAAkD;AAChF,MAAAA,iBAAgB,WAAW;AAC3B,MAAAA,mBAAkB;AAAA,IACpB;AAMA,gBAAY,UAAU,SAAS,qDAAqD;AACpF,mBAAe,mBAAmB,uBAAuB;AACzD,mBAAe,mBAAmB,yBAAyB;AAC3D,mBAAe,mBAAmB,gBAAgB;AAClD,mBAAe,mBAAmB,qBAAqB;AACvD,mBAAe,mBAAmB,wBAAwB;AAC1D,mBAAe,mBAAmB,yBAAyB;AAC3D,mBAAe,mBAAmB,wBAAwB;AAC1D,mBAAe,mBAAmB,iBAAiB;AAEnD,IAAAA,mBAAkB,IAAI,gBAAgB,eAAe,SAAS;AAC9D,uBAAmBA,gBAAe;AAMlC,mBAAe,GAAG,yBAAyB,YAAY;AACrD,YAAM,cAAc,qBAAqB;AAAA,IAC3C,CAAC;AAED,mBAAe,GAAG,2BAA2B,YAAY;AACvD,YAAMF,UAAS,UAAU;AACzB,UAAIA,SAAQ;AACV,cAAM,UAAU,MAAM,aAAaA,OAAM;AACzC,qBAAa,UAAU;AACvB,qBAAa,cAAc,KAAK,IAAI;AAEpC,eAAO,QAAQ,YAAY;AAAA,UACzB,QAAQ;AAAA,UACR;AAAA,UACA,UAAU,aAAa;AAAA,UACvB,cAAc,aAAa;AAAA,UAC3B,eAAe,aAAa;AAAA,UAC5B,gBAAgB,aAAa;AAAA,QAC/B,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,MACnB;AAAA,IACF,CAAC;AAED,mBAAe,GAAG,kBAAkB,OAAO,SAAe;AAExD,YAAM,mBAAmB;AAGzB,yBAAmB,mBAAmB;AAEtC,UAAI,gBAAgB;AAGpB,UAAI,eAAe,QAAQ,KAAK,aAAa,gBAAgB,MAAM;AACjE,YAAI;AAEF,gBAAM,WAAW,MAAM,kBAAkB,sBAAsB;AAE/D,cAAI,YAAY,aAAa,UAAU;AACrC,wBAAY,QAAQ,QAAQ,6BAA6B;AAAA,cACvD,UAAU,KAAK;AAAA,YACjB,CAAC;AAED,kBAAM,YAAY,MAAM,iBAAiB;AAAA,cACnC;AAAA,cACA;AAAA,cACA,aAAa,SAAS;AAAA,YAC5B;AAEA,4BAAgB;AAChB,wBAAY,QAAQ,QAAQ,+BAA+B;AAAA,cACzD,UAAU,cAAc;AAAA,YAC1B,CAAC;AAAA,UACH,OAAO;AACL,wBAAY,QAAQ,QAAQ,kDAAkD;AAAA,UAChF;AAAA,QACF,SAASC,QAAO;AACd,sBAAY,QAAQ,SAAS,0BAA0B;AAAA,YACrD,OAAQA,OAAgB;AAAA,UAC1B,GAAGA,MAAc;AAAA,QACnB;AAAA,MACF;AAGA,YAAM,mBAAmB,CAAC,UAAU,QAAQ,MAAM;AAElD,UAAI,CAAC,iBAAiB,SAAS,cAAc,IAAI,GAAG;AAElD,oBAAY,QAAQ,QAAQ,yCAAyC;AAAA,UACnE,UAAU,cAAc;AAAA,UACxB,UAAU,cAAc;AAAA,QAC1B,CAAC;AACD;AAAA,MACF;AAGA,kBAAY,QAAQ,QAAQ,uCAAuC;AAAA,QACjE,UAAU,cAAc;AAAA,QACxB,UAAU,cAAc;AAAA,MAC1B,CAAC;AAGD,UAAI,aAAa,cAAc;AAC7B,qBAAa,aAAa,QAAQ,aAAa;AAC/C,qBAAa,cAAc,KAAK,IAAI;AAEpC,eAAO,QAAQ,YAAY;AAAA,UACzB,QAAQ;AAAA,UACR,QAAQ,aAAa;AAAA,QACvB,CAAC,EAAE,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,MACnB;AAIA,2BAAqB,eAAe,qBAAqB,EAAE,MAAM,CAACA,WAAU;AAC1E,oBAAY,QAAQ,SAAS,+BAA+B,MAAMA,MAAK;AACvE,2BAAmB,yBAAyB;AAAA,MAC9C,CAAC;AAGD,YAAME,iBAAgB,iBAAiB;AACvC,UAAIA,kBAAiB,WAAW,aAAa,GAAG;AAC9C,oBAAY,QAAQ,QAAQ,0BAA0B;AAAA,UACpD,UAAU,cAAc;AAAA,UACxB,KAAK,cAAc;AAAA,QACrB,CAAC;AAED,eAAO,KAAK,OAAO;AAAA,UACjB,KAAK,cAAc;AAAA,UACnB,QAAQ;AAAA;AAAA,QACV,CAAC,EAAE,MAAM,CAACF,WAAU;AAClB,sBAAY,QAAQ,SAAS,4BAA4B;AAAA,YACvD,KAAK,cAAc;AAAA,UACrB,GAAGA,MAAK;AAAA,QACV,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAED,mBAAe,GAAG,uBAAuB,YAAY;AAEnD,YAAM,eAAe,KAAK,IAAI,IAAI;AAClC,kBAAY,YAAY,QAAQ,2BAA2B,EAAE,UAAU,aAAa,CAAC;AACrF,YAAM,EAAE,kBAAkB,CAAC,EAAE,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI,iBAAiB;AACjF,sBAAgB,KAAK,YAAY;AAEjC,YAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,iBAAiB,gBAAgB,MAAM,GAAG,EAAE,CAAC;AAG9E,mBAAa,WAAW,cAAc;AACtC,2BAAqB,WAAW;AAAA,IAClC,CAAC;AAED,mBAAe,GAAG,0BAA0B,MAAM;AAEhD,mBAAa,WAAW,iBAAiB;AACzC,2BAAqB,cAAc;AAAA,IACrC,CAAC;AAED,mBAAe,GAAG,2BAA2B,MAAM;AACjD,uBAAiB;AAAA,IACnB,CAAC;AAED,mBAAe,GAAG,0BAA0B,MAAM;AAChD,sBAAgB;AAAA,IAClB,CAAC;AAED,mBAAe,GAAG,mBAAmB,CAAC,UAAkB;AACtD,iCAA2B,KAAK;AAAA,IAClC,CAAC;AAED,IAAAC,iBAAgB,QAAQ;AAAA,EAC1B;AAKA,WAAS,sBAA4B;AACnC,QAAIA,kBAAiB;AACnB,MAAAA,iBAAgB,WAAW;AAAA,IAC7B;AAAA,EACF;AASA,SAAO,QAAQ,YAAY,YAAY,YAAY;AAEjD,UAAM,EAAE,WAAW,EAAE,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI,UAAU;AAClE,UAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,UAAU,WAAW,EAAE,CAAC;AAGzD,UAAM,mBAAmB;AAEzB,gBAAY,QAAQ,QAAQ,0CAA0C;AAAA,MACpE,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAGD,eAAW,MAAM,qBAAqB,cAAc,GAAG,GAAG;AAE1D,gBAAY,qBAAqB,aAAa;AAC9C,qBAAiB;AAGjB,WAAO,OAAO,OAAO,YAAY,EAAE,iBAAiB,EAAE,CAAC;AAIvD,UAAM;AAMN,QAAI;AACF,YAAMF,UAAS,MAAM,qBAAqB;AAC1C,UAAIA,SAAQ;AACV,kBAAUA,OAAM;AAAA,MAClB;AACA,YAAM,aAAa,WAAW,WAAW,EAAE,WAAW,CAAC,CAACA,QAAO,CAAC;AAAA,IAClE,SAASC,QAAO;AACd,kBAAY,QAAQ,SAAS,qCAAqC,MAAMA,MAAc;AACtF,YAAM,aAAa,WAAW,WAAW,EAAE,WAAW,MAAM,CAAC;AAAA,IAC/D;AAAA,EACF,CAAC;AAKD,SAAO,QAAQ,UAAU,YAAY,YAAY;AAE/C,UAAM,EAAE,WAAW,EAAE,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI,UAAU;AAClE,UAAM,OAAO,QAAQ,MAAM,IAAI,EAAE,UAAU,WAAW,EAAE,CAAC;AAGzD,UAAM,mBAAmB;AAEzB,gBAAY,QAAQ,QAAQ,yDAAyD;AAAA,MACnF,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC,CAAC;AAGD,eAAW,MAAM,qBAAqB,cAAc,GAAG,GAAG;AAE1D,gBAAY,qBAAqB,WAAW;AAC5C,qBAAiB;AAGjB,WAAO,OAAO,OAAO,YAAY,EAAE,iBAAiB,EAAE,CAAC;AAIvD,UAAM;AAMN,QAAI;AACF,YAAMD,UAAS,MAAM,qBAAqB;AAC1C,UAAIA,SAAQ;AACV,kBAAUA,OAAM;AAAA,MAClB;AACA,YAAM,aAAa,WAAW,WAAW,EAAE,WAAW,CAAC,CAACA,QAAO,CAAC;AAAA,IAClE,SAASC,QAAO;AACd,kBAAY,QAAQ,SAAS,qCAAqC,MAAMA,MAAc;AACtF,YAAM,aAAa,WAAW,WAAW,EAAE,WAAW,MAAM,CAAC;AAAA,IAC/D;AAAA,EACF,CAAC;AAKD,SAAO,cAAc,UAAU,YAAY,CAAC,mBAAmB;AAC7D,gBAAY,cAAc,QAAQ,wBAAwB,EAAE,eAAe,CAAC;AAG5E,UAAM,WAAW,sBAAsB,IAAI,cAAc;AAEzD,QAAI,UAAU;AAEZ,aAAO,QAAQ,OAAO;AAAA,QACpB,KAAK,+BAA+B,mBAAmB,cAAc,CAAC;AAAA,QACtE,MAAM;AAAA,QACN,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAGA,WAAO,cAAc,MAAM,cAAc;AAAA,EAC3C,CAAC;AAKD,SAAO,OAAO,QAAQ,YAAY,OAAO,UAAU;AACjD,QAAI,MAAM,SAAS,YAAY;AAE7B,kBAAY,MAAM,EAAE,KAAK,MAAM;AAC7B,gBAAQ,IAAI,oDAAoD;AAAA,MAClE,CAAC;AAAA,IACH,WAAW,MAAM,SAAS,wBAAwB,UAAU,GAAG;AAC7D,kBAAY,UAAU,QAAQ,gCAAgC;AAAA,QAC5D,WAAW,MAAM;AAAA,QACjB,WAAW,CAAC,CAAC,UAAU;AAAA,QACvB,eAAe,MAAM,gBAAgB,IAAI,KAAK,MAAM,aAAa,EAAE,YAAY,IAAI;AAAA,MACrF,CAAC;AACD,uBAAiB;AAAA,IACnB,WAAW,MAAM,SAAS,sBAAsB;AAC9C,kBAAY,UAAU,QAAQ,uDAAuD;AAAA,IACvF,WAAW,MAAM,SAAS,wBAAwB;AAEhD,YAAM,mBAAmB;AACzB,kCAA4BC,kBAAiB,gBAAgB;AAE7D,aAAO,QAAQ,MAAM,IAAI,EAAE,eAAe,KAAK,IAAI,EAAE,CAAC;AAAA,IACxD,WAAW,MAAM,SAAS,mBAAmB;AAC3C,0BAAoB;AAAA,IACtB;AAAA,EACF,CAAC;AAKD,SAAO,aAAa,UAAU,YAAY,OAAO,MAAM,QAAQ;AAE7D,UAAM,mBAAmB;AAEzB,QAAI,CAAC,UAAU,GAAG;AAChB,aAAO,cAAc,OAAO,yBAAyB;AAAA,QACnD,MAAM;AAAA,QACN,SAAS;AAAA,QACT,OAAO;AAAA,QACP,SAAS;AAAA,MACX,CAAC;AACD;AAAA,IACF;AAEA,YAAQ,KAAK,YAAY;AAAA,MACzB,KAAK;AACH,YAAI,KAAK,WAAW,KAAK;AACvB,mBAAS,KAAK,SAAS,IAAI,KAAK;AAAA,QAClC;AACA;AAAA,MACF,KAAK;AACH,YAAI,OAAO,IAAI,KAAK;AAClB,mBAAS,IAAI,KAAK,IAAI,KAAK;AAAA,QAC7B;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,iBAAiB,KAAK;AAC7B,mBAAS,qBAAqB,IAAI,SAAS,SAAS,KAAK,aAAa;AAAA,QACxE;AACA;AAAA,MACF,KAAK;AACH,YAAI,KAAK,UAAU,KAAK;AACtB,mBAAS,KAAK,QAAQ,iBAAiB,IAAI,SAAS,OAAO;AAAA,QAC7D;AACA;AAAA,IACF;AAAA,EACF,CAAC;AAOD,SAAO,QAAQ,UAAU,YAAY,CAAC,SAAS,QAAQ,iBAAiB;AAGtE,QAAI,CAAC,0BAA0B,QAAQ,QAAQ,MAAM,GAAG;AACtD,kBAAY,QAAQ,SAAS,qDAAqD;AAAA,QAChF,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA,QAClB,WAAW,QAAQ;AAAA,MACrB,CAAC;AACD,mBAAa,EAAE,SAAS,OAAO,OAAO,eAAe,CAAC;AACtD,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,OAAO;AAEnC,UAAI,QAAQ,SAAS;AACnB,cAAM,EAAE,OAAO,SAAS,YAAY,KAAK,IAAI,QAAQ;AACrD,cAAM,SAAS;AAEf,gBAAQ,OAAO;AAAA,UACf,KAAK;AACH,wBAAY,QAAQ,SAAS,GAAG,MAAM,IAAI,UAAU,IAAI,IAAI;AAC5D;AAAA,UACF,KAAK;AACH,wBAAY,QAAQ,QAAQ,GAAG,MAAM,IAAI,UAAU,IAAI,IAAI;AAC3D;AAAA,UACF,KAAK;AAAA,UACL;AACE,wBAAY,QAAQ,QAAQ,GAAG,MAAM,IAAI,UAAU,IAAI,IAAI;AAC3D;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ,WAAW,kBAAkB;AAIvC,OAAC,YAAY;AACX,YAAI;AAEF,gBAAM,mBAAmB;AAGzB,gBAAM,eAAe,MAAM,kBAAkB,UAAU;AAGvD,cAAI,gBAAgB,CAAC,aAAa,iBAAiB;AACjD,wBAAY,QAAQ,QAAQ,mEAAmE;AAG/F,kBAAM,uBAAuB,mBAAmB,kBAAkB;AAAA,cAChE;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAGA,uBAAa;AAAA,YACX,iBAAiB,aAAa;AAAA,YAC9B,UAAU,aAAa;AAAA,YACvB,SAAS,aAAa;AAAA,YACtB,cAAc,aAAa;AAAA,YAC3B,eAAe,iBAAiB;AAAA,YAChC,gBAAgB,kBAAkB;AAAA,YAClC,oBAAoBA,mBAAkBA,iBAAgB,YAAY,IAAI;AAAA,UACxE,CAAC;AAAA,QACH,SAASD,QAAO;AACd,sBAAY,QAAQ,SAAS,+CAA+C,MAAMA,MAAc;AAChG,uBAAa,EAAE,iBAAiB,OAAO,OAAQA,OAAgB,QAAQ,CAAC;AAAA,QAC1E;AAAA,MACF,GAAG;AAEH,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,iBAAiB;AAE7C,gBAAU,QAAQ,MAAM;AAGxB,UAAI,cAAc,kBAAkB,UAAU,QAAQ,MAAM;AAG5D,UAAI,QAAQ,gBAAgB;AAC1B,sBAAc,YAAY,KAAK,MAAM;AACnC,4BAAkB,QAAQ,cAAc;AACxC,uBAAa,iBAAiB,QAAQ;AACtC,iBAAO,kBAAkB,kBAAkB,QAAQ,cAAc;AAAA,QACnE,CAAC;AAAA,MACH;AAIA,kBAAY,KAAK,MAAM,iBAAiB,EAAE,KAAK,MAAM;AACnD,eAAO,aAAa,WAAW,eAAe,EAAE,QAAQ,QAAQ,OAAO,CAAC;AAAA,MAC1E,CAAC,EAAE,KAAK,MAAM;AAEZ,qBAAa;AAAA,UACX,SAAS;AAAA,UACT,iBAAiB,aAAa,6BAAkC,KAAK,aAAa,mCAAqC;AAAA,UACvH,UAAU,aAAa;AAAA,UACvB,SAAS,aAAa;AAAA,UACtB,cAAc,aAAa;AAAA,UAC3B,eAAe,aAAa;AAAA,UAC5B,gBAAgB,aAAa;AAAA,UAC7B,oBAAoBC,mBAAkBA,iBAAgB,YAAY,IAAI;AAAA,QACxE,CAAC;AAAA,MACH,CAAC,EAAE,MAAM,CAACD,WAAU;AAClB,oBAAY,QAAQ,SAAS,wBAAwB,MAAMA,MAAK;AAChE,qBAAa,EAAE,SAAS,OAAO,OAAOA,OAAM,QAAQ,CAAC;AAAA,MACvD,CAAC;AAED,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,UAAU;AAGtC,wBAAkB,KAAK,MAAM;AAC3B,eAAO,aAAa,WAAW,QAAQ;AAAA,MACzC,CAAC,EAAE,KAAK,MAAM;AAEZ,eAAO,kBAAkB,UAAU,IAAI;AAAA,MACzC,CAAC,EAAE,KAAK,MAAM;AACZ,eAAO,kBAAkB,cAAc,IAAI;AAAA,MAC7C,CAAC,EAAE,KAAK,MAAM;AACZ,qBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,MAChC,CAAC,EAAE,MAAM,CAACA,WAAU;AAClB,oBAAY,QAAQ,SAAS,uBAAuB,MAAMA,MAAK;AAC/D,qBAAa,EAAE,SAAS,OAAO,OAAOA,OAAM,QAAQ,CAAC;AAAA,MACvD,CAAC;AAED,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,kBAAkB;AAE9C,OAAC,YAAY;AACX,cAAM,mBAAmB;AAEzB,cAAMD,UAAS,UAAU;AACzB,YAAIA,SAAQ;AACV,8BAAoBA,OAAM,EAAE,KAAK,MAAM;AACrC,yBAAa;AAAA,cACX,iBAAiB;AAAA,cACjB,UAAU,aAAa;AAAA,cACvB,SAAS,aAAa;AAAA,cACtB,cAAc,aAAa;AAAA,cAC3B,eAAe,aAAa;AAAA,cAC5B,gBAAgB,aAAa;AAAA,YAC/B,CAAC;AAAA,UACH,CAAC,EAAE,MAAM,CAACC,WAAU;AAClB,wBAAY,QAAQ,SAAS,4BAA4B,MAAMA,MAAK;AACpE,yBAAa,EAAE,iBAAiB,MAAM,CAAC;AAAA,UACzC,CAAC;AAAA,QACH,OAAO;AACL,uBAAa,EAAE,iBAAiB,MAAM,CAAC;AAAA,QACzC;AAAA,MACF,GAAG;AAEH,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,mBAAmB;AAC/C,YAAM,WAA4B,CAAC;AAGnC,UAAI,QAAQ,UAAU,gBAAgB;AACpC,cAAM,cAAc,QAAQ,SAAS;AACrC,cAAMD,UAAS,UAAU;AACzB,cAAMI,cAAa,cAAc;AAGjC,YAAIJ,WAAUI,aAAY;AACxB,mBAAS;AAAA,YACP,qBAAqBJ,SAAQI,aAAY,WAAW,EAAE,KAAK,MAAM;AAE/D,gCAAkB,WAAW;AAC7B,2BAAa,iBAAiB;AAC9B,qBAAO,kBAAkB,kBAAkB,WAAW;AAAA,YACxD,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AAEL,4BAAkB,WAAW;AAC7B,uBAAa,iBAAiB;AAC9B,mBAAS,KAAK,kBAAkB,kBAAkB,WAAW,CAAC;AAAA,QAChE;AAAA,MACF;AAEA,UAAI,QAAQ,kBAAkB,QAAW;AACvC,yBAAiB,QAAQ,aAAa;AACtC,qBAAa,gBAAgB,QAAQ;AACrC,iBAAS,KAAK,kBAAkB,iBAAiB,QAAQ,aAAa,CAAC;AAAA,MACzE;AAEA,UAAI,QAAQ,wBAAwB,QAAW;AAC7C,+BAAuB,QAAQ,mBAAmB;AAClD,iBAAS,KAAK,kBAAkB,uBAAuB,QAAQ,mBAAmB,CAAC;AAAA,MACrF;AAEA,cAAQ,IAAI,QAAQ,EAAE,KAAK,MAAM;AAC/B,qBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,MAChC,CAAC,EAAE,MAAM,CAACH,WAAU;AAClB,oBAAY,QAAQ,SAAS,yBAAyB,MAAMA,MAAK;AACjE,qBAAa,EAAE,SAAS,OAAO,OAAOA,OAAM,QAAQ,CAAC;AAAA,MACvD,CAAC;AAED,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,wBAAwB;AAEpD,OAAC,YAAY;AACX,cAAM,mBAAmB;AAEzB,cAAMD,UAAS,UAAU;AACzB,cAAMI,cAAa,cAAc;AAEjC,YAAIJ,WAAUI,eAAc,QAAQ,UAAU;AAC5C,+BAAqBJ,SAAQI,aAAY,QAAQ,QAAQ,EAAE,KAAK,YAAY;AAC1E,8BAAkB,QAAQ,QAAQ;AAClC,yBAAa,iBAAiB,QAAQ;AACtC,kBAAM,kBAAkB,kBAAkB,QAAQ,QAAQ;AAE1D,yBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,UAChC,CAAC,EAAE,MAAM,CAACH,WAAU;AAClB,wBAAY,QAAQ,SAAS,kCAAkC,MAAMA,MAAK;AAC1E,yBAAa,EAAE,SAAS,OAAO,OAAOA,OAAM,QAAQ,CAAC;AAAA,UACvD,CAAC;AAAA,QACH,OAAO;AACL,uBAAa,EAAE,SAAS,OAAO,OAAO,8BAA8B,CAAC;AAAA,QACvE;AAAA,MACF,GAAG;AAEH,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,mBAAmB;AAE/C,OAAC,YAAY;AAEX,cAAM;AAEN,cAAM,UAAU,YAAY,WAAW;AACvC,cAAM,UAAU,eAAe,eAAe;AAC9C,cAAM,WAAW,mBAAmB,sBAAsB;AAC1D,cAAM,cAAc,SAAS;AAG7B,cAAM,iBAAiB;AAAA,UACrB,SAAS;AAAA,YACP,WAAWC,mBAAmBA,iBAAgB,YAAY,IAAI,cAAc,iBAAkB;AAAA,YAC9F,YAAY,QAAQ;AAAA,YACpB,mBAAmB,aAAa,gBAAgB;AAAA,YAChD,yBAAyB,aAAa,oBAAoB;AAAA,UAC5D;AAAA,UACA,WAAW,QAAQ;AAAA,UACnB,eAAe,QAAQ;AAAA,QACzB;AAKA,cAAM,0BAA0B;AAAA,UAC9B,WAAW,YAAY;AAAA,UACvB,gBAAgB;AAAA;AAAA,YAEd,oBAAoB,YAAY,QAAQ,WAAW;AAAA,YACnD,oBAAoB,YAAY,QAAQ,WAAW;AAAA;AAAA,YAEnD,oBAAoB,YAAY,SAAS,kBAAkB;AAAA,YAC3D,qBAAqB,YAAY,SAAS,uBAAuB;AAAA;AAAA,YAEjE,gBAAgB;AAAA,YAChB,YAAY;AAAA,YACZ,YAAY;AAAA,YACZ,kBAAkB;AAAA,YAClB,eAAe;AAAA,UACjB;AAAA,UACA,eAAe,YAAY;AAAA,QAC7B;AAGA,cAAM,EAAE,WAAW,GAAG,kBAAkB,CAAC,EAAE,IAAI,MAAM,OAAO,QAAQ,MAAM,IAAI,CAAC,YAAY,iBAAiB,CAAC;AAC7G,cAAM,kBAAkB,gBAAgB,SAAS,IAC7C,gBAAgB,OAAO,CAAC,GAAW,MAAc,IAAI,GAAG,CAAC,IAAI,gBAAgB,SAC7E;AAEJ,cAAM,oBAAoB;AAAA,UACxB;AAAA,UACA,gBAAgB,YAAY,WAAW,EAAE;AAAA;AAAA,UACzC,iBAAiB,gBAAgB,QAAQ,CAAC,IAAI;AAAA;AAAA,QAEhD;AAEA,cAAM,UAAU;AAAA,UACd,QAAQ,mBAAmB,UAAU;AAAA,UACrC,MAAM,QAAQ;AAAA;AAAA,UACd,WAAW,QAAQ,QAAQ;AAAA,UAC3B,aAAa;AAAA,UACb;AAAA,UACA,qBAAqB,YAAY,WAAW;AAAA,UAC5C;AAAA;AAAA,UACA,QAAQ;AAAA,YACN,OAAO,QAAQ,QAAQ;AAAA,YACvB,SAAS,QAAQ,QAAQ;AAAA;AAAA,YACzB,UAAU,CAAC;AAAA,UACb;AAAA,QACF;AAEA,qBAAa,EAAE,SAAS,MAAM,QAAQ,CAAC;AAAA,MACzC,GAAG;AAEH,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,gBAAgB;AAE5C,kBAAY,UAAU,EAAE,KAAK,MAAM;AACjC,qBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,MAChC,CAAC;AACD,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,qBAAqB;AAEjD,UAAI,QAAQ,QAAQ;AAClB,2BAAmB,aAAa,QAAQ,MAAM,EAAE,KAAK,MAAM;AACzD,uBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,QAChC,CAAC,EAAE,MAAM,CAACD,WAAU;AAClB,sBAAY,QAAQ,SAAS,iCAAiC,MAAMA,MAAK;AACzE,uBAAa,EAAE,SAAS,OAAO,OAAOA,OAAM,QAAQ,CAAC;AAAA,QACvD,CAAC;AAAA,MACH,OAAO;AACL,qBAAa,EAAE,SAAS,OAAO,OAAO,qBAAqB,CAAC;AAAA,MAC9D;AACA,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,mBAAmB;AAE/C,kBAAY,QAAQ,QAAQ,2BAA2B;AAGvD,OAAC,YAAY;AACX,cAAM;AAEN,cAAM,UAAU,YAAY,WAAW;AACvC,cAAM,eAAe,mBAAmB,gBAAgB;AAExD,cAAM,eAAe;AAAA,UACnB,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UAClC,SAAS,OAAO,QAAQ,YAAY,EAAE;AAAA,UACtC,WAAW;AAAA,UACX,iBAAiB,mBAAmB,sBAAsB;AAAA,UAC1D,YAAY;AAAA,YACV,gBAAgB,eAAe,eAAe;AAAA,YAC9C,oBAAoB,YAAY,WAAW;AAAA,YAC3C,cAAc;AAAA,cACZ,cAAc,aAAa,gBAAgB;AAAA,cAC3C,aAAa,aAAa,oBAAoB;AAAA,YAChD;AAAA,UACF;AAAA,UACA,WAAW;AAAA,YACT,SAAS;AAAA,YACT,QAAQ,mBAAmB,gBAAgB,EAAE;AAAA,UAC/C;AAAA,UACA,cAAc;AAAA,YACZ,iBAAiB,aAAa;AAAA,YAC9B,aAAa,aAAa,cAAc,IAAI,KAAK,aAAa,WAAW,EAAE,YAAY,IAAI;AAAA,YAC3F,UAAU,aAAa,WAAW,EAAE,OAAO,aAAa,SAAS,OAAO,UAAU,GAAG,CAAC,IAAI,MAAM,IAAI;AAAA,YACpG,aAAa,aAAa,SAAS,UAAU;AAAA,YAC7C,WAAW,aAAa,cAAc,UAAU;AAAA,UAClD;AAAA,QACF;AAEA,qBAAa,EAAE,SAAS,MAAM,MAAM,aAAa,CAAC;AAAA,MACpD,GAAG;AAEH,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,uBAAuB;AAEnD,YAAM,WAAW,sBAAsB,IAAI,QAAQ,cAAc;AACjE,UAAI,UAAU;AACZ,qBAAa,EAAE,SAAS,MAAM,MAAM,SAAS,CAAC;AAAA,MAChD,OAAO;AACL,qBAAa,EAAE,SAAS,OAAO,OAAO,yBAAyB,CAAC;AAAA,MAClE;AACA,aAAO;AAAA,IACT,WAAW,QAAQ,WAAW,YAAY;AAGxC,OAAC,YAAY;AACX,YAAI;AAEF,gBAAM,mBAAmB;AAEzB,gBAAMD,UAAS,UAAU;AACzB,cAAI,CAACA,SAAQ;AACX,yBAAa,EAAE,SAAS,OAAO,OAAO,mCAAmC,CAAC;AAC1E;AAAA,UACF;AAEA,gBAAM,WAAW,QAAQ;AACzB,cAAI,CAAC,YAAY,CAAC,SAAS,MAAM;AAC/B,yBAAa,EAAE,SAAS,OAAO,OAAO,oBAAoB,CAAC;AAC3D;AAAA,UACF;AAGA,gBAAM,WAAW,MAAM,MAAM,wCAAwC;AAAA,YACnE,QAAQ;AAAA,YACR,SAAS;AAAA,cACP,gBAAgBA;AAAA,cAChB,gBAAgB;AAAA,YAClB;AAAA,YACA,MAAM,KAAK,UAAU,QAAQ;AAAA,UAC/B,CAAC;AAED,cAAI,CAAC,SAAS,IAAI;AAChB,kBAAM,YAAY,MAAM,SAAS,KAAK;AACtC,gBAAI,eAAe;AACnB,gBAAI;AACF,oBAAM,YAAY,KAAK,MAAM,SAAS;AACtC,kBAAI,UAAU,OAAO,SAAS;AAC5B,+BAAe,UAAU,MAAM;AAAA,cACjC;AAAA,YACF,QAAQ;AAAA,YAER;AACA,kBAAM,IAAI,MAAM,YAAY;AAAA,UAC9B;AAGA,gBAAM,cAAc,qBAAqB;AAEzC,uBAAa,EAAE,SAAS,KAAK,CAAC;AAAA,QAChC,SAASC,QAAO;AACd,sBAAY,QAAQ,SAAS,uBAAuB,EAAE,UAAU,QAAQ,UAAU,KAAK,GAAGA,MAAc;AACxG,uBAAa,EAAE,SAAS,OAAO,OAAQA,OAAgB,QAAQ,CAAC;AAAA,QAClE;AAAA,MACF,GAAG;AAEH,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AAGD,EAAC,WAAmB,kBAAkB,WAAW;AAC/C,WAAO;AAAA,MACL,WAAW,YAAY,WAAW;AAAA,MAClC,iBAAiB,mBAAmB,sBAAsB;AAAA,MAC1D,gBAAgB,eAAe,eAAe;AAAA,MAC9C,oBAAoB,YAAY,WAAW;AAAA,MAC3C,cAAc;AAAA,QACZ,iBAAiB,aAAa;AAAA,QAC9B,aAAa,aAAa,cAAc,IAAI,KAAK,aAAa,WAAW,EAAE,YAAY,IAAI;AAAA,QAC3F,UAAU,aAAa,WAAW,EAAE,OAAO,aAAa,SAAS,OAAO,UAAU,GAAG,CAAC,IAAI,MAAM,IAAI;AAAA,QACpG,aAAa,aAAa,SAAS,UAAU;AAAA,QAC7C,WAAW,aAAa,cAAc,UAAU;AAAA,MAClD;AAAA,MACA,oBAAoBC,mBAAkBA,iBAAgB,YAAY,IAAI;AAAA,MACtE,qBAAqB;AAAA,QACnB,YAAY,oBAAoB;AAAA,QAChC,WAAW,oBAAoB;AAAA,QAC/B,WAAW,oBAAoB,YAAY,IAAI,KAAK,oBAAoB,SAAS,EAAE,YAAY,IAAI;AAAA,QACnG,UAAU,CAAC,CAAC,oBAAoB;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,cAAY,QAAQ,QAAQ,yCAAyC;AAAA,IACnE,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,EACpC,CAAC;",
  "names": ["error", "error", "error", "getApiKey", "apiKey", "error", "apiKey", "error", "deviceIden", "deviceNickname", "error", "apiKey", "deviceIden", "deviceNickname", "autoOpenLinks", "notificationTimeout", "API_BASE_URL", "PUSHES_URL", "DEVICES_URL", "USER_INFO_URL", "error", "notificationDataStore", "apiKey", "autoOpenLinks", "ServiceWorkerState", "error", "apiKey", "error", "websocketClient", "autoOpenLinks", "deviceIden"]
}
