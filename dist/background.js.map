{
  "version": 3,
  "sources": ["../src/lib/logging/index.ts", "../src/lib/perf/index.ts", "../src/lib/monitoring/index.ts", "../src/types/domain.ts", "../src/app/notifications/index.ts", "../src/lib/events/event-bus.ts", "../src/app/ws/client.ts", "../src/infrastructure/storage/storage.repository.ts", "../src/app/api/http.ts", "../src/app/push-types.ts", "../src/app/api/client.ts", "../src/infrastructure/storage/indexed-db.ts", "../src/background/keepalive.ts", "../src/app/session/pipeline.ts", "../src/app/session/index.ts", "../src/infrastructure/storage/opened-mru.repository.ts", "../src/background/diagnostics.ts", "../src/app/reconnect/index.ts", "../src/lib/crypto/index.ts", "../src/background/state.ts", "../src/background/links.ts", "../src/background/processing.ts", "../src/background/utils.ts", "../src/background/state-machine.ts", "../src/background/startup.ts", "../src/realtime/postConnectQueue.ts", "../src/lib/security/message-validation.ts", "../src/background/index.ts"],
  "sourcesContent": ["/* Logging and debug configuration (TypeScript)\n   Mirrors js/logging.js without changing behavior. */\n\nexport type LogLevel = \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\nexport type LogCategory =\n  | \"WEBSOCKET\"\n  | \"NOTIFICATIONS\"\n  | \"API\"\n  | \"STORAGE\"\n  | \"GENERAL\"\n  | \"PERFORMANCE\"\n  | \"ERROR\";\n\n// Persistent logging constants\nconst STORAGE_KEY = \"persistentDebugLogs\";\nconst MAX_PERSISTENT_LOGS = 5000; // Store the last 5000 log entries\n\nexport interface DebugConfig {\n  enabled: boolean;\n  categories: Record<LogCategory, boolean>;\n  logLevel: LogLevel;\n  maxLogEntries: number;\n  sanitizeData: boolean;\n}\n\n// DEBUG TOGGLE: Default to disabled to prevent unnecessary log accumulation\nexport const DEBUG_CONFIG: DebugConfig = {\n  enabled: false,\n  categories: {\n    WEBSOCKET: true,\n    NOTIFICATIONS: true,\n    API: true,\n    STORAGE: true,\n    GENERAL: true,\n    PERFORMANCE: true,\n    ERROR: true,\n  },\n  logLevel: \"DEBUG\",\n  maxLogEntries: 1000,\n  sanitizeData: true,\n};\n\nexport interface LogEntry {\n  timestamp: string;\n  category: LogCategory;\n  level: LogLevel;\n  message: string;\n  data: unknown | null;\n  error: { name: string; message: string; stack?: string } | null;\n}\n\nexport class DebugLogger {\n  private logs: LogEntry[] = [];\n  private startTime = Date.now();\n  private performanceMarkers = new Map<string, number>();\n\n  /**\n   * Rehydrate logs from persistent storage on startup\n   * This method loads logs from the previous session\n   */\n  async rehydrate(): Promise<void> {\n    try {\n      const result = await chrome.storage.local.get(STORAGE_KEY);\n      if (result[STORAGE_KEY] && Array.isArray(result[STORAGE_KEY])) {\n        this.logs = result[STORAGE_KEY];\n        console.log(\n          `[Logger] Rehydrated ${this.logs.length} logs from persistent storage.`,\n        );\n      }\n    } catch (error) {\n      console.error(\"[Logger] Failed to rehydrate logs:\", error);\n    }\n  }\n\n  /**\n   * Flush logs to persistent storage\n   * This method saves the current in-memory logs with circular buffer logic\n   */\n  async flush(): Promise<void> {\n    try {\n      // Circular buffer: trim to MAX_PERSISTENT_LOGS before saving\n      if (this.logs.length > MAX_PERSISTENT_LOGS) {\n        this.logs = this.logs.slice(this.logs.length - MAX_PERSISTENT_LOGS);\n      }\n      await chrome.storage.local.set({ [STORAGE_KEY]: this.logs });\n    } catch (error) {\n      // Don't use debugLogger here to avoid potential infinite loop\n      console.error(\"[Logger] Failed to flush logs to storage:\", error);\n    }\n  }\n\n  /**\n   * Clear all logs from memory and persistent storage\n   * This method is called when the user clicks \"Clear All Logs\" in the debug dashboard\n   */\n  async clearLogs(): Promise<void> {\n    this.logs = [];\n    await this.flush();\n    this.log('GENERAL', 'INFO', 'Log buffer has been cleared by the user.');\n  }\n\n  private sanitize(data: unknown): unknown {\n    if (!DEBUG_CONFIG.sanitizeData) return data;\n    if (typeof data === \"string\") {\n      if (data.length > 20 && /^[a-zA-Z0-9_-]+$/.test(data)) {\n        return data.substring(0, 4) + \"***\" + data.substring(data.length - 4);\n      }\n      return data;\n    }\n    if (data && typeof data === \"object\") {\n      const sanitized: Record<string, unknown> | unknown[] = Array.isArray(data)\n        ? []\n        : {};\n      for (const key in data as Record<string, unknown>) {\n        if (\n          key.toLowerCase().includes(\"token\") ||\n          key.toLowerCase().includes(\"key\") ||\n          key.toLowerCase().includes(\"password\")\n        ) {\n          (sanitized as any)[key] = this.sanitize((data as any)[key]);\n        } else {\n          (sanitized as any)[key] = (data as any)[key];\n        }\n      }\n      return sanitized;\n    }\n    return data;\n  }\n\n  private getTimestamp(): string {\n    const now = new Date();\n    const elapsed = Date.now() - this.startTime;\n    return `${now.toISOString()} (+${elapsed}ms)`;\n  }\n\n  /**\n   * Format data for console output to avoid [object Object]\n   */\n  private formatDataForConsole(data: unknown): string {\n    if (typeof data === 'object' && data !== null) {\n      try {\n        return JSON.stringify(data, null, 2);\n      } catch {\n        return String(data);\n      }\n    }\n    return String(data ?? 'null');\n  }\n\n  /**\n   * Format error for console output\n   */\n  private formatErrorForConsole(error: Error | null): string {\n    if (!error) return 'null';\n    \n    if (error instanceof Error) {\n      return `${error.name}: ${error.message}`;\n    }\n    \n    // Handle non-Error objects (like WebSocket Event objects)\n    try {\n      return JSON.stringify(error, null, 2);\n    } catch {\n      return String(error);\n    }\n  }\n\n  log(\n    category: LogCategory,\n    level: LogLevel,\n    message: string,\n    data: unknown = null,\n    error: Error | null = null,\n  ) {\n    if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.categories[category]) return;\n    const timestamp = this.getTimestamp();\n    const entry: LogEntry = {\n      timestamp,\n      category,\n      level,\n      message,\n      data: data ? this.sanitize(data) : null,\n      error: error\n        ? {\n          name: error.name,\n          message: error.message,\n          stack: (error as any).stack,\n        }\n        : null,\n    };\n    if (error && level === \"ERROR\") {\n      globalErrorTracker.trackError(\n        error,\n        { category, message, data: data ? this.sanitize(data) : null },\n        category,\n      );\n    }\n    this.logs.push(entry);\n    // Trimming is now handled by the periodic flush() method to avoid performance overhead\n\n    const prefix = `[${category}:${level}] ${timestamp}`;\n    const full = `${prefix} ${message}`;\n    const sanitized = data ? this.sanitize(data) : null;\n    switch (level) {\n    case \"ERROR\":\n      if (sanitized && error) {\n        console.error(full);\n        console.error(\"  Data:\", this.formatDataForConsole(sanitized));\n        console.error(\"  Error:\", this.formatErrorForConsole(error));\n      } else if (sanitized) {\n        console.error(full);\n        console.error(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else if (error) {\n        console.error(full);\n        console.error(\"  Error:\", this.formatErrorForConsole(error));\n      } else {\n        console.error(full);\n      }\n      break;\n    case \"WARN\":\n      if (sanitized) {\n        console.warn(full);\n        console.warn(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else {\n        console.warn(full);\n      }\n      break;\n    case \"INFO\":\n      if (sanitized) {\n        console.info(full);\n        console.info(\"  Data:\", this.formatDataForConsole(sanitized));\n      } else {\n        console.info(full);\n      }\n      break;\n    default:\n      if (sanitized) {\n        console.log(full);\n        console.log(\"  Data:\", sanitized);\n      } else {\n        console.log(full);\n      }\n    }\n  }\n\n  websocket(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"WEBSOCKET\", level, message, data, error || null);\n  }\n  notifications(\n    level: LogLevel,\n    message: string,\n    data?: unknown,\n    error?: Error,\n  ) {\n    this.log(\"NOTIFICATIONS\", level, message, data, error || null);\n  }\n  api(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"API\", level, message, data, error || null);\n  }\n  storage(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"STORAGE\", level, message, data, error || null);\n  }\n  general(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"GENERAL\", level, message, data, error || null);\n  }\n  performance(level: LogLevel, message: string, data?: unknown, error?: Error) {\n    this.log(\"PERFORMANCE\", level, message, data, error || null);\n  }\n  error(message: string, data?: unknown, error?: Error) {\n    this.log(\"ERROR\", \"ERROR\", message, data, error || null);\n  }\n\n  startTimer(name: string) {\n    this.performanceMarkers.set(name, Date.now());\n    this.performance(\"DEBUG\", `Timer started: ${name}`);\n  }\n  endTimer(name: string): number | null {\n    const start = this.performanceMarkers.get(name);\n    if (start) {\n      const duration = Date.now() - start;\n      this.performanceMarkers.delete(name);\n      this.performance(\"INFO\", `Timer ended: ${name}`, {\n        duration: `${duration}ms`,\n      });\n      return duration;\n    }\n    this.performance(\"WARN\", `Timer not found: ${name}`);\n    return null;\n  }\n  getRecentLogs(count = 50, category: LogCategory | null = null) {\n    let logs = this.logs;\n    if (category) logs = logs.filter((l) => l.category === category);\n    return logs.slice(-count);\n  }\n  exportLogs() {\n    return {\n      config: DEBUG_CONFIG,\n      logs: this.logs,\n      summary: {\n        totalLogs: this.logs.length,\n        categories: (\n          Object.keys(DEBUG_CONFIG.categories) as LogCategory[]\n        ).reduce((acc: Record<string, number>, cat) => {\n          acc[cat] = this.logs.filter((l) => l.category === cat).length;\n          return acc;\n        }, {}),\n        errors: this.logs.filter((l) => l.level === \"ERROR\").length,\n      },\n    };\n  }\n}\n\nexport const debugLogger = new DebugLogger();\n\n// Rehydrate logs from persistent storage on startup\n// We don't await this because we can't have a top-level await in a module\ndebugLogger.rehydrate();\n\nexport class DebugConfigManager {\n  async loadConfig() {\n    try {\n      debugLogger.storage(\"DEBUG\", \"Loading debug configuration from storage\");\n      const result = await chrome.storage.local.get([\"debugConfig\"]);\n      if (result.debugConfig) {\n        Object.assign(DEBUG_CONFIG, result.debugConfig as Partial<DebugConfig>);\n        debugLogger.storage(\n          \"INFO\",\n          \"Debug configuration loaded from storage\",\n          DEBUG_CONFIG,\n        );\n      } else {\n        debugLogger.storage(\n          \"INFO\",\n          \"No stored debug configuration found - using defaults\",\n          DEBUG_CONFIG,\n        );\n      }\n    } catch (error: any) {\n      debugLogger.storage(\n        \"ERROR\",\n        \"Failed to load debug configuration\",\n        null,\n        error,\n      );\n    }\n  }\n  async saveConfig() {\n    try {\n      debugLogger.storage(\"DEBUG\", \"Saving debug configuration to storage\");\n      await chrome.storage.local.set({ debugConfig: DEBUG_CONFIG });\n      debugLogger.storage(\"INFO\", \"Debug configuration saved to storage\");\n    } catch (error: any) {\n      debugLogger.storage(\n        \"ERROR\",\n        \"Failed to save debug configuration\",\n        null,\n        error,\n      );\n    }\n  }\n  async updateConfig(updates: Partial<DebugConfig>) {\n    Object.assign(DEBUG_CONFIG, updates);\n    await this.saveConfig();\n    debugLogger.general(\"INFO\", \"Debug configuration updated\", updates);\n  }\n  toggleCategory(category: LogCategory) {\n    if (\n      Object.prototype.hasOwnProperty.call(DEBUG_CONFIG.categories, category)\n    ) {\n      DEBUG_CONFIG.categories[category] = !DEBUG_CONFIG.categories[category];\n      void this.saveConfig();\n      debugLogger.general(\"INFO\", `Debug category ${category} toggled`, {\n        category,\n        enabled: DEBUG_CONFIG.categories[category],\n      });\n    }\n  }\n  setLogLevel(level: LogLevel) {\n    const valid: LogLevel[] = [\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"];\n    if (valid.includes(level)) {\n      DEBUG_CONFIG.logLevel = level;\n      void this.saveConfig();\n      debugLogger.general(\"INFO\", `Debug log level set to ${level}`);\n    }\n  }\n  getConfig(): DebugConfig {\n    return { ...DEBUG_CONFIG };\n  }\n  resetConfig() {\n    const def: DebugConfig = {\n      enabled: true,\n      categories: {\n        WEBSOCKET: true,\n        NOTIFICATIONS: true,\n        API: true,\n        STORAGE: true,\n        GENERAL: true,\n        PERFORMANCE: true,\n        ERROR: true,\n      },\n      logLevel: \"DEBUG\",\n      maxLogEntries: 1000,\n      sanitizeData: true,\n    };\n    Object.assign(DEBUG_CONFIG, def);\n    void this.saveConfig();\n    debugLogger.general(\"INFO\", \"Debug configuration reset to defaults\");\n  }\n}\n\nexport const debugConfigManager = new DebugConfigManager();\n\nexport class GlobalErrorTracker {\n  private errors: Array<{\n    timestamp: string;\n    category: string;\n    message: string;\n    name: string;\n    stack?: string;\n    context: any;\n  }> = [];\n  private errorCounts = new Map<string, number>();\n  private criticalErrors: any[] = [];\n\n  trackError(error: Error, context: any = {}, category = \"GENERAL\") {\n    const entry = {\n      timestamp: new Date().toISOString(),\n      category,\n      message: error.message,\n      name: error.name,\n      stack: (error as any).stack,\n      context,\n    };\n    this.errors.push(entry);\n    const count = (this.errorCounts.get(category) || 0) + 1;\n    this.errorCounts.set(category, count);\n    if (count >= 5) this.criticalErrors.push(entry);\n  }\n  getErrorSummary() {\n    const byCat: Record<string, number> = {};\n    this.errorCounts.forEach((v, k) => (byCat[k] = v));\n    return {\n      total: this.errors.length,\n      byCategory: byCat,\n      critical: this.criticalErrors.length,\n    };\n  }\n  exportErrorData() {\n    return { errors: this.errors.slice(-200), summary: this.getErrorSummary() };\n  }\n}\n\nexport const globalErrorTracker = new GlobalErrorTracker();\n\n// Attach listeners in SW environment; swallow if not available\ntry {\n  self.addEventListener(\"error\", (event: ErrorEvent) => {\n    globalErrorTracker.trackError(\n      (event as any).error || new Error(event.message),\n      {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        type: \"unhandled\",\n      },\n      \"GLOBAL\",\n    );\n  });\n} catch (error) {\n  // Log global unhandled rejection handler setup failure - non-critical for main functionality\n  console.warn('Failed to set up global unhandled rejection handler:', error);\n}\ntry {\n  self.addEventListener(\n    \"unhandledrejection\",\n    (event: PromiseRejectionEvent) => {\n      globalErrorTracker.trackError(\n        (event as any).reason || new Error(\"Unhandled promise rejection\"),\n        { type: \"unhandled_promise\" },\n        \"GLOBAL\",\n      );\n    },\n  );\n} catch {\n  /* noop */\n}\n", "/* Performance monitoring (TypeScript)\n   Mirrors js/performance.js */\n\nexport class PerformanceMonitor {\n  private metrics = new Map<string, number>();\n  private notificationTimeline: Array<{ ts: number; event: string }>= [];\n  private websocketMetrics = { connectionAttempts: 0, successfulConnections: 0, messagesReceived: 0, messagesProcessed: 0, reconnectionAttempts: 0, lastConnectionTime: null as number | null, totalDowntime: 0 };\n  private notificationMetrics = { pushesReceived: 0, notificationsCreated: 0, notificationsFailed: 0, unknownTypes: 0 };\n  private healthChecks = { success: 0, failure: 0, lastCheck: null as number | null };\n  private quality = { disconnections: 0, permanentErrors: 0, consecutiveFailures: 0 };\n  private recoveryMetrics = { invalidCursorRecoveries: 0, lastRecoveryTime: null as number | null };\n  private timers: Record<string, number> = {};\n\n  record(metric: string, value = 1) { const cur = this.metrics.get(metric) || 0; this.metrics.set(metric, cur + value); }\n  start(name: string) { this.timers[name] = Date.now(); }\n  end(name: string) { if (this.timers[name]) { const d = Date.now() - this.timers[name]; delete this.timers[name]; this.record(`timer:${name}`, d); return d; } return null; }\n  recordWebSocketConnection(success: boolean) { this.websocketMetrics.connectionAttempts++; if (success) { this.websocketMetrics.successfulConnections++; this.websocketMetrics.lastConnectionTime = Date.now(); this.quality.consecutiveFailures = 0; } }\n  recordWebSocketMessage(received = true, processed = false) { if (received) this.websocketMetrics.messagesReceived++; if (processed) this.websocketMetrics.messagesProcessed++; }\n  recordWebSocketReconnection() { this.websocketMetrics.reconnectionAttempts++; this.quality.consecutiveFailures++; }\n  recordHealthCheckSuccess() { this.healthChecks.success++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures = 0; }\n  recordHealthCheckFailure() { this.healthChecks.failure++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures++; }\n  recordDisconnection() { this.quality.disconnections++; }\n  recordPermanentError() { this.quality.permanentErrors++; }\n  recordNotification(event: string) { this.notificationTimeline.push({ ts: Date.now(), event }); if (this.notificationTimeline.length > 200) this.notificationTimeline.shift(); }\n  recordPushReceived() { this.notificationMetrics.pushesReceived++; }\n  recordNotificationCreated() { this.notificationMetrics.notificationsCreated++; }\n  recordNotificationFailed() { this.notificationMetrics.notificationsFailed++; }\n  recordUnknownPushType() { this.notificationMetrics.unknownTypes++; }\n  recordInvalidCursorRecovery() { this.recoveryMetrics.invalidCursorRecoveries++; this.recoveryMetrics.lastRecoveryTime = Date.now(); }\n  getPerformanceSummary() { return { websocket: this.websocketMetrics, health: this.healthChecks, quality: this.quality, notifications: this.notificationMetrics, recovery: this.recoveryMetrics, metrics: Object.fromEntries(this.metrics) as Record<string, number> }; }\n  getQualityMetrics() { return this.quality; }\n  exportPerformanceData() { return { summary: this.getPerformanceSummary(), timeline: this.notificationTimeline.slice(-200) }; }\n}\n\nexport const performanceMonitor = new PerformanceMonitor();\n\n", "/* Monitoring (TypeScript)\n   Mirrors js/monitoring.js */\n\nimport { debugLogger } from '../logging';\n\nexport class InitializationTracker {\n  private initializations: Array<{ source: string; timestamp: string }> = [];\n  private stats: Record<string, number> = { onInstalled: 0, onStartup: 0, onAlarm: 0, onMessage: 0, manual: 0 };\n\n  recordInitialization(source: string) {\n    this.initializations.push({ source, timestamp: new Date().toISOString() });\n    if (this.stats[source] !== undefined) this.stats[source]++;\n  }\n  exportData() { return { initializations: this.initializations.slice(-100), stats: { ...this.stats } }; }\n}\n\nexport const initTracker = new InitializationTracker();\n\nexport class WebSocketStateMonitor {\n  private stateHistory: Array<{ timestamp: number; state: string | null; duration: number }>= [];\n  private lastStateCheck = Date.now();\n  private monitoringInterval: ReturnType<typeof setInterval> | null = null;\n  private alertThresholds = { slowReceive: 15000 };\n\n  recordStateChange(newState: string) {\n    const now = Date.now();\n    const prev = this.stateHistory[this.stateHistory.length - 1];\n    const duration = prev ? now - prev.timestamp : 0;\n    this.stateHistory.push({ timestamp: now, state: newState, duration });\n    if (this.stateHistory.length > 200) this.stateHistory.shift();\n  }\n  getStateReport() {\n    const currentState = (globalThis as any).websocket && typeof (globalThis as any).websocket.readyState === 'number'\n      ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][(globalThis as any).websocket.readyState] : 'NULL';\n    return { currentState, lastCheck: new Date(this.lastStateCheck).toISOString(), historyLength: this.stateHistory.length };\n  }\n  startMonitoring() {\n    if (this.monitoringInterval) return;\n    this.monitoringInterval = setInterval(() => {\n      this.lastStateCheck = Date.now();\n      const state = (globalThis as any).websocket ? (globalThis as any).websocket.readyState : null;\n      try { (globalThis as any).debugLogger?.websocket('DEBUG', 'WebSocket state check', { state }); } catch (error) {\n        // Log the error with context - this is a monitoring operation that shouldn't fail the main flow\n        debugLogger.general('WARN', 'Failed to log WebSocket state check', null, error as Error);\n      }\n    }, 30000);\n  }\n  stopMonitoring() { if (this.monitoringInterval) { clearInterval(this.monitoringInterval); this.monitoringInterval = null; } }\n}\n\nexport const wsStateMonitor = new WebSocketStateMonitor();\n\n", "/************************************\r\n * Domain types for TypeScript plan *\r\n ************************************/\r\n\r\nexport type ISO8601 = string;\r\n\r\n// ============================================================================\r\n// User and Device Types\r\n// ============================================================================\r\n\r\nexport interface User {\r\n  iden: string;\r\n  email?: string;\r\n  name?: string;\r\n  image_url?: string;\r\n  max_upload_size?: number;\r\n}\r\n\r\nexport interface Device {\r\n  iden: string;\r\n  nickname?: string;\r\n  manufacturer?: string;\r\n  model?: string;\r\n  active?: boolean;\r\n  created?: number;\r\n  modified?: number;\r\n  push_token?: string;\r\n  app_version?: number;\r\n  type?: string;\r\n  kind?: string;\r\n  icon?: string;\r\n  has_sms?: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// Push Types\r\n// ============================================================================\r\n\r\nexport interface PushBase {\r\n  iden?: string;\r\n  active?: boolean;\r\n  created?: number;\r\n  modified?: number;\r\n  dismissed?: boolean;\r\n  direction?: 'self' | 'incoming' | 'outgoing';\r\n  sender_iden?: string;\r\n  sender_email?: string;\r\n  sender_name?: string;\r\n  receiver_iden?: string;\r\n  receiver_email?: string;\r\n  target_device_iden?: string;\r\n  source_device_iden?: string;\r\n  encrypted?: boolean;\r\n  ciphertext?: string;\r\n}\r\n\r\nexport interface LinkPush extends PushBase {\r\n  type: 'link';\r\n  title?: string;\r\n  body?: string;\r\n  url: string;\r\n}\r\n\r\nexport interface NotePush extends PushBase {\r\n  type: 'note';\r\n  title?: string;\r\n  body?: string;\r\n}\r\n\r\nexport interface FilePush extends PushBase {\r\n  type: 'file';\r\n  file_name?: string;\r\n  file_type?: string;\r\n  file_url?: string;\r\n  body?: string;\r\n  image_url?: string;\r\n  image_width?: number;\r\n  image_height?: number;\r\n}\r\n\r\nexport interface MirrorPush extends PushBase {\r\n  type: 'mirror';\r\n  title?: string;\r\n  body?: string;\r\n  icon?: string;\r\n  application_name?: string;\r\n  package_name?: string;\r\n  notification_id?: string;\r\n  notification_tag?: string;\r\n  source_user_iden?: string;\r\n}\r\n\r\nexport interface DismissalPush extends PushBase {\r\n  type: 'dismissal';\r\n  package_name?: string;\r\n  notification_id?: string;\r\n  notification_tag?: string;\r\n  source_user_iden?: string;\r\n}\r\n\r\nexport interface SmsChangedPush extends PushBase {\r\n  type: 'sms_changed';\r\n  notifications?: Array<{\r\n    title?: string;\r\n    body?: string;\r\n    timestamp?: number;\r\n    image_url?: string;\r\n  }>;\r\n}\r\n\r\nexport type Push = LinkPush | NotePush | FilePush | MirrorPush | DismissalPush | SmsChangedPush;\r\n\r\n// ============================================================================\r\n// Chat Types\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a chat/conversation with a contact\r\n * From /v2/chats API endpoint\r\n */\r\nexport interface Chat {\r\n  iden: string;\r\n  active: boolean;\r\n  created: number;\r\n  modified: number;\r\n  muted?: boolean;\r\n  with: {\r\n    email: string;\r\n    email_normalized: string;\r\n    iden?: string;\r\n    image_url?: string;\r\n    name?: string;\r\n    type: \"user\" | \"email\";\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Session and State Types\r\n// ============================================================================\r\n\r\nexport interface SessionCache {\r\n  userInfo: User | null;\r\n  devices: Device[];\r\n  recentPushes: Push[];\r\n  chats: Chat[]; // \u2190 ADD THIS LINE\r\n  isAuthenticated: boolean;\r\n  lastUpdated: number;\r\n  autoOpenLinks: boolean;\r\n  deviceNickname: string;\r\n  onlyThisDevice: boolean;\r\n  lastModifiedCutoff: number; // \u2190 Tracks last timestamp for incremental fetches\r\n  cachedAt: number; // Timestamp when cache was saved to IndexedDB\r\n}\r\n\r\nexport interface InitializationState {\r\n  inProgress: boolean;\r\n  completed: boolean;\r\n  error: Error | null;\r\n  timestamp: number | null;\r\n}\r\n\r\n// ============================================================================\r\n// WebSocket Types\r\n// ============================================================================\r\n\r\nexport enum WS_READY_STATE {\r\n  CONNECTING = 0,\r\n  OPEN = 1,\r\n  CLOSING = 2,\r\n  CLOSED = 3\r\n}\r\n\r\nexport interface WebSocketTickleMessage {\r\n  type: 'tickle';\r\n  subtype: 'push' | 'device';\r\n}\r\n\r\nexport interface WebSocketPushMessage {\r\n  type: 'push';\r\n  push: Push;\r\n}\r\n\r\nexport interface WebSocketNopMessage {\r\n  type: 'nop';\r\n}\r\n\r\nexport type WebSocketMessage = WebSocketTickleMessage | WebSocketPushMessage | WebSocketNopMessage;\r\n\r\n// ============================================================================\r\n// API Response Types\r\n// ============================================================================\r\n\r\nexport interface APIResponse<T> {\r\n  data?: T;\r\n  error?: {\r\n    type: string;\r\n    message: string;\r\n    cat?: string;\r\n  };\r\n}\r\n\r\nexport interface DevicesResponse {\r\n  devices: Device[];\r\n}\r\n\r\nexport interface PushesResponse {\r\n  pushes: Push[];\r\n  cursor?: string;\r\n}\r\n\r\nexport type UserResponse = User;\r\n\r\n// ============================================================================\r\n// Configuration Types\r\n// ============================================================================\r\n\r\nexport interface DebugConfig {\r\n  enabled: boolean;\r\n  categories: Record<string, boolean>;\r\n  logLevel: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\r\n  maxLogEntries: number;\r\n  sanitizeData: boolean;\r\n}\r\n\r\nexport interface StorageConfig {\r\n  apiKey?: string;\r\n  deviceIden?: string;\r\n  deviceNickname?: string;\r\n  autoOpenLinks?: boolean;\r\n  notificationTimeout?: number;\r\n  onlyThisDevice?: boolean;\r\n  debugConfig?: DebugConfig;\r\n}\r\n\r\n// ============================================================================\r\n// Chrome Message Types\r\n// ============================================================================\r\n\r\nexport enum MessageAction {\r\n  GET_SESSION_DATA = 'getSessionData',\r\n  API_KEY_CHANGED = 'apiKeyChanged',\r\n  SESSION_DATA_UPDATED = 'sessionDataUpdated',\r\n  PUSHES_UPDATED = 'pushesUpdated',\r\n  SETTINGS_CHANGED = 'settingsChanged',\r\n  LOGOUT = 'logout',\r\n  REFRESH_SESSION = 'refreshSession',\r\n  UPDATE_DEVICE_NICKNAME = 'updateDeviceNickname',\r\n  LOG = 'log',\r\n  SEND_PUSH = 'sendPush',\r\n  GET_NOTIFICATION_DATA = 'getNotificationData',\r\n  CLEAR_ALL_LOGS = 'clearAllLogs',\r\n  UPDATE_DEBUG_CONFIG = 'updateDebugConfig',\r\n  EXPORT_DEBUG_DATA = 'exportDebugData',\r\n  GET_DEBUG_SUMMARY = 'getDebugSummary',\r\n  CONNECTION_STATE_CHANGED = 'connectionStateChanged',\r\n  AUTO_OPEN_LINKS_CHANGED = 'autoOpenLinksChanged',\r\n  ENCRYPTION_PASSWORD_CHANGED = 'encryptionPasswordChanged',\r\n  DEBUG_MODE_CHANGED = 'debugModeChanged',\r\n}\r\n\r\nexport interface GetSessionDataMessage {\r\n  action: MessageAction.GET_SESSION_DATA;\r\n}\r\n\r\nexport interface SessionDataResponse {\r\n  isAuthenticated: boolean;\r\n  userInfo: User | null;\r\n  devices: Device[];\r\n  recentPushes: Push[];\r\n  chats: Chat[]; // \u2190 ADD THIS\r\n  autoOpenLinks: boolean;\r\n  deviceNickname: string;\r\n  websocketConnected?: boolean;\r\n  onlyThisDevice?: boolean;\r\n  deviceIden?: string;\r\n}\r\n\r\nexport interface ApiKeyChangedMessage {\r\n  action: MessageAction.API_KEY_CHANGED;\r\n  apiKey: string;\r\n  deviceNickname?: string;\r\n}\r\n\r\nexport interface SessionDataUpdatedMessage {\r\n  action: MessageAction.SESSION_DATA_UPDATED;\r\n  isAuthenticated: boolean;\r\n  userInfo?: User | null;\r\n  devices?: Device[];\r\n  recentPushes?: Push[];\r\n  autoOpenLinks?: boolean;\r\n  deviceNickname?: string;\r\n}\r\n\r\nexport interface PushesUpdatedMessage {\r\n  action: MessageAction.PUSHES_UPDATED;\r\n  pushes: Push[];\r\n}\r\n\r\nexport interface SettingsChangedMessage {\r\n  action: MessageAction.SETTINGS_CHANGED;\r\n  autoOpenLinks?: boolean;\r\n  notificationTimeout?: number;\r\n  onlyThisDevice?: boolean;\r\n}\r\n\r\nexport interface LogoutMessage {\r\n  action: MessageAction.LOGOUT;\r\n}\r\n\r\nexport interface RefreshSessionMessage {\r\n  action: MessageAction.REFRESH_SESSION;\r\n}\r\n\r\nexport interface UpdateDeviceNicknameMessage {\r\n  action: MessageAction.UPDATE_DEVICE_NICKNAME;\r\n  nickname: string;\r\n}\r\n\r\nexport type ChromeMessage =\r\n  | GetSessionDataMessage\r\n  | ApiKeyChangedMessage\r\n  | SessionDataUpdatedMessage\r\n  | PushesUpdatedMessage\r\n  | SettingsChangedMessage\r\n  | LogoutMessage\r\n  | RefreshSessionMessage\r\n  | UpdateDeviceNicknameMessage;\r\n\r\n// ============================================================================\r\n// Type Guards\r\n// ============================================================================\r\n\r\nexport function isLinkPush(push: Push): push is LinkPush {\r\n  return push.type === 'link';\r\n}\r\n\r\nexport function isNotePush(push: Push): push is NotePush {\r\n  return push.type === 'note';\r\n}\r\n\r\nexport function isFilePush(push: Push): push is FilePush {\r\n  return push.type === 'file';\r\n}\r\n\r\nexport function isMirrorPush(push: Push): push is MirrorPush {\r\n  return push.type === 'mirror';\r\n}\r\n\r\nexport function isDismissalPush(push: Push): push is DismissalPush {\r\n  return push.type === 'dismissal';\r\n}\r\n\r\nexport function isTickleMessage(msg: WebSocketMessage): msg is WebSocketTickleMessage {\r\n  return msg.type === 'tickle';\r\n}\r\n\r\nexport function isPushMessage(msg: WebSocketMessage): msg is WebSocketPushMessage {\r\n  return msg.type === 'push';\r\n}\r\n\r\nexport function isNopMessage(msg: WebSocketMessage): msg is WebSocketNopMessage {\r\n  return msg.type === 'nop';\r\n}\r\n\r\n// ============================================================================\r\n// Validation Helpers\r\n// ============================================================================\r\n\r\nexport function isValidPush(push: unknown): push is Push {\r\n  if (!push || typeof push !== 'object') return false;\r\n  const p = push as Partial<Push>;\r\n  return typeof p.type === 'string' && ['link', 'note', 'file', 'mirror', 'dismissal'].includes(p.type);\r\n}\r\n\r\nexport function isValidDevice(device: unknown): device is Device {\r\n  if (!device || typeof device !== 'object') return false;\r\n  const d = device as Partial<Device>;\r\n  return typeof d.iden === 'string' && d.iden.length > 0;\r\n}\r\n\r\nexport function isValidUser(user: unknown): user is User {\r\n  if (!user || typeof user !== 'object') return false;\r\n  const u = user as Partial<User>;\r\n  return typeof u.iden === 'string' && u.iden.length > 0;\r\n}\r\n\r\n", "import { debugLogger } from \"../../lib/logging\";\nimport { performanceMonitor } from \"../../lib/perf\";\n\n// Track last disconnection notification to avoid spam\nlet lastDisconnectionNotification = 0;\nconst DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\n\n/**\n * Helper function to create notification with auto-dismiss\n */\nexport function createNotificationWithTimeout(\n  notificationId: string,\n  options: chrome.notifications.NotificationCreateOptions,\n  callback?: (id?: string) => void,\n  timeoutMs?: number,\n): void {\n  // Get ABSOLUTE URL for the icon - service workers need absolute paths!\n  const iconUrl = chrome.runtime.getURL(\"icons/icon128.png\");\n\n  // Create CLEAN options with ONLY the properties we want\n  const safeOptions: chrome.notifications.NotificationCreateOptions = {\n    type: \"basic\",\n    iconUrl: iconUrl, // Use absolute URL\n    title: options.title || \"Pushbullet\",\n    message: options.message || \"\",\n    priority: options.priority || 1,\n  };\n\n  // Log what we're creating\n  debugLogger.notifications(\n    \"DEBUG\",\n    \"Creating notification with safe options\",\n    {\n      notificationId,\n      iconUrl,\n      title: safeOptions.title,\n      messageLength: safeOptions.message?.length || 0,\n    },\n  );\n\n  chrome.notifications.create(notificationId, safeOptions, (createdId) => {\n    // Check for errors\n    if (chrome.runtime.lastError) {\n      debugLogger.notifications(\"ERROR\", \"Notification creation error\", {\n        error: chrome.runtime.lastError.message,\n        notificationId,\n      });\n    }\n\n    if (callback) callback(createdId);\n\n    // Auto-dismiss logic\n    try {\n      const timeout = timeoutMs !== undefined ? timeoutMs : 10000; // Default 10 seconds\n      if (typeof timeout === \"number\" && timeout > 0) {\n        setTimeout(() => {\n          chrome.notifications.clear(createdId || notificationId, () => {});\n        }, timeout);\n      }\n    } catch (error) {\n      debugLogger.notifications(\n        \"ERROR\",\n        \"Failed to set notification timeout\",\n        {\n          error: (error as Error).message,\n        },\n        error as Error,\n      );\n    }\n  });\n}\n\n/**\n * Check if we should show a disconnection notification\n */\nexport function checkDisconnectionNotification(): void {\n  const now = Date.now();\n  const timeSinceLastNotification = now - lastDisconnectionNotification;\n\n  // Only notify if cooldown period has passed\n  if (timeSinceLastNotification < DISCONNECTION_NOTIFICATION_COOLDOWN) {\n    debugLogger.general(\n      \"DEBUG\",\n      \"Disconnection notification suppressed - cooldown active\",\n      {\n        timeSinceLastNotification: `${Math.round(timeSinceLastNotification / 1000)}s`,\n        cooldownPeriod: `${DISCONNECTION_NOTIFICATION_COOLDOWN / 1000}s`,\n      },\n    );\n    return;\n  }\n\n  // Check if we've been disconnected for threshold period\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n  if (qualityMetrics.consecutiveFailures >= 3) {\n    showDisconnectionNotification();\n    lastDisconnectionNotification = now;\n  }\n}\n\n/**\n * Show disconnection notification\n */\nexport function showDisconnectionNotification(): void {\n  createNotificationWithTimeout(\n    \"pushbullet-disconnected\",\n    {\n      type: \"basic\",\n      iconUrl: \"icons/icon128.png\",\n      title: \"Pushbullet Connection Issue\",\n      message: \"Real-time push notifications may be delayed. Reconnecting...\",\n      priority: 1,\n    },\n    (notificationId) => {\n      debugLogger.general(\"INFO\", \"Disconnection notification shown\", {\n        notificationId,\n      });\n    },\n  );\n}\n\n/**\n * Show permanent WebSocket error notification\n */\nexport function showPermanentWebSocketError(closeInfo: {\n  code: number;\n  reason?: string;\n  wasClean?: boolean;\n}): void {\n  const title = \"Pushbullet requires attention\";\n  const message =\n    `Real-time connection stopped (code ${closeInfo.code}). ${closeInfo.reason || \"\"}`.trim();\n\n  createNotificationWithTimeout(\n    \"pushbullet-permanent-error\",\n    {\n      type: \"basic\",\n      iconUrl: \"icons/icon128.png\",\n      title,\n      message,\n      priority: 2,\n    },\n    () => {},\n  );\n\n  try {\n    chrome.action.setBadgeBackgroundColor({ color: \"#d93025\" });\n    chrome.action.setBadgeText({ text: \"ERR\" });\n  } catch (error) {\n    // Log badge setting errors - these are non-critical UI updates\n    debugLogger.general(\n      \"WARN\",\n      \"Failed to set error badge\",\n      null,\n      error as Error,\n    );\n  }\n}\n\n/**\n * Clear error badge\n */\nexport function clearErrorBadge(): void {\n  try {\n    chrome.action.setBadgeText({ text: \" \" });\n  } catch (error) {\n    // Log badge clearing errors - these are non-critical UI updates\n    debugLogger.general(\n      \"WARN\",\n      \"Failed to clear error badge\",\n      null,\n      error as Error,\n    );\n  }\n}\n", "/**\n * Event Bus Pattern\n * \n * This module implements a simple event bus for decoupling components.\n * Components can emit events without knowing who (if anyone) is listening.\n * \n * Benefits:\n * - Decoupling: Components don't need to know about each other\n * - Flexibility: Easy to add/remove listeners\n * - Testability: Easy to test components in isolation\n * \n * Example:\n * ```typescript\n * // Component A emits an event\n * globalEventBus.emit('user:login', { userId: 123 });\n * \n * // Component B listens for the event\n * globalEventBus.on('user:login', (data) => {\n *   console.log('User logged in:', data.userId);\n * });\n * ```\n */\n\n/**\n * Listener function type\n * Can receive optional data of any type\n */\ntype Listener = (data?: any) => void;\n\n/**\n * Event Bus Class\n * \n * Manages event listeners and event emission.\n * Uses a Map to store listeners for each event type.\n */\nclass EventBus {\n  /**\n   * Map of event names to sets of listener functions\n   * Using Set ensures each listener is only registered once\n   */\n  private listeners = new Map<string, Set<Listener>>();\n\n  /**\n   * Register a listener for an event\n   * \n   * @param event - Event name (e.g., 'websocket:connected')\n   * @param listener - Function to call when event is emitted\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.on('websocket:connected', () => {\n   *   console.log('WebSocket connected!');\n   * });\n   * ```\n   */\n  on(event: string, listener: Listener): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(listener);\n  }\n\n  /**\n   * Remove a listener for an event\n   * \n   * @param event - Event name\n   * @param listener - Listener function to remove\n   * \n   * @example\n   * ```typescript\n   * const handler = () => console.log('Connected');\n   * globalEventBus.on('websocket:connected', handler);\n   * globalEventBus.off('websocket:connected', handler);\n   * ```\n   */\n  off(event: string, listener: Listener): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n      // Clean up empty sets\n      if (eventListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n  }\n\n  /**\n   * Emit an event to all registered listeners\n   * \n   * @param event - Event name\n   * @param data - Optional data to pass to listeners\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.emit('websocket:message', { \n   *   type: 'push', \n   *   data: { title: 'Hello' } \n   * });\n   * ```\n   */\n  emit(event: string, data?: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      // Call each listener with the data\n      eventListeners.forEach(listener => {\n        try {\n          listener(data);\n        } catch (error) {\n          // Log errors but don't stop other listeners\n          console.error(`Error in event listener for '${event}':`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Register a one-time listener for an event\n   * The listener will be automatically removed after being called once\n   * \n   * @param event - Event name\n   * @param listener - Function to call when event is emitted\n   * \n   * @example\n   * ```typescript\n   * globalEventBus.once('websocket:connected', () => {\n   *   console.log('Connected for the first time!');\n   * });\n   * ```\n   */\n  once(event: string, listener: Listener): void {\n    const onceWrapper = (data?: any) => {\n      listener(data);\n      this.off(event, onceWrapper);\n    };\n    this.on(event, onceWrapper);\n  }\n\n  /**\n   * Remove all listeners for an event\n   * If no event is specified, removes all listeners for all events\n   * \n   * @param event - Optional event name. If not provided, clears all listeners\n   * \n   * @example\n   * ```typescript\n   * // Remove all listeners for a specific event\n   * globalEventBus.removeAllListeners('websocket:connected');\n   * \n   * // Remove all listeners for all events\n   * globalEventBus.removeAllListeners();\n   * ```\n   */\n  removeAllListeners(event?: string): void {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n  }\n\n  /**\n   * Get the number of listeners for an event\n   * \n   * @param event - Event name\n   * @returns Number of listeners registered for the event\n   * \n   * @example\n   * ```typescript\n   * const count = globalEventBus.listenerCount('websocket:connected');\n   * console.log(`${count} listeners registered`);\n   * ```\n   */\n  listenerCount(event: string): number {\n    const eventListeners = this.listeners.get(event);\n    return eventListeners ? eventListeners.size : 0;\n  }\n\n  /**\n   * Get all event names that have listeners\n   * \n   * @returns Array of event names\n   * \n   * @example\n   * ```typescript\n   * const events = globalEventBus.eventNames();\n   * console.log('Events with listeners:', events);\n   * ```\n   */\n  eventNames(): string[] {\n    return Array.from(this.listeners.keys());\n  }\n}\n\n/**\n * Global Event Bus Instance\n * \n * This is a singleton instance that the whole extension can use.\n * Import this in any module that needs to emit or listen for events.\n * \n * @example\n * ```typescript\n * import { globalEventBus } from './lib/events/event-bus';\n * \n * // Emit an event\n * globalEventBus.emit('user:action', { action: 'click' });\n * \n * // Listen for an event\n * globalEventBus.on('user:action', (data) => {\n *   console.log('User action:', data.action);\n * });\n * ```\n */\nexport const globalEventBus = new EventBus();\n\n/**\n * Event Bus Class Export\n * \n * Export the class for testing purposes or if you need to create\n * multiple event bus instances (though the global singleton is recommended)\n */\nexport { EventBus };\n\n", "import { performanceMonitor } from \"../../lib/perf\";\nimport { debugLogger, globalErrorTracker } from \"../../lib/logging\";\nimport { wsStateMonitor } from \"../../lib/monitoring\";\nimport { WS_READY_STATE } from \"../../types/domain\";\nimport { clearErrorBadge, showPermanentWebSocketError } from \"../notifications\";\nimport { globalEventBus } from \"../../lib/events/event-bus\";\n\nexport interface CloseInfo {\n  code: number;\n  reason?: string;\n  wasClean?: boolean;\n}\n\n/**\n * WebSocket client for Pushbullet streaming API\n *\n * ARCHITECTURAL CHANGE: Event-Driven Architecture\n * This class now uses the global event bus to emit events instead of\n * calling handler functions directly. This decouples the WebSocketClient\n * from the background script and makes it more flexible and testable.\n *\n * Events emitted:\n * - websocket:connected - When WebSocket connection is established\n * - websocket:disconnected - When WebSocket connection is closed\n * - websocket:message - When a message is received\n * - websocket:tickle:push - When a push tickle is received\n * - websocket:tickle:device - When a device tickle is received\n * - websocket:push - When a push is received\n * - websocket:polling:check - When polling mode should be checked\n * - websocket:polling:stop - When polling mode should be stopped\n * - websocket:state - When connection state changes (for popup)\n */\nexport class WebSocketClient {\n  private static readonly NOP_TIMEOUT = 60000; // 60 seconds\n\n  private socket: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;\n  private lastNopAt: number = 0;\n\n  constructor(\n    private websocketUrl: string,\n    private getApiKey: () => string | null,\n  ) {}\n\n  /**\n   * Get current WebSocket instance\n   */\n  getSocket(): WebSocket | null {\n    return this.socket;\n  }\n\n  /**\n   * Get current ready state\n   */\n  getReadyState(): number {\n    return this.socket?.readyState ?? WebSocket.CLOSED;\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return (\n      this.socket !== null && this.socket.readyState === WS_READY_STATE.OPEN\n    );\n  }\n\n  /**\n   * Connect to WebSocket\n   */\n  connect(): void {\n    try {\n      const apiKey = this.getApiKey();\n      if (!apiKey) {\n        debugLogger.websocket(\"WARN\", \"connectWebSocket called without apiKey\");\n        return;\n      }\n\n      // If already open, do nothing\n      if (this.socket && this.socket.readyState === WS_READY_STATE.OPEN) {\n        debugLogger.websocket(\"DEBUG\", \"WebSocket already open\");\n        return;\n      }\n\n      // Fix WebSocket URL construction - Pushbullet uses simple concatenation\n      const url = this.websocketUrl + apiKey;\n\n      // CRITICAL: Log the exact URL being constructed (without exposing full API key)\n      debugLogger.websocket(\"INFO\", \"WebSocket URL construction debug\", {\n        baseUrl: this.websocketUrl,\n        apiKeyLength: apiKey.length,\n        apiKeyPrefix: apiKey.substring(0, 8) + \"...\",\n        finalUrlLength: url.length,\n        urlPattern: this.websocketUrl + \"***\",\n      });\n      debugLogger.websocket(\"INFO\", \"Connecting to WebSocket\", {\n        url: this.websocketUrl + \"***\",\n        reconnectAttempts: this.reconnectAttempts,\n        currentSocketState: this.socket\n          ? this.socket.readyState\n          : \"no_existing_socket\",\n        apiKeyPresent: !!apiKey,\n      });\n      this.reconnectAttempts = 0;\n\n      // Log pre-creation state\n      debugLogger.websocket(\"DEBUG\", \"About to create WebSocket object\", {\n        url: this.websocketUrl + \"***\",\n        currentSocketExists: !!this.socket,\n        currentSocketState: this.socket ? this.socket.readyState : \"null\",\n      });\n\n      try {\n        this.socket = new WebSocket(url);\n        debugLogger.websocket(\n          \"DEBUG\",\n          \"WebSocket object created successfully\",\n          {\n            url: this.websocketUrl + \"***\",\n            readyState: this.socket.readyState,\n            urlLength: url.length,\n          },\n        );\n      } catch (createError) {\n        debugLogger.websocket(\"ERROR\", \"Failed to create WebSocket object\", {\n          url: this.websocketUrl + \"***\",\n          error:\n            createError instanceof Error\n              ? createError.message\n              : String(createError),\n          errorType: createError?.constructor?.name,\n          timestamp: new Date().toISOString(),\n        });\n        // Reset socket to null on creation failure\n        this.socket = null;\n        throw createError;\n      }\n\n      debugLogger.websocket(\"DEBUG\", \"Setting up WebSocket event handlers\", {\n        url: this.websocketUrl + \"***\",\n        readyState: this.socket.readyState,\n        socketExists: !!this.socket,\n      });\n\n      this.socket.onopen = () => {\n        debugLogger.websocket(\"INFO\", \"WebSocket connection established\", {\n          timestamp: new Date().toISOString(),\n        });\n\n        this.lastNopAt = Date.now();\n        performanceMonitor.recordWebSocketConnection(true);\n        wsStateMonitor.startMonitoring();\n\n        // Emit event to stop polling mode\n        globalEventBus.emit(\"websocket:polling:stop\");\n\n        try {\n          clearErrorBadge();\n        } catch {\n          // noop\n        }\n\n        // Emit connected event\n        globalEventBus.emit(\"websocket:connected\");\n\n        // Emit state change for popup\n        globalEventBus.emit(\"websocket:state\", \"connected\");\n      };\n\n      this.socket.onmessage = (ev) => {\n        const msg = JSON.parse(ev.data);\n        globalEventBus.emit(\"websocket:message\", msg);\n        if (msg.type === \"nop\") {\n          this.lastNopAt = Date.now();\n          debugLogger.websocket(\"DEBUG\", \"Server nop received\", { timestamp: new Date(this.lastNopAt).toISOString() });\n        }\n        if (msg.type === \"tickle\") {\n          if (msg.subtype === \"push\") {\n            globalEventBus.emit(\"websocket:tickle:push\");\n          } else if (msg.subtype === \"device\") {\n            globalEventBus.emit(\"websocket:tickle:device\");\n          }\n        }\n        if (msg.type === \"push\") {\n          if (\"push\" in msg && msg.push) {\n            globalEventBus.emit(\"websocket:push\", msg.push);\n          } else {\n            debugLogger.websocket(\n              \"WARN\",\n              \"Push message received without push payload\",\n            );\n          }\n        }\n      };\n\n      this.socket.onerror = (error) => {\n        // WebSocket error events are generic Event objects, not Error instances\n        // This can occur during connection attempt, socket creation, or network issues\n        // CRITICAL: This error handler might be called when this.socket is null or undefined\n\n        const currentSocket = this.socket; // Local reference to avoid race conditions\n        const socketExists = !!currentSocket;\n        const socketState = socketExists\n          ? currentSocket.readyState\n          : \"no_socket\";\n        const isConnecting = socketExists\n          ? currentSocket.readyState === WS_READY_STATE.CONNECTING\n          : false;\n        const isConnected = socketExists\n          ? currentSocket.readyState === WS_READY_STATE.OPEN\n          : false;\n\n        const errorInfo = {\n          type: (error as any).type || \"unknown\",\n          target: (error as any).target ? \"WebSocket\" : \"unknown\",\n          readyState: socketState,\n          socketExists: socketExists,\n          url: this.websocketUrl,\n          timestamp: new Date().toISOString(),\n          reconnectAttempts: this.reconnectAttempts,\n          // Additional debugging info\n          isConnecting: isConnecting,\n          isConnected: isConnected,\n          errorEventDetails: {\n            timeStamp: (error as any).timeStamp,\n            bubbles: (error as any).bubbles,\n            cancelable: (error as any).cancelable,\n            currentTarget: (error as any).currentTarget\n              ? \"WebSocket\"\n              : \"unknown\",\n          },\n        };\n\n        debugLogger.websocket(\"ERROR\", \"WebSocket error occurred\", errorInfo);\n\n        // Create a proper Error object for tracking\n        const websocketError = new Error(\n          `WebSocket connection error: ${errorInfo.type} (socket: ${socketExists ? \"exists\" : \"null\"}, state: ${socketState})`,\n        );\n        websocketError.name = \"WebSocketError\";\n        globalErrorTracker.trackError(\n          websocketError,\n          {\n            category: \"WEBSOCKET\",\n            message: \"WebSocket error occurred\",\n            data: errorInfo,\n          },\n          \"WEBSOCKET\",\n        );\n      };\n\n      this.socket.onclose = (event) => {\n        const closeInfo: CloseInfo = {\n          code: event.code,\n          reason: event.reason || \"No reason provided\",\n          wasClean: event.wasClean,\n        };\n\n        debugLogger.websocket(\"WARN\", \"WebSocket connection closed\", {\n          ...closeInfo,\n          timestamp: new Date().toISOString(),\n          reconnectAttempts: this.reconnectAttempts,\n        });\n\n        // Emit disconnected event\n        globalEventBus.emit(\"websocket:disconnected\", {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean,\n        });\n\n        // Emit state change for popup\n        globalEventBus.emit(\"websocket:state\", \"disconnected\");\n\n        // Permanent error: stop and notify\n        if (\n          event.code === 1008 ||\n          event.code === 4001 ||\n          (event.code >= 4000 && event.code < 5000)\n        ) {\n          debugLogger.websocket(\n            \"ERROR\",\n            \"Permanent WebSocket error - stopping reconnection attempts\",\n            closeInfo,\n          );\n          try {\n            showPermanentWebSocketError(closeInfo);\n          } catch {\n            // noop\n          }\n          return;\n        }\n      };\n    } catch (error) {\n      debugLogger.websocket(\n        \"ERROR\",\n        \"Failed to create WebSocket connection\",\n        {\n          url: this.websocketUrl + \"***\",\n          hasApiKey: !!this.getApiKey(),\n        },\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnect(): void {\n    if (this.socket) {\n      try {\n        debugLogger.websocket(\"INFO\", \"Disconnecting WebSocket\", {\n          readyState: this.socket.readyState,\n        });\n\n        this.socket.close();\n        this.socket = null;\n\n        wsStateMonitor.stopMonitoring();\n      } catch (error) {\n        debugLogger.websocket(\n          \"ERROR\",\n          \"Error disconnecting WebSocket\",\n          null,\n          error as Error,\n        );\n      }\n    }\n  }\n\n  /**\n   * Get reconnect attempts count\n   */\n  getReconnectAttempts(): number {\n    return this.reconnectAttempts;\n  }\n\n  /**\n   * Reset reconnect attempts\n   */\n  resetReconnectAttempts(): void {\n    this.reconnectAttempts = 0;\n  }\n\n  public isConnectionHealthy(): boolean {\n    const NOP_TIMEOUT_MS = 60000; // 60s window\n    if (this.socket?.readyState !== WS_READY_STATE.OPEN) return false; // must be OPEN\n    const age = Date.now() - this.lastNopAt;\n    return age >= 0 && age <= NOP_TIMEOUT_MS; // recent nop seen\n  }\n}\n", "/**\r\n * Storage Repository Pattern\r\n * \r\n * This module implements the Repository Pattern for storage operations.\r\n * It abstracts away the chrome.storage API, making the code more testable\r\n * and maintainable.\r\n * \r\n * Benefits:\r\n * - Testability: Easy to mock storage in tests\r\n * - Maintainability: Storage logic centralized in one place\r\n * - Clarity: Simple, clear API for storage operations\r\n */\r\n\r\n/**\r\n * Storage Repository Interface\r\n * \r\n * This interface defines the contract for storage operations.\r\n * Any implementation must provide these methods.\r\n */\r\nexport interface StorageRepository {\r\n  // API Key\r\n  getApiKey(): Promise<string | null>;\r\n  setApiKey(key: string | null): Promise<void>;\r\n\r\n  // Device Information\r\n  getDeviceIden(): Promise<string | null>;\r\n  setDeviceIden(iden: string | null): Promise<void>;\r\n\r\n  getDeviceNickname(): Promise<string | null>;\r\n  setDeviceNickname(nickname: string): Promise<void>;\r\n\r\n  // Settings\r\n  getAutoOpenLinks(): Promise<boolean>;\r\n  setAutoOpenLinks(enabled: boolean): Promise<void>;\r\n\r\n  getNotificationTimeout(): Promise<number>;\r\n  setNotificationTimeout(timeout: number): Promise<void>;\r\n\r\n  getOnlyThisDevice(): Promise<boolean>;\r\n  setOnlyThisDevice(value: boolean): Promise<void>;\r\n\r\n  // Encryption\r\n  getEncryptionPassword(): Promise<string | null>;\r\n  setEncryptionPassword(password: string | null): Promise<void>;\r\n\r\n  // UI State\r\n  getScrollToRecentPushes(): Promise<boolean>;\r\n  setScrollToRecentPushes(scroll: boolean): Promise<void>;\r\n  removeScrollToRecentPushes(): Promise<void>;\r\n\r\n  // Device Registration\r\n  getDeviceRegistrationInProgress(): Promise<boolean>;\r\n  setDeviceRegistrationInProgress(inProgress: boolean): Promise<void>;\r\n\r\n  // Last Modified Cutoff\r\n  getLastModifiedCutoff(): Promise<number | null>;\r\n  setLastModifiedCutoff(value: number): Promise<void>;\r\n  removeLastModifiedCutoff(): Promise<void>;\r\n\r\n  // Auto Open Links on Reconnect\r\n  getLastAutoOpenCutoff(): Promise<number | null>;\r\n  setLastAutoOpenCutoff(value: number): Promise<void>;\r\n  getAutoOpenLinksOnReconnect(): Promise<boolean>;\r\n  setAutoOpenLinksOnReconnect(value: boolean): Promise<void>;\r\n  getMaxAutoOpenPerReconnect(): Promise<number>;\r\n  setMaxAutoOpenPerReconnect(value: number): Promise<void>;\r\n  getDismissAfterAutoOpen(): Promise<boolean>;\r\n  setDismissAfterAutoOpen(value: boolean): Promise<void>;\r\n\r\n  // User Info Cache\r\n  getUserInfoCache(): Promise<any | null>;\r\n  setUserInfoCache(value: any): Promise<void>;\r\n\r\n  // Bulk Operations\r\n  clear(): Promise<void>;\r\n  remove(keys: string[]): Promise<void>;\r\n\r\n  // Diagnostics\r\n  getAutoOpenDebugSnapshot(): Promise<{\r\n    lastAutoOpenCutoff: number;\r\n    lastModifiedCutoff: number;\r\n    mruCount: number;\r\n    maxOpenedCreated: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Chrome Storage Repository Implementation\r\n * \r\n * This class implements the StorageRepository interface using the\r\n * chrome.storage API. It handles the promisification of the callback-based\r\n * chrome.storage API.\r\n */\r\nexport class ChromeStorageRepository implements StorageRepository {\r\n  /**\r\n   * Get API Key from local storage\r\n   * Security: API keys are stored in local storage (not synced) to prevent\r\n   * exposure through Chrome's sync infrastructure\r\n   */\r\n  async getApiKey(): Promise<string | null> {\r\n    const result = await chrome.storage.local.get(['apiKey']);\r\n    return result.apiKey || null;\r\n  }\r\n\r\n  /**\r\n   * Set API Key in local storage\r\n   * Security: API keys are stored in local storage (not synced) to prevent\r\n   * exposure through Chrome's sync infrastructure\r\n   */\r\n  async setApiKey(key: string | null): Promise<void> {\r\n    if (key === null) {\r\n      await chrome.storage.local.remove(['apiKey']);\r\n    } else {\r\n      await chrome.storage.local.set({ apiKey: key });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Device Identifier from local storage\r\n   */\r\n  async getDeviceIden(): Promise<string | null> {\r\n    const result = await chrome.storage.local.get(['deviceIden']);\r\n    return result.deviceIden || null;\r\n  }\r\n\r\n  /**\r\n   * Set Device Identifier in local storage\r\n   */\r\n  async setDeviceIden(iden: string | null): Promise<void> {\r\n    if (iden === null) {\r\n      await chrome.storage.local.remove(['deviceIden']);\r\n    } else {\r\n      await chrome.storage.local.set({ deviceIden: iden });\r\n    }\r\n  }\r\n\r\n  /**\r\n    * Get Device Nickname from local storage\r\n    */\r\n  async getDeviceNickname(): Promise<string | null> {\r\n    const result = await chrome.storage.local.get(['deviceNickname']);\r\n    return result.deviceNickname || null;\r\n  }\r\n\r\n  /**\r\n    * Set Device Nickname in local storage\r\n    */\r\n  async setDeviceNickname(nickname: string): Promise<void> {\r\n    await chrome.storage.local.set({ deviceNickname: nickname });\r\n  }\r\n\r\n  /**\r\n   * Get Auto Open Links setting from sync storage\r\n   */\r\n  async getAutoOpenLinks(): Promise<boolean> {\r\n    const result = await chrome.storage.sync.get(['autoOpenLinks']);\r\n    return result.autoOpenLinks !== undefined ? result.autoOpenLinks : false;\r\n  }\r\n\r\n  /**\r\n   * Set Auto Open Links setting in sync storage\r\n   */\r\n  async setAutoOpenLinks(enabled: boolean): Promise<void> {\r\n    await chrome.storage.sync.set({ autoOpenLinks: enabled });\r\n  }\r\n\r\n  /**\r\n   * Get Notification Timeout from sync storage\r\n   */\r\n  async getNotificationTimeout(): Promise<number> {\r\n    const result = await chrome.storage.sync.get(['notificationTimeout']);\r\n    return result.notificationTimeout !== undefined ? result.notificationTimeout : 5000;\r\n  }\r\n\r\n  /**\r\n   * Set Notification Timeout in sync storage\r\n   */\r\n  async setNotificationTimeout(timeout: number): Promise<void> {\r\n    await chrome.storage.sync.set({ notificationTimeout: timeout });\r\n  }\r\n\r\n  /**\r\n   * Get Only This Device setting from sync storage\r\n   */\r\n  async getOnlyThisDevice(): Promise<boolean> {\r\n    const result = await chrome.storage.sync.get(['onlyThisDevice']);\r\n    return result.onlyThisDevice !== undefined ? result.onlyThisDevice : false;\r\n  }\r\n\r\n  /**\r\n   * Set Only This Device setting in sync storage\r\n   */\r\n  async setOnlyThisDevice(value: boolean): Promise<void> {\r\n    await chrome.storage.sync.set({ onlyThisDevice: value });\r\n  }\r\n\r\n  /**\n   * Get Encryption Password from local storage\n   */\n  async getEncryptionPassword(): Promise<string | null> {\n    const result = await chrome.storage.local.get(['encryptionPassword']);\r\n    return result.encryptionPassword || null;\r\n  }\r\n\r\n  /**\r\n   * Set Encryption Password in local storage\r\n   */\r\n  async setEncryptionPassword(password: string | null): Promise<void> {\r\n    if (password === null) {\r\n      await chrome.storage.local.remove(['encryptionPassword']);\r\n    } else {\r\n      await chrome.storage.local.set({ encryptionPassword: password });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Scroll to Recent Pushes flag from local storage\r\n   */\r\n  async getScrollToRecentPushes(): Promise<boolean> {\r\n    const result = await chrome.storage.local.get(['scrollToRecentPushes']);\r\n    return result.scrollToRecentPushes || false;\r\n  }\r\n\r\n  /**\r\n   * Set Scroll to Recent Pushes flag in local storage\r\n   */\r\n  async setScrollToRecentPushes(scroll: boolean): Promise<void> {\r\n    await chrome.storage.local.set({ scrollToRecentPushes: scroll });\r\n  }\r\n\r\n  /**\r\n   * Remove Scroll to Recent Pushes flag from local storage\r\n   */\r\n  async removeScrollToRecentPushes(): Promise<void> {\r\n    await chrome.storage.local.remove(['scrollToRecentPushes']);\r\n  }\r\n\r\n  /**\r\n   * Get Device Registration In Progress flag from local storage\r\n   */\r\n  async getDeviceRegistrationInProgress(): Promise<boolean> {\r\n    const result = await chrome.storage.local.get(['deviceRegistrationInProgress']);\r\n    return result.deviceRegistrationInProgress || false;\r\n  }\r\n\r\n  /**\r\n   * Set Device Registration In Progress flag in local storage\r\n   */\r\n  async setDeviceRegistrationInProgress(inProgress: boolean): Promise<void> {\r\n    await chrome.storage.local.set({ deviceRegistrationInProgress: inProgress });\r\n  }\r\n\r\n  /**\r\n   * Get Last Modified Cutoff from local storage\r\n   */\r\n  async getLastModifiedCutoff(): Promise<number | null> {\r\n    const result = await chrome.storage.local.get(['lastModifiedCutoff']);\r\n    const cutoff = result.lastModifiedCutoff;\r\n    return typeof cutoff === 'number' ? cutoff : null;\r\n  }\r\n\r\n  /**\r\n   * Set Last Modified Cutoff in local storage\r\n   */\r\n  async setLastModifiedCutoff(value: number): Promise<void> {\r\n    if (value === 0) {\r\n      console.warn('Storage: Setting lastModifiedCutoff to 0 - ensure this is via unsafe setter');\r\n    }\r\n    await chrome.storage.local.set({ lastModifiedCutoff: value });\r\n  }\r\n\r\n  /**\r\n   * Remove Last Modified Cutoff from local storage\r\n   * Used during invalid cursor recovery\r\n   */\r\n  async removeLastModifiedCutoff(): Promise<void> {\r\n    await chrome.storage.local.remove('lastModifiedCutoff');\r\n  }\r\n\r\n  /**\r\n   * Get Last Auto Open Cutoff from local storage\r\n   */\r\n  async getLastAutoOpenCutoff(): Promise<number | null> {\r\n    const result = await chrome.storage.local.get(['lastAutoOpenCutoff']);\r\n    const v = result.lastAutoOpenCutoff;\r\n    return typeof v === 'number' ? v : null;\r\n  }\r\n\r\n  /**\r\n   * Set Last Auto Open Cutoff in local storage\r\n   */\r\n  async setLastAutoOpenCutoff(value: number): Promise<void> {\r\n    await chrome.storage.local.set({ lastAutoOpenCutoff: value });\r\n  }\r\n\r\n  /**\r\n   * Get Auto Open Links on Reconnect setting from local storage\r\n   */\r\n  async getAutoOpenLinksOnReconnect(): Promise<boolean> {\r\n    const result = await chrome.storage.local.get(['autoOpenLinksOnReconnect']);\r\n    const v = result.autoOpenLinksOnReconnect;\r\n    return typeof v === 'boolean' ? v : false;\r\n  }\r\n\r\n  /**\r\n   * Set Auto Open Links on Reconnect setting in local storage\r\n   */\r\n  async setAutoOpenLinksOnReconnect(value: boolean): Promise<void> {\r\n    await chrome.storage.local.set({ autoOpenLinksOnReconnect: value });\r\n  }\r\n\r\n  /**\r\n   * Get Max Auto Open Per Reconnect from local storage\r\n   */\r\n  async getMaxAutoOpenPerReconnect(): Promise<number> {\r\n    const result = await chrome.storage.local.get(['maxAutoOpenPerReconnect']);\r\n    const v = result.maxAutoOpenPerReconnect;\r\n    return typeof v === 'number' && v > 0 ? v : 5;\r\n  }\r\n\r\n  /**\r\n   * Set Max Auto Open Per Reconnect in local storage\r\n   */\r\n  async setMaxAutoOpenPerReconnect(value: number): Promise<void> {\r\n    await chrome.storage.local.set({ maxAutoOpenPerReconnect: value });\r\n  }\r\n\r\n  /**\r\n   * Get Dismiss After Auto Open setting from local storage\r\n   */\r\n  async getDismissAfterAutoOpen(): Promise<boolean> {\r\n    const result = await chrome.storage.local.get(['dismissAfterAutoOpen']);\r\n    return Boolean(result.dismissAfterAutoOpen);\r\n  }\r\n\r\n  /**\r\n   * Set Dismiss After Auto Open setting in local storage\r\n   */\r\n  async setDismissAfterAutoOpen(value: boolean): Promise<void> {\r\n    await chrome.storage.local.set({ dismissAfterAutoOpen: value });\r\n  }\r\n\r\n  /**\r\n   * Get User Info Cache from local storage\r\n   */\r\n  async getUserInfoCache(): Promise<any | null> {\r\n    const result = await chrome.storage.local.get(['userInfoCache']);\r\n    return result.userInfoCache || null;\r\n  }\r\n\r\n  /**\r\n   * Set User Info Cache in local storage\r\n   */\r\n  async setUserInfoCache(value: any): Promise<void> {\r\n    await chrome.storage.local.set({ userInfoCache: value });\r\n  }\r\n\r\n  /**\r\n   * Clear all storage (both sync and local)\r\n   */\r\n  async clear(): Promise<void> {\r\n    await Promise.all([\r\n      chrome.storage.sync.clear(),\r\n      chrome.storage.local.clear()\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Remove specific keys from storage\r\n   * Removes from both sync and local storage\r\n   */\r\n  async remove(keys: string[]): Promise<void> {\r\n    await Promise.all([\r\n      chrome.storage.sync.remove(keys),\r\n      chrome.storage.local.remove(keys)\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Get Auto Open Debug Snapshot for diagnostics\r\n   */\r\n  async getAutoOpenDebugSnapshot(): Promise<{\r\n    lastAutoOpenCutoff: number;\r\n    lastModifiedCutoff: number;\r\n    mruCount: number;\r\n    maxOpenedCreated: number;\r\n  }> {\r\n    const { lastAutoOpenCutoff = 0 } =\r\n      await chrome.storage.local.get('lastAutoOpenCutoff');\r\n    const { lastModifiedCutoff = 0 } =\r\n      await chrome.storage.local.get('lastModifiedCutoff');\r\n    const raw = await chrome.storage.local.get('openedPushMRU');\r\n    const mru = raw.openedPushMRU as\r\n      | { idens?: string[]; maxOpenedCreated?: number }\r\n      | undefined;\r\n    return {\r\n      lastAutoOpenCutoff:\r\n        typeof lastAutoOpenCutoff === 'number' ? lastAutoOpenCutoff : 0,\r\n      lastModifiedCutoff:\r\n        typeof lastModifiedCutoff === 'number' ? lastModifiedCutoff : 0,\r\n      mruCount: Array.isArray(mru?.idens) ? mru!.idens!.length : 0,\r\n      maxOpenedCreated:\r\n        typeof mru?.maxOpenedCreated === 'number' ? mru!.maxOpenedCreated! : 0,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a singleton instance of the storage repository\r\n * This ensures we have a single point of access throughout the application\r\n */\r\nexport const storageRepository = new ChromeStorageRepository();\r\n\r\n", "export async function fetchWithTimeout(input: RequestInfo, init: RequestInit = {}, timeoutMs = 5000): Promise<Response> {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeoutMs);\n  try {\n    return await fetch(input, { ...init, signal: controller.signal });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nexport async function retry<T>(fn: () => Promise<T>, retries = 1, backoffMs = 300): Promise<T> {\n  let lastErr: unknown;\n  for (let i = 0; i <= retries; i++) {\n    try { return await fn(); } catch (e) {\n      lastErr = e;\n      if (i < retries) await new Promise(r => setTimeout(r, backoffMs * (i + 1)));\n    }\n  }\n  throw lastErr;\n}\n\n/**\n * Check if an API error response indicates an invalid cursor\n *\n * Pushbullet API returns specific error when cursor is invalid:\n * - HTTP 400 or 410\n * - Error message contains \"cursor\" or \"invalid\"\n */\nexport function isInvalidCursorError(response: Response, errorData?: any): boolean {\n  // Check HTTP status codes\n  if (response.status === 400 || response.status === 410) {\n    // Check error message for cursor-related keywords\n    const errorMessage = errorData?.error?.message || errorData?.message || '';\n    const lowerMessage = errorMessage.toLowerCase();\n\n    return lowerMessage.includes('cursor') ||\n           lowerMessage.includes('invalid') ||\n           lowerMessage.includes('expired');\n  }\n\n  return false;\n}", "/**\n * Push Type Support Module\n * Centralizes logic for checking which push types are supported.\n */\n\nimport { debugLogger } from \"../lib/logging\";\n\n/**\n * Push types that are fully supported and can be displayed in the extension.\n */\nexport const SUPPORTED_PUSH_TYPES: readonly string[] = [\n  \"note\",\n  \"link\",\n  \"mirror\",\n  \"sms_changed\",\n  \"file\",\n] as const;\n\n/**\n * Push types that are known but explicitly not supported.\n */\nexport const KNOWN_UNSUPPORTED_TYPES: readonly string[] = [\n  \"dismissal\",\n  \"clip\",\n  \"ephemeral\",\n  \"channel\",\n] as const;\n\n/**\n * Result of checking push type support.\n */\nexport interface PushTypeSupportResult {\n  supported: boolean;\n  category: \"supported\" | \"known-unsupported\" | \"unknown\";\n}\n\n/**\n * Check if a push type is supported by the extension.\n */\nexport function checkPushTypeSupport(pushType: string): PushTypeSupportResult {\n  if (SUPPORTED_PUSH_TYPES.includes(pushType)) {\n    return { supported: true, category: \"supported\" };\n  }\n\n  if (KNOWN_UNSUPPORTED_TYPES.includes(pushType)) {\n    return { supported: false, category: \"known-unsupported\" };\n  }\n\n  return { supported: false, category: \"unknown\" };\n}\n\n/**\n * Log a warning for an unsupported push type.\n *\n * @param pushType - The type of the push\n * @param pushIden - The push identifier\n * @param source - Where the push was encountered (e.g., 'fetchRecentPushes', 'websocket')\n * @param fullPush - Optional full push data for unknown types\n */\nexport function logUnsupportedPushType(\n  pushType: string,\n  pushIden: string,\n  source: string,\n  fullPush?: any,\n): void {\n  const typeCheck = checkPushTypeSupport(pushType);\n\n  if (typeCheck.category === \"known-unsupported\") {\n    debugLogger.general(\"WARN\", \"Encountered known unsupported push type\", {\n      pushType,\n      pushIden,\n      source,\n      category: typeCheck.category,\n      reason: \"This push type is not supported by the extension\",\n      supportedTypes: SUPPORTED_PUSH_TYPES,\n    });\n  } else if (typeCheck.category === \"unknown\") {\n    debugLogger.general(\"WARN\", \"Encountered unknown push type\", {\n      pushType,\n      pushIden,\n      source,\n      category: typeCheck.category,\n      reason: \"This is a new or unrecognized push type\",\n      supportedTypes: SUPPORTED_PUSH_TYPES,\n      // Include full push data for unknown types\n      fullPushData: fullPush,\n    });\n  }\n}\n", "import type { Chat, User, Device, Push, DevicesResponse, PushesResponse } from \"../../types/domain\";\r\nimport { debugLogger } from \"../../lib/logging\";\r\nimport { storageRepository } from \"../../infrastructure/storage/storage.repository\";\r\nimport { fetchWithTimeout, retry, isInvalidCursorError } from \"./http\";\r\nimport { checkPushTypeSupport, logUnsupportedPushType } from \"../push-types\";\r\n\r\nconst API_BASE_URL = 'https://api.pushbullet.com/v2';\r\nconst PUSHES_URL = `${API_BASE_URL}/pushes`;\r\nconst DEVICES_URL = `${API_BASE_URL}/devices`;\r\nconst USER_INFO_URL = `${API_BASE_URL}/users/me`;\r\n\r\ntype HeadersInit = Record<string, string>;\r\n\r\n// Promise singleton for device registration to prevent race conditions\r\nlet registrationPromise: Promise<{ deviceIden: string; needsUpdate: boolean }> | null = null;\r\n\r\nfunction authHeaders(apiKey: string): HeadersInit {\r\n  return { 'Access-Token': apiKey };\r\n}\r\n\r\nexport async function fetchUserInfoWithTimeout(apiKey: string): Promise<User> {\r\n  const response = await fetchWithTimeout(USER_INFO_URL, { headers: authHeaders(apiKey) }, 5000);\r\n  if (!response.ok) {\r\n    const errorText = await response.text().catch(() => 'Unknown error');\r\n    throw new Error(`Failed to fetch user info: ${response.status} ${response.statusText} - ${errorText}`);\r\n  }\r\n  return response.json();\r\n}\r\n\r\nexport async function getUserInfoWithTimeoutRetry(apiKey: string): Promise<User> {\r\n  return retry(() => fetchUserInfoWithTimeout(apiKey), 1, 500); // 1 retry with 500ms backoff\r\n}\r\n\r\nexport async function fetchUserInfo(apiKey: string): Promise<User> {\r\n  const startTime = Date.now();\r\n  debugLogger.api('INFO', 'Fetching user info', { url: USER_INFO_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\r\n\r\n  try {\r\n    const response = await fetch(USER_INFO_URL, { headers: authHeaders(apiKey) });\r\n    const duration = Date.now() - startTime;\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text().catch(() => 'Unknown error');\r\n      const error = new Error(`Failed to fetch user info: ${response.status} ${response.statusText} - ${errorText}`);\r\n      debugLogger.api('ERROR', 'User info fetch failed', {\r\n        url: USER_INFO_URL,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        duration: `${duration}ms`,\r\n        errorText\r\n      }, error);\r\n      throw error;\r\n    }\r\n\r\n    const data = await response.json();\r\n    debugLogger.api('INFO', 'User info fetched successfully', {\r\n      url: USER_INFO_URL,\r\n      status: response.status,\r\n      duration: `${duration}ms`,\r\n      userEmail: data.email ? data.email.substring(0, 3) + '***' : 'unknown',\r\n      userName: data.name || 'unknown'\r\n    });\r\n    return data;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    debugLogger.api('ERROR', 'User info fetch error', {\r\n      url: USER_INFO_URL,\r\n      duration: `${duration}ms`,\r\n      error: (error as Error).message\r\n    }, error as Error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function fetchDevices(apiKey: string): Promise<Device[]> {\r\n  const startTime = Date.now();\r\n  debugLogger.api('INFO', 'Fetching devices', { url: DEVICES_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\r\n\r\n  try {\r\n    const response = await fetch(`${DEVICES_URL}?active=true`, { headers: authHeaders(apiKey) });\r\n    const duration = Date.now() - startTime;\r\n\r\n    if (!response.ok) {\r\n      const error = new Error(`Failed to fetch devices: ${response.status} ${response.statusText}`);\r\n      debugLogger.api('ERROR', 'Devices fetch failed', {\r\n        url: DEVICES_URL,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        duration: `${duration}ms`\r\n      }, error);\r\n      throw error;\r\n    }\r\n\r\n    const data: DevicesResponse = await response.json();\r\n    const allDevices = data.devices; // Include inactive mobiles for \"Send to\"\r\n    \r\n    // Log EVERY device name/details\r\n    allDevices.forEach((device, index) => {\r\n      const displayName = device.nickname || `${device.manufacturer || ''} ${device.model || device.type || ''}`.trim() || 'Unknown Device';\r\n      debugLogger.general('INFO', `[DEVICE_NAME] #${index + 1}/${allDevices.length}: \"${displayName}\"`, {\r\n        iden: device.iden,\r\n        nickname: device.nickname || '(none)',\r\n        model: device.model || '(none)',\r\n        manufacturer: device.manufacturer || '(none)',\r\n        type: device.type || '(none)',\r\n        active: device.active\r\n      });\r\n    });\r\n    \r\n    // Filter ghosts (no truthy identifying fields)\r\n    const validDevices = allDevices.filter(device => \r\n      device.nickname || device.model || device.manufacturer || device.type\r\n    );\r\n    \r\n    debugLogger.api('INFO', 'Devices fetched successfully', {\r\n      url: DEVICES_URL,\r\n      status: response.status,\r\n      duration: `${duration}ms`,\r\n      totalDevices: data.devices.length,\r\n      validDevices: validDevices.length,\r\n      ghostDevices: data.devices.length - validDevices.length,\r\n      activeDevices: validDevices.filter(d => d.active).length,\r\n      inactiveDevices: validDevices.filter(d => !d.active).length\r\n    });\r\n    return validDevices;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    debugLogger.api('ERROR', 'Devices fetch error', {\r\n      url: DEVICES_URL,\r\n      duration: `${duration}ms`,\r\n      error: (error as Error).message\r\n    }, error as Error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function fetchRecentPushes(\r\n  apiKey: string,\r\n  limit: number = 20\r\n): Promise<Push[]> {\r\n  const startTime = Date.now();\r\n  const url = `${PUSHES_URL}?limit=${limit}`;\r\n  debugLogger.api('INFO', 'Fetching recent pushes', { url, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\r\n\r\n  try {\r\n    const response = await fetch(url, { headers: authHeaders(apiKey) });\r\n    const duration = Date.now() - startTime;\r\n\r\n    if (!response.ok) {\r\n      const error = new Error(`Failed to fetch pushes: ${response.status} ${response.statusText}`);\r\n      debugLogger.api('ERROR', 'Pushes fetch failed', {\r\n        url,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        duration: `${duration}ms`\r\n      }, error);\r\n      throw error;\r\n    }\r\n\r\n    const data: PushesResponse = await response.json();\r\n    const filteredPushes = data.pushes.filter(push => {\r\n      // Check if dismissed\r\n      if (push.dismissed) {\r\n        return false; // Filter out dismissed pushes\r\n      }\r\n\r\n      // Check if push type is supported\r\n      const typeCheck = checkPushTypeSupport(push.type);\r\n      if (!typeCheck.supported) {\r\n        logUnsupportedPushType(push.type, push.iden || \"unknown\", \"fetchRecentPushes\");\r\n        return false;\r\n      }\r\n\r\n      // Check if push has displayable content\r\n      const hasContent =\r\n        ('title' in push && push.title) ||\r\n        ('body' in push && push.body) ||\r\n        ('url' in push && push.url) ||\r\n        ('file_name' in push && push.file_name) ||\r\n        ('file_url' in push && push.file_url);\r\n      return hasContent;\r\n    });\r\n    debugLogger.api('INFO', 'Pushes fetched successfully', {\r\n      url,\r\n      status: response.status,\r\n      duration: `${duration}ms`,\r\n      totalPushes: data.pushes.length,\r\n      filteredPushes: filteredPushes.length,\r\n      pushTypes: filteredPushes.map(p => p.type).join(', ')\r\n    });\r\n    return filteredPushes;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    debugLogger.api('ERROR', 'Pushes fetch error', {\r\n      url,\r\n      duration: `${duration}ms`,\r\n      error: (error as Error).message\r\n    }, error as Error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// NEW: Incremental fetch with modified_after + active=true + pagination\r\nexport async function fetchIncrementalPushes(\r\n  apiKey: string,\r\n  modifiedAfter: number | null,\r\n  pageLimit = 100\r\n): Promise<Push[]> {\r\n  const all: Push[] = [];\r\n  let cursor: string | undefined = undefined;\r\n  let page = 0;\r\n\r\n  do {\r\n    const params = new URLSearchParams();\r\n    params.set('active', 'true'); // exclude deletions from \"latest\" list\r\n    params.set('limit', String(pageLimit));\r\n    if (modifiedAfter && modifiedAfter > 0) {\r\n      params.set('modified_after', String(modifiedAfter));\r\n    }\r\n    if (cursor) params.set('cursor', cursor);\r\n\r\n    const url = `${PUSHES_URL}?${params.toString()}`;\r\n    const startTime = Date.now();\r\n    const response = await fetch(url, { headers: authHeaders(apiKey) });\r\n    const duration = Date.now() - startTime;\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text().catch(() => 'Unknown error');\r\n\r\n      // NEW: Try to parse error response\r\n      let errorData: any = null;\r\n      try {\r\n        errorData = JSON.parse(errorText);\r\n      } catch {\r\n        // Not JSON, that's okay\r\n      }\r\n\r\n      // NEW: Check for invalid cursor\r\n      if (isInvalidCursorError(response, errorData)) {\r\n        debugLogger.api('WARN', 'Invalid cursor error detected', {\r\n          status: response.status,\r\n          errorText,\r\n          modifiedAfter\r\n        });\r\n\r\n        // Throw special error type that can be caught by caller\r\n        const error = new Error('INVALID_CURSOR');\r\n        error.name = 'InvalidCursorError';\r\n        throw error;\r\n      }\r\n\r\n      // Original error handling for other errors\r\n      const error = new Error(\r\n        `Failed to fetch pushes (${response.status} ${response.statusText}) - ${errorText}`\r\n      );\r\n      debugLogger.api('ERROR', 'Incremental pushes fetch failed', {\r\n        url,\r\n        status: response.status,\r\n        duration: `${duration}ms`,\r\n        errorText\r\n      });\r\n      throw error;\r\n    }\r\n\r\n    const data = (await response.json()) as PushesResponse;\r\n    const pagePushes = Array.isArray(data.pushes) ? data.pushes : [];\r\n    all.push(...pagePushes);\r\n    cursor = data.cursor;\r\n\r\n    debugLogger.api('INFO', 'Incremental pushes page fetched', {\r\n      url,\r\n      status: response.status,\r\n      duration: `${duration}ms`,\r\n      page,\r\n      pageCount: pagePushes.length,\r\n      totalSoFar: all.length,\r\n      hasMore: !!cursor,\r\n    });\r\n\r\n    page += 1;\r\n    // guard: avoid huge loops on first sync\r\n    if (page > 10) break;\r\n  } while (cursor);\r\n\r\n  // Filter to only supported types and log unsupported ones\r\n  const filtered = all.filter(p => {\r\n    // Check if dismissed\r\n    if (p.dismissed) {\r\n      return false;\r\n    }\r\n\r\n    // Check push type support\r\n    const typeCheck = checkPushTypeSupport(p.type);\r\n    if (!typeCheck.supported) {\r\n      logUnsupportedPushType(p.type, p.iden || \"unknown\", \"fetchIncrementalPushes\");\r\n      return false;\r\n    }\r\n\r\n    // Push is supported and not dismissed\r\n    return true;\r\n  });\r\n\r\n  return filtered;\r\n}\r\n\r\n/**\r\n * Fetch pushes specifically for display in the popup UI.\r\n * This is separate from incremental fetches used for auto-opening links.\r\n *\r\n * @param apiKey - The Pushbullet API key\r\n * @param limit - Number of pushes to fetch (default 50)\r\n * @returns Array of Push objects for display\r\n */\r\nexport async function fetchDisplayPushes(\r\n  apiKey: string,\r\n  limit: number = 50\r\n): Promise<Push[]> {\r\n  debugLogger.api('INFO', 'Fetching display pushes', {\r\n    limit,\r\n    hasApiKey: !!apiKey,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n\r\n  try {\r\n    // Use the modified fetchRecentPushes with custom limit\r\n    const pushes = await fetchRecentPushes(apiKey, limit);\r\n\r\n    debugLogger.api('INFO', 'Display pushes fetched successfully', {\r\n      count: pushes.length,\r\n      limit,\r\n    });\r\n\r\n    return pushes;\r\n  } catch (error) {\r\n    debugLogger.api('ERROR', 'Failed to fetch display pushes', {\r\n      error: (error as Error).message,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function ensureDeviceExists(apiKey: string, deviceIden: string): Promise<boolean> {\r\n  const response = await fetch(\r\n    `https://api.pushbullet.com/v2/devices/${deviceIden}`,\r\n    { method: 'GET', headers: { 'Access-Token': apiKey } }\r\n  );\r\n  return response.status !== 404;\r\n}\r\n\r\nexport async function registerDevice(\r\n  apiKey: string,\r\n  deviceIden: string | null,\r\n  deviceNickname: string\r\n): Promise<{ deviceIden: string; needsUpdate: boolean }> {\r\n  // If registration is already in progress, return the existing promise\r\n  if (registrationPromise) {\r\n    debugLogger.general('INFO', 'Device registration already in progress, reusing promise', {\r\n      source: 'registerDevice',\r\n      existingRegistration: true\r\n    });\r\n    return registrationPromise;\r\n  }\r\n\r\n  // Create and store the registration promise\r\n  registrationPromise = (async () => {\r\n    try {\r\n      debugLogger.general('INFO', 'Starting device registration process', {\r\n        hasApiKey: !!apiKey,\r\n        currentDeviceIden: deviceIden,\r\n        deviceNickname,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // Check if device is already registered\r\n      const existingDeviceIden = await storageRepository.getDeviceIden();\r\n\r\n      if (existingDeviceIden) {\r\n        debugLogger.general('INFO', 'Device already registered', { deviceIden: existingDeviceIden, deviceNickname });\r\n\r\n        // Check if nickname needs updating\r\n        try {\r\n          const devices = await fetchDevices(apiKey);\r\n\r\n          // --- START NEW CODE ---\r\n          // Log ALL devices with ALL attributes for debugging\r\n          debugLogger.general('INFO', '[DEVICE_DEBUG] All devices fetched from API', {\r\n            totalDevices: devices.length,\r\n            timestamp: new Date().toISOString()\r\n          });\r\n\r\n          // Log each device individually with full details\r\n          devices.forEach((device, index) => {\r\n            debugLogger.general('INFO', `[DEVICE_DEBUG] Device #${index + 1}`, {\r\n              iden: device.iden,\r\n              nickname: device.nickname || '(no nickname)',\r\n              model: device.model || '(no model)',\r\n              manufacturer: device.manufacturer || '(no manufacturer)',\r\n              type: device.type || '(no type)',\r\n              active: device.active,\r\n              created: device.created,\r\n              modified: device.modified,\r\n              icon: device.icon || '(no icon)',\r\n              pushToken: device.push_token ? `${device.push_token.substring(0, 8)}...` : '(no push token)',\r\n              appVersion: device.app_version || '(no app version)',\r\n              hasSms: device.has_sms || false,\r\n              // Include ALL raw device data\r\n              rawDevice: device\r\n            });\r\n          });\r\n          // --- END NEW CODE ---\r\n\r\n          const currentDevice = devices.find(d => d.iden === existingDeviceIden);\r\n\r\n          // --- START FIX ---\r\n          // Check if the stored device ID actually exists in the fetched device list\r\n          if (!currentDevice) {\r\n            debugLogger.general('WARN', '[DEVICE_DEBUG] Stored device ID not found in API response - device was deleted', {\r\n              storedDeviceIden: existingDeviceIden,\r\n              availableDeviceIdens: devices.map(d => d.iden)\r\n            });\r\n\r\n            // Clear stale device ID from storage\r\n            await storageRepository.setDeviceIden(null);\r\n\r\n            debugLogger.general('INFO', 'Cleared stale device ID, will register new device');\r\n\r\n            // Fall through to device registration below\r\n            // (DON'T use 'return' here - let it continue to the registration code)\r\n          } else {\r\n            // Device exists - check if nickname needs updating\r\n            const currentNickname = currentDevice.nickname;\r\n\r\n            if (currentNickname !== deviceNickname) {\r\n              debugLogger.general('INFO', '[DEVICE_DEBUG] Nickname mismatch, updating', {\r\n                currentNickname,\r\n                newNickname: deviceNickname\r\n              });\r\n\r\n              await updateDeviceNickname(apiKey, existingDeviceIden, deviceNickname);\r\n\r\n            } else {\r\n              debugLogger.general('DEBUG', 'Device nickname unchanged, skipping update');\r\n            }\r\n\r\n            return { deviceIden: existingDeviceIden, needsUpdate: false };\r\n          }\r\n          // --- END FIX ---\r\n        } catch (error) {\r\n          debugLogger.general('WARN', 'Failed to update existing device, will re-register', {\r\n            error: (error as Error).message,\r\n            deviceIden: existingDeviceIden\r\n          });\r\n          await storageRepository.setDeviceIden(null);\r\n        }\r\n      }\r\n\r\n      // Register new device\r\n      debugLogger.general('INFO', 'Registering new device with Pushbullet API', { deviceNickname, url: DEVICES_URL });\r\n\r\n      const registrationData = {\r\n        nickname: deviceNickname,\r\n        model: 'Chrome',\r\n        manufacturer: 'Google',\r\n        push_token: '',\r\n        app_version: 8623,\r\n        icon: 'browser',\r\n        has_sms: false,\r\n        type: 'chrome'\r\n      };\r\n\r\n      debugLogger.api('INFO', 'Sending device registration request', {\r\n        url: DEVICES_URL,\r\n        method: 'POST',\r\n        deviceData: registrationData\r\n      });\r\n\r\n      const startTime = Date.now();\r\n      const response = await fetch(DEVICES_URL, {\r\n        method: 'POST',\r\n        headers: {\r\n          ...authHeaders(apiKey),\r\n          'Content-Type': 'application/json'\r\n        },\r\n        body: JSON.stringify(registrationData)\r\n      });\r\n\r\n      const duration = Date.now() - startTime;\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text().catch(() => 'Unknown error');\r\n        const error = new Error(`Failed to register device: ${response.status} ${response.statusText} - ${errorText}`);\r\n        debugLogger.api('ERROR', 'Device registration failed', {\r\n          url: DEVICES_URL,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          duration: `${duration}ms`,\r\n          errorText\r\n        }, error);\r\n        throw error;\r\n      }\r\n\r\n      const device: Device = await response.json();\r\n      const newDeviceIden = device.iden;\r\n\r\n      debugLogger.api('INFO', 'Device registered successfully', {\r\n        url: DEVICES_URL,\r\n        status: response.status,\r\n        duration: `${duration}ms`,\r\n        deviceIden: newDeviceIden,\r\n        deviceNickname: device.nickname\r\n      });\r\n\r\n      // Save device iden to storage\r\n      await storageRepository.setDeviceIden(newDeviceIden);\r\n\r\n      debugLogger.general('INFO', 'Device registration completed', {\r\n        deviceIden: newDeviceIden,\r\n        deviceNickname: device.nickname\r\n      });\r\n\r\n      return { deviceIden: newDeviceIden, needsUpdate: false };\r\n    } catch (error) {\r\n      debugLogger.general('ERROR', 'Error in registerDevice function', {\r\n        errorMessage: (error as Error).message,\r\n        errorStack: (error as Error).stack\r\n      });\r\n      throw error;\r\n    } finally {\r\n      // Clear the promise reference to allow retry on failure\r\n      registrationPromise = null;\r\n    }\r\n  })();\r\n\r\n  return registrationPromise;\r\n}\r\n\r\nexport async function updateDeviceNickname(\r\n  apiKey: string,\r\n  deviceIden: string,\r\n  newNickname: string\r\n): Promise<void> {\r\n  const deviceExists = await ensureDeviceExists(apiKey, deviceIden);\r\n  if (!deviceExists) {\r\n    throw new Error(`Device with iden ${deviceIden} not found on server.`);\r\n  }\r\n\r\n  debugLogger.general('INFO', 'Updating device nickname', {\r\n    deviceIden,\r\n    newNickname,\r\n    timestamp: new Date().toISOString()\r\n  });\r\n\r\n  try {\r\n    const url = `${DEVICES_URL}/${deviceIden}`;\r\n    const startTime = Date.now();\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        ...authHeaders(apiKey),\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({ nickname: newNickname })\r\n    });\r\n\r\n    const duration = Date.now() - startTime;\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text().catch(() => 'Unknown error');\r\n      const error = new Error(`Failed to update device nickname: ${response.status} ${response.statusText} - ${errorText}`);\r\n      debugLogger.api('ERROR', 'Device nickname update failed', {\r\n        url,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        duration: `${duration}ms`,\r\n        errorText\r\n      }, error);\r\n      throw error;\r\n    }\r\n\r\n    const device: Device = await response.json();\r\n    debugLogger.api('INFO', 'Device nickname updated successfully', {\r\n      url,\r\n      status: response.status,\r\n      duration: `${duration}ms`,\r\n      deviceIden,\r\n      newNickname: device.nickname\r\n    });\r\n  } catch (error) {\r\n    debugLogger.general('ERROR', 'Error in updateDeviceNickname function', {\r\n      errorMessage: (error as Error).message,\r\n      errorStack: (error as Error).stack\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch chats (contacts/friends) from Pushbullet\r\n * Returns list of active chats only\r\n */\r\nexport async function fetchChats(apiKey: string): Promise<Chat[]> {\r\n  try {\r\n    debugLogger.api(\"INFO\", \"Fetching chats from Pushbullet API\");\r\n\r\n    const response = await fetch('https://api.pushbullet.com/v2/chats', {\r\n      method: 'GET',\r\n      headers: {\r\n        'Access-Token': apiKey,\r\n        'Content-Type': 'application/json',\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\r\n        `Failed to fetch chats: ${response.status} ${response.statusText}`\r\n      );\r\n    }\r\n\r\n    const data = await response.json();\r\n    const chats = data.chats || [];\r\n\r\n    // Filter to only active chats (not deleted)\r\n    const activeChats = chats.filter((chat: Chat) => chat.active);\r\n\r\n    debugLogger.api(\"INFO\", \"Chats fetched successfully\", {\r\n      totalChats: chats.length,\r\n      activeChats: activeChats.length,\r\n    });\r\n\r\n    return activeChats;\r\n\r\n  } catch (error) {\r\n    debugLogger.api(\"ERROR\", \"Error fetching chats\", {\r\n      error: (error as Error).message,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function dismissPush(iden: string, apiKey: string): Promise<void> {\r\n  const url = `https://api.pushbullet.com/v2/pushes/${encodeURIComponent(iden)}`;\r\n  const response = await fetch(url, {\r\n    method: 'POST',\r\n    headers: {\r\n      ...authHeaders(apiKey),\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({ dismissed: true }),\r\n  });\r\n  if (!response.ok) throw new Error(`Dismiss failed: ${response.status}`);\r\n}\r\n\r\n\r\n", "// src/infrastructure/storage/indexed-db.ts\n\nimport type { SessionCache } from \"../../types/domain\";\nimport { debugLogger } from \"../../lib/logging\";\n\nconst DB_NAME = \"PushbulletState\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"session\";\nconst CACHE_KEY = \"main\";\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\n\n/**\n * Opens the IndexedDB database and creates the object store if needed.\n */\nfunction openDb(): Promise<IDBDatabase> {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      debugLogger.storage(\"ERROR\", \"IndexedDB error\", { error: request.error });\n      reject(request.error);\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME);\n        debugLogger.storage(\"INFO\", \"IndexedDB object store created\");\n      }\n    };\n  });\n\n  return dbPromise;\n}\n\n/**\n * Saves the entire session cache to IndexedDB.\n * @param session The session cache object to save.\n */\nexport async function saveSessionCache(session: SessionCache): Promise<void> {\n  try {\n    const db = await openDb();\n    const transaction = db.transaction(STORE_NAME, \"readwrite\");\n    const store = transaction.objectStore(STORE_NAME);\n\n    // *** ADD THESE 2 LINES BEFORE store.put ***\n    const timestampedSession = { ...session, cachedAt: Date.now() };\n    store.put(timestampedSession, CACHE_KEY);\n\n    await new Promise((resolve) => (transaction.oncomplete = resolve));\n    debugLogger.storage(\"DEBUG\", \"Session cache saved to IndexedDB\");\n  } catch (error) {\n    debugLogger.storage(\n      \"ERROR\",\n      \"Failed to save session to IndexedDB\",\n      null,\n      error as Error,\n    );\n  }\n}\n\n/**\n * Loads the session cache from IndexedDB.\n * @returns The saved session cache, or null if not found.\n */\nexport async function loadSessionCache(): Promise<SessionCache | null> {\n  try {\n    const db = await openDb();\n    const transaction = db.transaction(STORE_NAME, \"readonly\");\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(CACHE_KEY);\n\n    return new Promise((resolve) => {\n      request.onsuccess = () => {\n        debugLogger.storage(\"DEBUG\", \"Session cache loaded from IndexedDB\", {\n          found: !!request.result,\n        });\n        resolve(request.result || null);\n      };\n      request.onerror = () => {\n        debugLogger.storage(\"ERROR\", \"Failed to load session from IndexedDB\", {\n          error: request.error,\n        });\n        resolve(null);\n      };\n    });\n  } catch (error) {\n    debugLogger.storage(\n      \"ERROR\",\n      \"Failed to open IndexedDB for loading\",\n      null,\n      error as Error,\n    );\n    return null;\n  }\n}\n\n/**\n * Clears the session cache from IndexedDB.\n */\nexport async function clearSessionCache(): Promise<void> {\n  try {\n    const db = await openDb();\n    const transaction = db.transaction(STORE_NAME, \"readwrite\");\n    const store = transaction.objectStore(STORE_NAME);\n    store.clear();\n    await new Promise((resolve) => (transaction.oncomplete = resolve));\n    debugLogger.storage(\"INFO\", \"IndexedDB session cache cleared\");\n  } catch (error) {\n    debugLogger.storage(\n      \"ERROR\",\n      \"Failed to clear IndexedDB session\",\n      null,\n      error as Error,\n    );\n  }\n}", "/**\n * Keepalive utility to prevent service worker termination during critical operations\n */\nimport { debugLogger } from '../lib/logging';\n\nconst KEEPALIVE_ALARM = 'criticalKeepalive';\nconst KEEPALIVE_INTERVAL_SECONDS = 20; // Chrome's minimum is 0.5 minutes (30s), but we use seconds for clarity\n\nlet activeCount = 0;\n\n/**\n * Start aggressive keepalive during critical operations\n * Call this BEFORE starting initialization\n */\nexport function startCriticalKeepalive(): void {\n  activeCount++;\n\n  if (activeCount === 1) {\n    // First caller - create the alarm\n    chrome.alarms.create(KEEPALIVE_ALARM, {\n      delayInMinutes: KEEPALIVE_INTERVAL_SECONDS / 60,\n      periodInMinutes: KEEPALIVE_INTERVAL_SECONDS / 60\n    });\n\n    debugLogger.general('INFO', 'Critical keepalive started', {\n      interval: `${KEEPALIVE_INTERVAL_SECONDS}s`,\n      activeCount\n    });\n  } else {\n    debugLogger.general('DEBUG', 'Critical keepalive already active', { activeCount });\n  }\n}\n\n/**\n * Stop aggressive keepalive after critical operation completes\n * Call this AFTER initialization finishes (success or failure)\n */\nexport function stopCriticalKeepalive(): void {\n  if (activeCount > 0) {\n    activeCount--;\n  }\n\n  if (activeCount === 0) {\n    // Last caller - remove the alarm\n    chrome.alarms.clear(KEEPALIVE_ALARM, (wasCleared) => {\n      debugLogger.general('INFO', 'Critical keepalive stopped', { wasCleared });\n    });\n  } else {\n    debugLogger.general('DEBUG', 'Critical keepalive still needed', { activeCount });\n  }\n}\n\n/**\n * Handle the keepalive alarm event\n * Add this to chrome.alarms.onAlarm listener\n */\nexport function handleKeepaliveAlarm(alarm: chrome.alarms.Alarm): boolean {\n  if (alarm.name === KEEPALIVE_ALARM) {\n    debugLogger.general('DEBUG', 'Critical keepalive heartbeat', {\n      timestamp: new Date().toISOString(),\n      activeCount\n    });\n    return true; // Handled\n  }\n  return false; // Not our alarm\n}", "import { storageRepository } from '../../infrastructure/storage/storage.repository';\nimport { fetchIncrementalPushes } from '../api/client';\nimport { debugLogger } from '../../lib/logging';\nimport { setLastModifiedCutoffSafe } from './index';\nimport type { Push } from '../../types/domain';\n\ntype IncrementalSeedResult = { isSeedRun: true; pushes: [] };\ntype IncrementalNormalResult = { isSeedRun: false; pushes: Push[] };\nexport type IncrementalResult = IncrementalSeedResult | IncrementalNormalResult;\n\nasync function computeMaxModified(pushes: Array<{ modified?: number }>): Promise<number> {\n  let maxModified = 0;\n  for (const p of pushes) {\n    const m = typeof p.modified === 'number' ? p.modified : 0;\n    if (m > maxModified) maxModified = m;\n  }\n  return maxModified;\n}\n\nexport async function refreshPushesIncremental(apiKey: string): Promise<IncrementalResult> {\n  const storedCutoff = await storageRepository.getLastModifiedCutoff();\n  const isSeedRun = !storedCutoff || storedCutoff === 0;\n\n  if (isSeedRun) {\n    debugLogger.general('INFO', 'Pipeline 1 First run cutoff missing/0. Seeding cutoff only; skipping side effects.');\n    // Compute cutoff only (no side effects)\n    const pushes = await fetchIncrementalPushes(apiKey, null, 100);\n    const newCutoff = await computeMaxModified(pushes);\n    if (newCutoff > 0) {\n      await setLastModifiedCutoffSafe(newCutoff);\n      debugLogger.general('INFO',\n        \"Pipeline 1 Seed complete. Updated lastModifiedCutoff via safe setter.\",\n        { newCutoff },\n      );\n    } else {\n      debugLogger.general('WARN', 'Pipeline 1 Seed returned no items; leaving cutoff unchanged.');\n    }\n    // CRITICAL: return empty pushes to prevent accidental processing by callers\n    return { pushes: [], isSeedRun: true as const };\n  }\n\n  // Normal incremental: fetch and advance cutoff\n  const pushes = await fetchIncrementalPushes(apiKey, storedCutoff, 100);\n  const maxModified = await computeMaxModified(pushes);\n  if (maxModified > storedCutoff!) {\n    await setLastModifiedCutoffSafe(maxModified);\n    debugLogger.general('DEBUG', 'Pipeline 1 Updated cutoff via safe setter', {\n      old: storedCutoff,\n      new: maxModified,\n    });\n  }\n  return { pushes, isSeedRun: false as const };\n}", "import type { SessionCache } from \"../../types/domain\";\r\nimport { debugLogger } from \"../../lib/logging\";\r\nimport { performanceMonitor } from \"../../lib/perf\";\r\nimport {\r\n  fetchChats,\r\n  fetchDevices,\r\n  fetchDisplayPushes,  // \u2190 ADD: Import new function\r\n  fetchUserInfo,\r\n  registerDevice,\r\n} from \"../api/client\";\r\nimport { storageRepository } from \"../../infrastructure/storage/storage.repository\";\r\nimport { saveSessionCache } from \"../../infrastructure/storage/indexed-db\";\r\nimport { startCriticalKeepalive, stopCriticalKeepalive } from \"../../background/keepalive\";\r\nimport { refreshPushesIncremental } from \"./pipeline\";\r\n\r\n// Session cache state\r\nexport const sessionCache: SessionCache = {\r\n  userInfo: null,\r\n  devices: [],\r\n  recentPushes: [],\r\n  chats: [], // \u2190 ADD THIS LINE\r\n  isAuthenticated: false,\r\n  lastUpdated: 0,\r\n  autoOpenLinks: true,\r\n  deviceNickname: \"Chrome\",\r\n  onlyThisDevice: false,\r\n  lastModifiedCutoff: 0,  // \u2190 ADD: Initialize to 0\r\n  cachedAt: 0, // No cache initially\r\n};\r\n\r\n/**\r\n * Cache Time-To-Live (TTL) in milliseconds\r\n * 5 minutes = 300,000 milliseconds\r\n * Cache older than this will be considered stale\r\n */\r\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\n/**\r\n * Check if cached session data is fresh enough to use\r\n * @param cachedSession - Session loaded from IndexedDB\r\n * @returns true if cache is fresh, false if stale or invalid\r\n */\r\nfunction isCacheFresh(cachedSession: SessionCache | null): boolean {\r\n  if (!cachedSession) {\r\n    return false; // No cache\r\n  }\r\n\r\n  if (!cachedSession.isAuthenticated) {\r\n    return false; // Not authenticated in cache\r\n  }\r\n\r\n  if (!cachedSession.cachedAt) {\r\n    return false; // Cache has no timestamp (old format)\r\n  }\r\n\r\n  const cacheAge = Date.now() - cachedSession.cachedAt;\r\n  const isFresh = cacheAge < CACHE_TTL_MS;\r\n\r\n  debugLogger.general('DEBUG', \"Cache freshness check\", {\r\n    cacheAge: `${Math.round(cacheAge / 1000)}s`,\r\n    ttl: `${CACHE_TTL_MS / 1000}s`,\r\n    isFresh,\r\n  });\r\n\r\n  return isFresh;\r\n}\r\n\r\n/**\r\n * Reset the session cache to its initial, unauthenticated state.\r\n * This ensures no stale data remains when logging out.\r\n */\r\nexport function resetSessionCache(): void {\r\n  sessionCache.userInfo = null;\r\n  sessionCache.devices = [];\r\n  sessionCache.recentPushes = [];\r\n  sessionCache.chats = [];\r\n  sessionCache.isAuthenticated = false;\r\n  sessionCache.lastUpdated = 0;\r\n  sessionCache.autoOpenLinks = true;\r\n  sessionCache.deviceNickname = \"Chrome\";\r\n  sessionCache.lastModifiedCutoff = 0;  // \u2190 ADD: Reset cutoff on logout\r\n  sessionCache.cachedAt = 0;\r\n}\r\n\r\n/**\r\n * Refresh session cache in the background without blocking the UI\r\n * This runs AFTER the popup has already displayed cached data\r\n * @param apiKey - API key for network requests\r\n */\r\nasync function refreshSessionInBackground(apiKey: string): Promise<void> {\r\n  debugLogger.general('INFO', \"Starting background cache refresh\");\r\n\r\n  try {\r\n    // Fetch fresh data from API\r\n    const [userInfo, devices, displayPushes, chats] = await Promise.all([\r\n      fetchUserInfo(apiKey).catch((e) => {\r\n        debugLogger.api('WARN', \"Background user fetch failed\", { error: String(e) });\r\n        return sessionCache.userInfo; // Keep existing\r\n      }),\r\n      fetchDevices(apiKey).catch((e) => {\r\n        debugLogger.api('WARN', \"Background devices fetch failed\", { error: String(e) });\r\n        return sessionCache.devices; // Keep existing\r\n      }),\r\n      fetchDisplayPushes(apiKey, 50).catch((e) => {\r\n        debugLogger.api('WARN', \"Background pushes fetch failed\", { error: String(e) });\r\n        return sessionCache.recentPushes; // Keep existing\r\n      }),\r\n      fetchChats(apiKey).catch((e) => {\r\n        debugLogger.api('WARN', \"Background chats fetch failed\", { error: String(e) });\r\n        return sessionCache.chats; // Keep existing\r\n      }),\r\n    ]);\r\n\r\n    // Update in-memory cache\r\n    sessionCache.userInfo = userInfo;\r\n    sessionCache.devices = devices;\r\n    sessionCache.recentPushes = displayPushes;\r\n    sessionCache.chats = chats;\r\n    sessionCache.lastUpdated = Date.now();\r\n\r\n    // Save updated cache back to IndexedDB\r\n    await saveSessionCache(sessionCache);\r\n\r\n    debugLogger.general('INFO', \"Background cache refresh completed\", {\r\n      deviceCount: devices.length,\r\n      pushCount: displayPushes.length,\r\n      chatCount: chats.length,\r\n    });\r\n\r\n    // Notify popup that data has been updated\r\n    chrome.runtime.sendMessage({\r\n      action: \"SESSION_DATA_UPDATED\",\r\n      userInfo,\r\n      devices,\r\n      recentPushes: displayPushes,\r\n      chats,\r\n    }).catch(() => {\r\n      // Popup might be closed, that's okay\r\n      debugLogger.general('DEBUG', \"Popup not available for background update notification\");\r\n    });\r\n\r\n  } catch (error) {\r\n    debugLogger.general('ERROR',\r\n      \"Background cache refresh failed\",\r\n      null,\r\n      error as Error,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle invalid cursor recovery\r\n *\r\n * This function is called when the API returns an invalid_cursor error.\r\n * It clears all local state and triggers a fresh bootstrap.\r\n */\r\nexport async function handleInvalidCursorRecovery(\r\n  apiKey: string,\r\n  connectWebSocketFn?: () => void\r\n): Promise<void> {\r\n  debugLogger.general('WARN', 'Invalid cursor detected - starting recovery process');\r\n\r\n  try {\r\n    // Step 1: Clear cursor from storage\r\n    debugLogger.general('INFO', 'Clearing invalid cursor from storage');\r\n    await handleInvalidCursorRecoveryReset();\r\n\r\n    // Step 2: Reset session cache\r\n    debugLogger.general('INFO', 'Resetting session cache');\r\n    sessionCache.lastModifiedCutoff = 0;\r\n    sessionCache.recentPushes = [];\r\n\r\n    // Step 3: Track recovery attempt\r\n    performanceMonitor.recordInvalidCursorRecovery();\r\n\r\n    // Step 4: Re-bootstrap session\r\n    debugLogger.general('INFO', 'Re-bootstrapping session after invalid cursor');\r\n    await initializeSessionCache('invalid-cursor-recovery', connectWebSocketFn);\r\n\r\n    debugLogger.general('INFO', 'Invalid cursor recovery completed successfully');\r\n  } catch (error) {\r\n    debugLogger.general('ERROR', 'Failed to recover from invalid cursor', null, error as Error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function hydrateCutoff(): Promise<void> {\r\n  const cutoff = await storageRepository.getLastModifiedCutoff();\r\n  sessionCache.lastModifiedCutoff = typeof cutoff === 'number' ? cutoff : 0;\r\n  debugLogger.general('DEBUG', `Session: Hydrated lastModifiedCutoff=${sessionCache.lastModifiedCutoff}`);\r\n}\r\n\r\n\r\n\r\n// Explicit reset flows only:\r\nexport async function handleLogoutReset(): Promise<void> {\r\n  await storageRepository.setLastModifiedCutoff(0); // allowed here\r\n  debugLogger.general('INFO', 'Cutoff: set to 0 due to explicit logout.');\r\n}\r\n\r\n// SAFE: for normal advancement; rejects 0 and non-increasing values\r\nexport async function setLastModifiedCutoffSafe(next: number): Promise<void> {\r\n  const current = await storageRepository.getLastModifiedCutoff();\r\n  if (!Number.isFinite(next) || next <= 0) {\r\n    debugLogger.general('WARN', 'CutoffSafe: refusing non-positive or invalid value', { next });\r\n    return;\r\n  }\r\n  if (current && next <= current) {\r\n    debugLogger.general('DEBUG', 'CutoffSafe: unchanged or non-increasing', { current, next });\r\n    return;\r\n  }\r\n  await storageRepository.setLastModifiedCutoff(next);\r\n  sessionCache.lastModifiedCutoff = next;\r\n  debugLogger.general('INFO', 'Pipeline 1 Updated cutoff via safe setter', { old: current ?? null, new: next });\r\n}\r\n\r\n// UNSAFE: only for explicit logout or invalid-cursor recovery\r\nexport async function setLastModifiedCutoffUnsafeForRecovery(next: number): Promise<void> {\r\n  await storageRepository.setLastModifiedCutoff(next);\r\n  sessionCache.lastModifiedCutoff = next;\r\n  debugLogger.general('INFO', 'Cutoff set UNSAFE due to explicit recovery/logout', { new: next });\r\n}\r\n\r\nexport async function handleInvalidCursorRecoveryReset(): Promise<void> {\r\n  await setLastModifiedCutoffUnsafeForRecovery(0); // allowed here\r\n  debugLogger.general('INFO', 'Cutoff: set to 0 due to invalid-cursor recovery.');\r\n}\r\n\r\n\r\n\r\n// Promise singleton for single-flight initialization\r\n// Prevents race conditions when multiple events trigger initialization concurrently\r\nlet initPromise: Promise<string | null> | null = null;\r\n\r\n/**\r\n * Get the current initialization promise (if any)\r\n * This allows callers to await ongoing initialization instead of polling\r\n */\r\nexport function getInitPromise(): Promise<string | null> | null {\r\n  return initPromise;\r\n}\r\n\r\n/**\r\n * Set the global initialization promise\r\n * This should only be called by orchestrateInitialization to coordinate all init attempts\r\n * @param promise - The initialization promise to set, or null to clear\r\n */\r\nexport function setInitPromise(promise: Promise<string | null> | null): void {\r\n  initPromise = promise;\r\n\r\n  debugLogger.general('DEBUG', \"Global init promise updated\", {\r\n    isSet: !!promise,\r\n    previouslySet: initPromise !== promise && initPromise !== null,\r\n  });\r\n}\r\n\r\n/**\r\n * Clear the global initialization promise\r\n * This should be called when initialization completes or fails\r\n * Always called in a finally block to ensure cleanup\r\n */\r\nexport function clearInitPromise(): void {\r\n  const wasSet = initPromise !== null;\r\n  initPromise = null;\r\n\r\n  if (wasSet) {\r\n    debugLogger.general('DEBUG', \"Global init promise cleared\", {\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n  }\r\n}\r\n\r\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.sync\r\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\r\n\r\nexport async function initializeSessionCache(\r\n  source = \"unknown\",\r\n  connectWebSocketFn?: () => void,\r\n  stateSetters?: {\r\n    setApiKey: (key: string | null) => void;\r\n    setDeviceIden: (iden: string | null) => void;\r\n    setAutoOpenLinks: (value: boolean) => void;\r\n    setDeviceNickname: (nickname: string) => void;\r\n    setNotificationTimeout: (timeout: number) => void;\r\n  },\r\n): Promise<string | null> {\r\n  // If initialization is already in progress, return the existing promise\r\n  // This allows concurrent callers to await the same initialization\r\n  if (initPromise) {\r\n    debugLogger.general(\r\n      \"INFO\",\r\n      \"Initialization already in progress, returning existing promise\",\r\n      {\r\n        source,\r\n        existingInitialization: true,\r\n      },\r\n    );\r\n    return initPromise;\r\n  }\r\n\r\n  // If the session is already authenticated (e.g., loaded from IndexedDB),\r\n  // then there is no work to do here.\r\n  if (sessionCache.isAuthenticated) {\r\n    const hasData =\r\n      sessionCache.userInfo !== null && (sessionCache.devices?.length ?? 0) > 0;\r\n\r\n    if (!hasData) {\r\n      debugLogger.general(\r\n        \"WARN\",\r\n        \"Authenticated flag set but session data missing \u2014 forcing re-initialization\",\r\n      );\r\n      sessionCache.isAuthenticated = false;\r\n    } else {\r\n      debugLogger.general(\r\n        \"INFO\",\r\n        \"Session already loaded with data, skipping network initialization.\",\r\n      );\r\n      if (connectWebSocketFn) connectWebSocketFn();\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Create and store the initialization promise\r\n  initPromise = (async () => {\r\n    // START keepalive\r\n    startCriticalKeepalive();\r\n\r\n    try {\r\n      debugLogger.general(\"INFO\", \"Initializing session cache\", {\r\n        source,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      // Load core settings from sync storage\r\n      debugLogger.storage(\r\n        \"DEBUG\",\r\n        \"Loading initial configuration from storage repository\",\r\n      );\r\n\r\n      // Get API key and device iden from storage repository\r\n      const apiKeyValue = await storageRepository.getApiKey();\r\n      const deviceIdenValue = await storageRepository.getDeviceIden();\r\n\r\n      if (stateSetters) {\r\n        stateSetters.setApiKey(apiKeyValue);\r\n        stateSetters.setDeviceIden(deviceIdenValue);\r\n      }\r\n\r\n      // Get settings with defaults from storage repository\r\n      const autoOpenLinksValue = await storageRepository.getAutoOpenLinks();\r\n      const notificationTimeoutValue =\r\n        await storageRepository.getNotificationTimeout();\r\n      const deviceNicknameValue =\r\n        (await storageRepository.getDeviceNickname()) || \"Chrome\";\r\n\r\n      if (stateSetters) {\r\n        stateSetters.setAutoOpenLinks(autoOpenLinksValue);\r\n        stateSetters.setNotificationTimeout(notificationTimeoutValue);\r\n        stateSetters.setDeviceNickname(deviceNicknameValue);\r\n      }\r\n\r\n      sessionCache.autoOpenLinks = autoOpenLinksValue;\r\n      sessionCache.deviceNickname = deviceNicknameValue;\r\n\r\n      debugLogger.storage(\r\n        \"INFO\",\r\n        \"Loaded configuration from storage repository\",\r\n        {\r\n          hasApiKey: !!apiKeyValue,\r\n          hasDeviceIden: !!deviceIdenValue,\r\n          autoOpenLinks: autoOpenLinksValue,\r\n          deviceNickname: deviceNicknameValue,\r\n          notificationTimeout: notificationTimeoutValue,\r\n        },\r\n      );\r\n\r\n      debugLogger.general(\"DEBUG\", \"API key status\", {\r\n        hasApiKey: !!apiKeyValue,\r\n        apiKeyLength: apiKeyValue ? apiKeyValue.length : 0,\r\n      });\r\n\r\n      if (apiKeyValue) {\r\n        debugLogger.general(\r\n          \"INFO\",\r\n          \"API key available - initializing session data\",\r\n        );\r\n\r\n        // Fetch user info\r\n        const userInfo = await fetchUserInfo(apiKeyValue);\r\n        sessionCache.userInfo = userInfo;\r\n\r\n        // Fetch devices\r\n        const devices = await fetchDevices(apiKeyValue);\r\n        sessionCache.devices = devices;\r\n\r\n        // ========================================\r\n        // PIPELINE 1: Incremental Auto-Open Pipeline\r\n        // ========================================\r\n        // This pipeline tracks what pushes we've already seen and processes\r\n        // new ones for auto-opening links. It uses lastModifiedCutoff to\r\n        // fetch only changes since the last check.\r\n\r\n        debugLogger.general('INFO', 'Pipeline 1: Fetching incremental pushes for auto-open');\r\n\r\n        const { isSeedRun } = await refreshPushesIncremental(apiKeyValue);\r\n\r\n        if (isSeedRun) {\r\n          debugLogger.general('INFO', 'Seed run: cutoff initialized; skipping processing and auto-open.');\r\n          // Update sessionCache.lastModifiedCutoff from storage\r\n          const updatedCutoff = await storageRepository.getLastModifiedCutoff();\r\n          sessionCache.lastModifiedCutoff = updatedCutoff ?? 0;\r\n          // Continue with initialization even on seed run\r\n        }\r\n\r\n        // Update sessionCache.lastModifiedCutoff from storage\r\n        const updatedCutoff = await storageRepository.getLastModifiedCutoff();\r\n        sessionCache.lastModifiedCutoff = updatedCutoff ?? 0;\r\n\r\n        // ========================================\r\n        // PIPELINE 2: Display History Pipeline\r\n        // ========================================\r\n        // This pipeline fetches the last 50 pushes for display in the popup.\r\n        // It is completely independent of the incremental tracking used for\r\n        // auto-opening links.\r\n\r\n        debugLogger.general('INFO', 'Pipeline 2: Fetching display pushes for UI');\r\n\r\n        const displayPushes = await fetchDisplayPushes(apiKeyValue, 50);\r\n\r\n        debugLogger.general('INFO', 'Pipeline 2: Display fetch complete', {\r\n          count: displayPushes.length,\r\n        });\r\n\r\n        // Store display pushes in session cache for popup consumption\r\n        sessionCache.recentPushes = displayPushes;\r\n\r\n        // ========== ADD THIS ENTIRE BLOCK ==========\r\n        // Fetch chats (friends/contacts)\r\n        try {\r\n          const chats = await fetchChats(apiKeyValue);\r\n          sessionCache.chats = chats;\r\n          debugLogger.general(\"INFO\", \"Chats loaded successfully\", {\r\n            chatCount: chats.length,\r\n          });\r\n        } catch (error) {\r\n          // Don't fail initialization if chats fail to load\r\n          debugLogger.general(\"WARN\", \"Failed to load chats, continuing anyway\", {\r\n            error: (error as Error).message,\r\n          });\r\n          sessionCache.chats = [];\r\n        }\r\n        // ========== END OF BLOCK ==========\r\n\r\n        // Update session cache\r\n        sessionCache.isAuthenticated = true;\r\n        sessionCache.lastUpdated = Date.now();\r\n\r\n        debugLogger.general(\"INFO\", \"Session cache populated successfully\", {\r\n          hasUserInfo: !!sessionCache.userInfo,\r\n          deviceCount: sessionCache.devices.length,\r\n          pushCount: sessionCache.recentPushes.length,\r\n          lastUpdated: new Date(sessionCache.lastUpdated).toISOString(),\r\n        });\r\n\r\n        // Register device\r\n        await registerDevice(apiKeyValue, deviceIdenValue, deviceNicknameValue);\r\n\r\n        // Connect WebSocket if the function is provided\r\n        if (connectWebSocketFn) {\r\n          debugLogger.general(\"INFO\", \"Session initialized, connecting WebSocket.\");\r\n          connectWebSocketFn();\r\n        }\r\n\r\n        // Start periodic health check\r\n        chrome.alarms.create(\"websocketHealthCheck\", { periodInMinutes: 1 });\r\n        debugLogger.general(\"DEBUG\", \"WebSocket health check alarm created\", {\r\n          interval: \"1 minutes\",\r\n        });\r\n      } else {\r\n        debugLogger.general(\r\n          \"WARN\",\r\n          \"No API key available - session cache not initialized\",\r\n        );\r\n      }\r\n\r\n      // Save our freshly built session to the database for next time.\r\n      saveSessionCache(sessionCache);\r\n      debugLogger.general(\"INFO\", \"Initialization completed successfully\", {\r\n        source,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      return apiKeyValue;\r\n    } catch (error) {\r\n      debugLogger.general(\r\n        \"ERROR\",\r\n        \"Error initializing session cache\",\r\n        {\r\n          error:\r\n            (error as Error).message ||\r\n            (error as Error).name ||\r\n            \"Unknown error\",\r\n        },\r\n        error as Error,\r\n      );\r\n      sessionCache.isAuthenticated = false;\r\n      throw error;\r\n    } finally {\r\n      // ALWAYS stop keepalive\r\n      stopCriticalKeepalive();\r\n      // Clear the promise reference to allow retry on failure\r\n      initPromise = null;\r\n    }\r\n  })();\r\n\r\n  return initPromise;\r\n}\r\n\r\nexport async function refreshSessionCache(apiKeyParam: string): Promise<void> {\r\n  debugLogger.general(\"INFO\", \"Refreshing session cache\", {\r\n    hasApiKey: !!apiKeyParam,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n\r\n  try {\r\n    if (apiKeyParam) {\r\n      debugLogger.general(\r\n        \"DEBUG\",\r\n        \"API key available - refreshing session data\",\r\n      );\r\n\r\n      // Fetch user info\r\n      debugLogger.general(\"DEBUG\", \"Refreshing user info\");\r\n      const userInfo = await fetchUserInfo(apiKeyParam);\r\n      sessionCache.userInfo = userInfo;\r\n\r\n      // Fetch devices\r\n      debugLogger.general(\"DEBUG\", \"Refreshing devices\");\r\n      const devices = await fetchDevices(apiKeyParam);\r\n      sessionCache.devices = devices;\r\n\r\n      // ========================================\r\n      // PIPELINE 1: Incremental Auto-Open Pipeline (Refresh)\r\n      // ========================================\r\n      debugLogger.general('DEBUG', 'Pipeline 1: Refreshing incremental pushes');\r\n\r\n      const { pushes: incrementalPushes, isSeedRun } = await refreshPushesIncremental(apiKeyParam);\r\n\r\n      if (isSeedRun) {\r\n        debugLogger.general('INFO', 'Seed run: cutoff initialized; skipping processing and auto-open.');\r\n        // Update sessionCache.lastModifiedCutoff from storage\r\n        const updatedCutoff = await storageRepository.getLastModifiedCutoff();\r\n        sessionCache.lastModifiedCutoff = updatedCutoff ?? 0;\r\n        // Continue with initialization even on seed run\r\n      }\r\n\r\n      // Update sessionCache.lastModifiedCutoff from storage\r\n      const updatedCutoff = await storageRepository.getLastModifiedCutoff();\r\n      sessionCache.lastModifiedCutoff = updatedCutoff ?? 0;\r\n\r\n      // ========================================\r\n      // PIPELINE 2: Display History Pipeline (Refresh)\r\n      // ========================================\r\n      debugLogger.general('DEBUG', 'Pipeline 2: Refreshing display pushes');\r\n\r\n      const displayPushes = await fetchDisplayPushes(apiKeyParam, 50);\r\n      sessionCache.recentPushes = displayPushes;\r\n\r\n      debugLogger.general('INFO', 'Session refresh complete', {\r\n        incrementalCount: incrementalPushes.length,\r\n        displayCount: displayPushes.length,\r\n      });\r\n\r\n      // ========== ADD THIS ==========\r\n      // Refresh chats\r\n      try {\r\n        const chats = await fetchChats(apiKeyParam);\r\n        sessionCache.chats = chats;\r\n      } catch (error) {\r\n        debugLogger.general(\"WARN\", \"Failed to refresh chats\", {\r\n          error: (error as Error).message,\r\n        });\r\n      }\r\n      // ========== END ==========\r\n\r\n      // Update session cache\r\n      sessionCache.isAuthenticated = true;\r\n      sessionCache.lastUpdated = Date.now();\r\n\r\n      debugLogger.general(\"INFO\", \"Session cache refreshed successfully\", {\r\n        hasUserInfo: !!sessionCache.userInfo,\r\n        deviceCount: sessionCache.devices.length,\r\n        pushCount: sessionCache.recentPushes.length,\r\n        lastUpdated: new Date(sessionCache.lastUpdated).toISOString(),\r\n      });\r\n    } else {\r\n      debugLogger.general(\r\n        \"WARN\",\r\n        \"No API key available - cannot refresh session cache\",\r\n      );\r\n      sessionCache.isAuthenticated = false;\r\n    }\r\n  } catch (error) {\r\n    debugLogger.general(\r\n      \"ERROR\",\r\n      \"Error refreshing session cache\",\r\n      {\r\n        error: (error as Error).message,\r\n      },\r\n      error as Error,\r\n    );\r\n    throw error;\r\n  }\r\n}\r\n\r\n// *** ADD THESE 2 EXPORTS ***\r\nexport { isCacheFresh };\r\nexport { refreshSessionInBackground };\r\n", "import { debugLogger } from '../../lib/logging';\n\nconst OPENED_MRU_KEY = 'openedPushMRU';\nconst MRU_CAP = 500;\n\ntype OpenedMRU = {\n  idens: string[];       // newest-first\n  maxOpenedCreated: number; // largest push.created observed on auto-open\n};\n\nasync function loadMRU(): Promise<OpenedMRU> {\n  const raw = await chrome.storage.local.get(OPENED_MRU_KEY);\n  const mru = raw[OPENED_MRU_KEY] as OpenedMRU | undefined;\n  return mru ?? { idens: [], maxOpenedCreated: 0 };\n}\n\nasync function saveMRU(mru: OpenedMRU): Promise<void> {\n  await chrome.storage.local.set({ [OPENED_MRU_KEY]: mru });\n}\n\nexport async function hasOpenedIden(iden: string): Promise<boolean> {\n  const mru = await loadMRU();\n  return mru.idens.includes(iden);\n}\n\nexport async function markOpened(iden: string, created: number): Promise<void> {\n  const mru = await loadMRU();\n  // Fast skip if already present\n  if (!mru.idens.includes(iden)) {\n    mru.idens.unshift(iden);\n    if (mru.idens.length > MRU_CAP) mru.idens.length = MRU_CAP;\n  }\n  if (Number.isFinite(created) && created > mru.maxOpenedCreated) {\n    mru.maxOpenedCreated = created;\n  }\n  await saveMRU(mru);\n  debugLogger.general('DEBUG', `MRU: marked opened iden=${iden}, maxOpenedCreated=${mru.maxOpenedCreated}`);\n}\n\nexport async function getMaxOpenedCreated(): Promise<number> {\n  const mru = await loadMRU();\n  return mru.maxOpenedCreated || 0;\n}\n\nexport async function clearOpenedMRU(): Promise<void> {\n  await chrome.storage.local.set({\n    [OPENED_MRU_KEY]: { idens: [], maxOpenedCreated: 0 },\n  });\n}", "import { storageRepository } from '../infrastructure/storage/storage.repository';\nimport { clearOpenedMRU } from '../infrastructure/storage/opened-mru.repository';\nimport { debugLogger } from '../lib/logging';\n\nconst DEV_ENABLED = true; // or read from debugConfigManager\n\nexport function installDiagnosticsMessageHandler(): void {\n  chrome.runtime.onMessage.addListener((msg, _sender, sendResponse) => {\n    if (!DEV_ENABLED) return; // ignore in production\n    (async () => {\n      if (msg?.type === 'diag:dump-autoopen') {\n        const snap = await storageRepository.getAutoOpenDebugSnapshot();\n        debugLogger.general('INFO', 'DIAG auto-open snapshot', snap);\n        sendResponse({ ok: true, snap });\n      } else if (msg?.type === 'diag:clear-mru') {\n        await clearOpenedMRU();\n        debugLogger.general('WARN', 'DIAG MRU cleared by developer action');\n        const snap = await storageRepository.getAutoOpenDebugSnapshot();\n        debugLogger.general('INFO', 'DIAG auto-open snapshot (post-clear)', snap);\n        sendResponse({ ok: true, snap });\n      }\n    })();\n    return true; // async\n  });\n}", "import { debugLogger } from '../../lib/logging';\nimport { storageRepository } from '../../infrastructure/storage/storage.repository';\n\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.local\n// Security: API keys are stored in local storage (not synced) to prevent exposure\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n/**\n * Ensure critical configuration is loaded from storage\n * Used for service worker wake-ups to rehydrate state\n *\n * ARCHITECTURAL PATTERN: Uses StorageRepository for centralized storage access\n * All storage operations go through the repository pattern - NO direct chrome.storage calls\n *\n * @param stateSetters - Object containing state setter functions\n * @param stateGetters - Object containing state getter functions\n */\nexport async function ensureConfigLoaded(\n  stateSetters?: {\n    setApiKey: (key: string | null) => void;\n    setDeviceIden: (iden: string | null) => void;\n    setAutoOpenLinks: (value: boolean) => void;\n    setDeviceNickname: (nickname: string) => void;\n    setNotificationTimeout: (timeout: number) => void;\n  },\n  stateGetters?: {\n    getApiKey: () => string | null;\n    getDeviceIden: () => string | null;\n    getAutoOpenLinks: () => boolean;\n    getDeviceNickname: () => string;\n    getNotificationTimeout: () => number;\n  }\n): Promise<void> {\n  try {\n    if (!stateSetters || !stateGetters) {\n      // No state management provided, just return\n      return;\n    }\n\n    // Determine what needs to be loaded\n    const needsApiKey = !stateGetters.getApiKey();\n    const needsDeviceIden = !stateGetters.getDeviceIden();\n    const needsNickname = stateGetters.getDeviceNickname() === null || stateGetters.getDeviceNickname() === undefined;\n    const needsAutoOpen = stateGetters.getAutoOpenLinks() === null || stateGetters.getAutoOpenLinks() === undefined;\n    const needsTimeout = stateGetters.getNotificationTimeout() === null || stateGetters.getNotificationTimeout() === undefined;\n\n    // Load API key from repository (local storage, not synced)\n    if (needsApiKey) {\n      try {\n        const apiKey = await storageRepository.getApiKey();\n        if (apiKey) {\n          stateSetters.setApiKey(apiKey);\n        }\n      } catch (error) {\n        // Log storage errors in ensureConfigLoaded - these are non-critical for startup\n        debugLogger.general(\"WARN\", \"Failed to load API key from storage\", null, error as Error);\n      }\n    }\n\n    // Load device identifier from repository (local storage)\n    if (needsDeviceIden) {\n      try {\n        const deviceIden = await storageRepository.getDeviceIden();\n        if (deviceIden) {\n          stateSetters.setDeviceIden(deviceIden);\n        }\n      } catch (error) {\n        // Log storage errors in ensureConfigLoaded - these are non-critical for startup\n        debugLogger.general(\"WARN\", \"Failed to load device identifier from storage\", null, error as Error);\n      }\n    }\n\n    // Load device nickname from repository (synced storage)\n    if (needsNickname) {\n      try {\n        const deviceNickname = await storageRepository.getDeviceNickname();\n        if (deviceNickname !== null && deviceNickname !== undefined) {\n          stateSetters.setDeviceNickname(deviceNickname);\n        }\n      } catch (error) {\n        // Log storage errors in ensureConfigLoaded - these are non-critical for startup\n        debugLogger.general(\"WARN\", \"Failed to load device nickname from storage\", null, error as Error);\n      }\n    }\n\n    // Load auto-open links setting from repository (synced storage)\n    if (needsAutoOpen) {\n      try {\n        const autoOpenLinks = await storageRepository.getAutoOpenLinks();\n        if (autoOpenLinks !== null && autoOpenLinks !== undefined) {\n          stateSetters.setAutoOpenLinks(autoOpenLinks);\n        }\n      } catch (error) {\n        // Log storage errors in ensureConfigLoaded - these are non-critical for startup\n        debugLogger.general(\"WARN\", \"Failed to load auto-open links setting from storage\", null, error as Error);\n      }\n    }\n\n    // Load notification timeout from repository (synced storage)\n    if (needsTimeout) {\n      try {\n        const notificationTimeout = await storageRepository.getNotificationTimeout();\n        if (notificationTimeout !== null && notificationTimeout !== undefined) {\n          stateSetters.setNotificationTimeout(notificationTimeout);\n        }\n      } catch (error) {\n        // Log storage errors in ensureConfigLoaded - these are non-critical for startup\n        debugLogger.general(\"WARN\", \"Failed to load notification timeout from storage\", null, error as Error);\n      }\n    }\n\n    // Log completion\n    try {\n      debugLogger.storage('DEBUG', 'ensureConfigLoaded completed', {\n        hasApiKey: !!stateGetters.getApiKey(),\n        hasDeviceIden: !!stateGetters.getDeviceIden(),\n        autoOpenLinks: stateGetters.getAutoOpenLinks(),\n        notificationTimeout: stateGetters.getNotificationTimeout(),\n        deviceNickname: stateGetters.getDeviceNickname()\n      });\n    } catch (error) {\n      // Log logging errors in ensureConfigLoaded - these are non-critical\n      console.warn('Failed to log ensureConfigLoaded completion:', error);\n    }\n  } catch (e) {\n    try {\n      debugLogger.storage('WARN', 'ensureConfigLoaded encountered an error', {\n        error: e && (e as Error).message\n      });\n    } catch (error) {\n      // Log logging errors in ensureConfigLoaded - these are non-critical\n      console.warn('Failed to log ensureConfigLoaded error:', error);\n    }\n  }\n}\n\n", "/**\n * Pushbullet End-to-End Encryption (E2EE) Decryption\n * \n * Based on Pushbullet's E2EE specification:\n * - Key derivation: PBKDF2 with HMAC-SHA256\n * - Encryption: AES-256-GCM\n * - Encoding: Base64\n */\n\nimport type { Push } from '../../types/domain';\n\nexport class PushbulletCrypto {\n  /**\n   * Generate encryption/decryption key from password\n   * @param password - User's encryption password\n   * @param userIden - User's iden (used as salt)\n   * @returns Derived key for AES-GCM\n   */\n  static async deriveKey(password: string, userIden: string): Promise<CryptoKey> {\n    // Check if Web Crypto API is available\n    if (!globalThis.crypto || !crypto.subtle) {\n      throw new Error('Web Crypto API unavailable - requires HTTPS or localhost');\n    }\n\n    // Convert password to bytes\n    const encoder = new TextEncoder();\n    const passwordBytes = encoder.encode(password);\n    \n    // Import password as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      passwordBytes,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits', 'deriveKey']\n    );\n    \n    // Use user iden as salt\n    const salt = encoder.encode(userIden);\n    \n    // Derive key using PBKDF2\n    const key = await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: salt,\n        iterations: 30000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      { name: 'AES-GCM', length: 256 },\n      false,\n      ['decrypt']\n    );\n    \n    return key;\n  }\n  \n  /**\n   * Decrypt an encrypted message\n   * @param encodedMessage - Base64 encoded encrypted message\n   * @param key - Decryption key\n   * @returns Decrypted message object\n   */\n  static async decryptMessage(encodedMessage: string, key: CryptoKey): Promise<unknown> {\n    try {\n      // Decode from base64\n      const encryptedData = this.base64ToBytes(encodedMessage);\n      \n      // Parse the encoded message format:\n      // version (1 byte) + tag (16 bytes) + iv (12 bytes) + ciphertext (rest)\n      const version = encryptedData[0];\n      \n      if (version !== 49) { // ASCII '1'\n        throw new Error(`Unsupported encryption version: ${version}`);\n      }\n      \n      const tag = encryptedData.slice(1, 17);        // 16 bytes\n      const iv = encryptedData.slice(17, 29);        // 12 bytes (96 bits)\n      const ciphertext = encryptedData.slice(29);    // Rest\n      \n      // Combine ciphertext and tag for AES-GCM\n      const combined = new Uint8Array(ciphertext.length + tag.length);\n      combined.set(ciphertext);\n      combined.set(tag, ciphertext.length);\n      \n      // Decrypt using AES-GCM\n      const decrypted = await crypto.subtle.decrypt(\n        {\n          name: 'AES-GCM',\n          iv: iv,\n          tagLength: 128 // 16 bytes = 128 bits\n        },\n        key,\n        combined\n      );\n      \n      // Convert decrypted bytes to string\n      const decoder = new TextDecoder();\n      const decryptedText = decoder.decode(decrypted);\n      \n      // Parse as JSON\n      return JSON.parse(decryptedText);\n    } catch {\n      // SECURITY FIX (M-04): Don't log sensitive crypto data\n      console.error('Decryption error - check encryption password');\n      throw new Error('Failed to decrypt message. Check your encryption password.');\n    }\n  }\n  \n  /**\n   * Convert base64 string to Uint8Array\n   * @param base64 - Base64 encoded string\n   * @returns Decoded bytes\n   */\n  static base64ToBytes(base64: string): Uint8Array {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n  \n  /**\n   * Decrypt a Pushbullet encrypted push\n   * @param encryptedPush - Push object with 'encrypted' and 'ciphertext' fields\n   * @param password - User's encryption password\n   * @param userIden - User's iden\n   * @returns Decrypted push data\n   */\n  static async decryptPush(encryptedPush: Push, password: string, userIden: string): Promise<Push> {\n    if (!encryptedPush.encrypted || !encryptedPush.ciphertext) {\n      throw new Error('Push is not encrypted');\n    }\n    \n    // Derive key from password\n    const key = await this.deriveKey(password, userIden);\n    \n    // Decrypt the ciphertext\n    const decryptedData = await this.decryptMessage(encryptedPush.ciphertext, key);\n    \n    // Return decrypted push with original metadata\n    return {\n      ...encryptedPush,\n      ...(decryptedData as object),\n      encrypted: false // Mark as decrypted\n    } as Push;\n  }\n}\n\n", "/**\n * Global state management for background service worker\n */\n\n\nimport { WebSocketClient } from '../app/ws/client';\n\n// API constants\nexport const API_BASE_URL = 'https://api.pushbullet.com/v2';\nexport const PUSHES_URL = `${API_BASE_URL}/pushes`;\nexport const DEVICES_URL = `${API_BASE_URL}/devices`;\nexport const USER_INFO_URL = `${API_BASE_URL}/users/me`;\nexport const WEBSOCKET_URL = 'wss://stream.pushbullet.com/websocket/';\n\n// Global state variables\nlet apiKey: string | null = null;\nlet deviceIden: string | null = null;\nlet deviceNickname = 'Chrome';\nlet autoOpenLinks = true;\nlet notificationTimeout = 10000;\nlet websocketClient: WebSocketClient | null = null;\nlet pollingMode = false;\nlet lastDisconnectionNotification = 0;\n\n// Constants\nexport const DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\nexport const DISCONNECTION_NOTIFICATION_THRESHOLD = 300000; // 5 minutes\n\n\n\n// NO ENCRYPTION/DECRYPTION - API key is stored in plain text in chrome.storage.local\n// Security: API keys are stored in local storage (not synced) to prevent exposure\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n// Getters and setters\nexport function getApiKey(): string | null {\n  return apiKey;\n}\n\nexport function setApiKey(key: string | null): void {\n  apiKey = key;\n}\n\nexport function getDeviceIden(): string | null {\n  return deviceIden;\n}\n\nexport function setDeviceIden(iden: string | null): void {\n  deviceIden = iden;\n}\n\nexport function getDeviceNickname(): string {\n  return deviceNickname;\n}\n\nexport function setDeviceNickname(nickname: string): void {\n  deviceNickname = nickname;\n}\n\nexport function getAutoOpenLinks(): boolean {\n  return autoOpenLinks;\n}\n\nexport function setAutoOpenLinks(value: boolean): void {\n  autoOpenLinks = value;\n}\n\nexport function getNotificationTimeout(): number {\n  return notificationTimeout;\n}\n\nexport function setNotificationTimeout(timeout: number): void {\n  notificationTimeout = timeout;\n}\n\nexport function getWebSocketClient(): WebSocketClient | null {\n  return websocketClient;\n}\n\nexport function setWebSocketClient(client: WebSocketClient | null): void {\n  websocketClient = client;\n}\n\nexport function isPollingMode(): boolean {\n  return pollingMode;\n}\n\nexport function setPollingMode(mode: boolean): void {\n  pollingMode = mode;\n}\n\nexport function getLastDisconnectionNotification(): number {\n  return lastDisconnectionNotification;\n}\n\nexport function setLastDisconnectionNotification(timestamp: number): void {\n  lastDisconnectionNotification = timestamp;\n}\n\n", "import {\n  fetchIncrementalPushes,\n  dismissPush,\n} from \"../app/api/client\"; // dismissPush added\nimport { storageRepository } from \"../infrastructure/storage/storage.repository\";\nimport { hasOpenedIden, markOpened, getMaxOpenedCreated } from \"../infrastructure/storage/opened-mru.repository\";\nimport type { Push } from \"../types/domain\";\nimport { debugLogger } from \"../lib/logging\";\nimport { getApiKey } from \"./state\"; // \u2B05\uFE0F NEW LINE\n\nfunction isLinkPush(p: Push): p is Push & { url: string; iden: string } {\n  return p.type === \"link\" && typeof p.url === \"string\" && p.url.length > 0 && typeof p.iden === \"string\";\n}\n\n/**\n * Opens a URL in a new tab (or window as fallback).\n *\n * This function attempts to open a URL in a new background tab first.\n * If that fails (due to focus restrictions, permissions, or browser state),\n * it falls back to creating a new window.\n *\n * Both operations are non-intrusive:\n * - Tabs are created with `active: false` (background)\n * - Windows are created with `focused: false` (background)\n *\n * @param url - The URL to open. Must be a valid HTTP/HTTPS URL.\n * @returns Promise that resolves when the tab/window is created, or rejects if both fail.\n */\nexport async function openTab(url: string): Promise<void> {\n  if (!url || typeof url !== \"string\") {\n    debugLogger.general(\"WARN\", \"Invalid URL (empty or non-string)\", { url });\n    throw new Error(\"Invalid URL\");\n  }\n  let parsed: URL;\n  try {\n    parsed = new URL(url);\n  } catch {\n    debugLogger.general(\"WARN\", \"Invalid URL (parse failed)\", { url });\n    throw new Error(\"Invalid URL\");\n  }\n  if (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n    debugLogger.general(\"WARN\", \"Invalid URL (protocol rejected)\", {\n      url,\n      protocol: parsed.protocol,\n    });\n    throw new Error(\"Invalid protocol\");\n  }\n  try {\n    await chrome.tabs.create({ url, active: false });\n    debugLogger.general(\"DEBUG\", \"Tab created successfully\", { url });\n  } catch {\n    debugLogger.general(\"WARN\", \"Tab creation failed, trying window fallback\", {\n      url,\n    });\n    await chrome.windows.create({ url, focused: false });\n    debugLogger.general(\"INFO\", \"Window created as fallback\", { url });\n  }\n}\n\nexport async function autoOpenOfflineLinks(\n  apiKey: string,\n  sessionCutoff: number | null,\n): Promise<void> {\n  const enabled = await storageRepository.getAutoOpenLinksOnReconnect();\n  if (!enabled) {\n    debugLogger.websocket(\"DEBUG\", \"Auto-open offline links disabled\");\n    return;\n  }\n\n  const safetyCap = await storageRepository.getMaxAutoOpenPerReconnect();\n  const lastAuto = (await storageRepository.getLastAutoOpenCutoff()) || 0;\n  const modifiedAfter = Math.max(lastAuto, sessionCutoff || 0);\n\n  debugLogger.websocket(\n    \"INFO\",\n    \"Auto-open links: fetching incremental changes\",\n    { modifiedAfter },\n  );\n\n  const changes = await fetchIncrementalPushes(apiKey, modifiedAfter, 100);\n\n  // New: apply MRU + created guards before selecting toOpen\n  const maxOpenedCreated = await getMaxOpenedCreated();\n  const candidates = changes\n    .filter(isLinkPush)\n    .filter(p => {\n      const created = typeof p.created === 'number' ? p.created : 0;\n      return created > lastAuto && created > maxOpenedCreated;\n    })\n    .sort((a, b) => (a.created ?? 0) - (b.created ?? 0));\n\n  if (candidates.length === 0) {\n    debugLogger.websocket(\"INFO\", \"Auto-open links: no new link pushes to open\");\n    return;\n  }\n\n  debugLogger.websocket(\"INFO\", \"Auto-opening link pushes\", {\n    count: candidates.length,\n    total: candidates.length,\n  });\n\n  const openedCreated: number[] = [];\n  let openedThisRun = 0;\n\n  // Pre-loop optimization (added in Step 4C)\n  const shouldDismiss = await storageRepository.getDismissAfterAutoOpen();\n  const dismissApiKey = getApiKey();\n\n  for (const p of candidates) {\n    if (openedThisRun >= safetyCap) {\n      debugLogger.websocket(\"WARN\", \"Auto-open links capped\", {\n        opened: openedThisRun,\n        total: candidates.length,\n        cap: safetyCap,\n      });\n      break;\n    }\n\n    if (await hasOpenedIden(p.iden)) {\n      debugLogger.websocket(\"DEBUG\", \"Auto-open skip (MRU)\", { iden: p.iden });\n      continue;\n    }\n\n    try {\n      await openTab(p.url);\n      await markOpened(p.iden, p.created ?? 0);\n      debugLogger.websocket(\"DEBUG\", \"MRU marked opened\", {\n        iden: p.iden,\n        created: p.created ?? 0,\n      });\n\n      // Dismiss after auto-open (matches real-time behavior)\n      if (shouldDismiss && dismissApiKey && p.iden) {\n        try {\n          await dismissPush(p.iden, dismissApiKey);\n          debugLogger.websocket(\n            \"INFO\",\n            `Offline AutoOpen: dismissed iden=${p.iden} after auto-open`,\n          );\n        } catch (e) {\n          debugLogger.websocket(\n            \"WARN\",\n            `Offline AutoOpen: dismiss failed for iden=${p.iden}: ${(e as Error).message}`,\n          );\n        }\n      }\n\n      openedThisRun += 1;\n      openedCreated.push(p.created ?? 0);\n    } catch {\n      debugLogger.websocket(\"WARN\", \"Auto-open failed\", { iden: p.iden, url: p.url });\n    }\n  }\n\n  const maxCreated = Math.max(lastAuto, ...openedCreated, 0);\n  if (maxCreated > lastAuto) {\n    await storageRepository.setLastAutoOpenCutoff(maxCreated);\n    debugLogger.websocket(\"INFO\", \"Advanced lastAutoOpenCutoff\", { old: lastAuto, new: maxCreated });\n  }\n}\n\n", "import { storageRepository } from '../infrastructure/storage/storage.repository';\nimport { hasOpenedIden, markOpened, getMaxOpenedCreated } from '../infrastructure/storage/opened-mru.repository';\nimport { debugLogger } from '../lib/logging';\nimport { dismissPush } from '../app/api/client';\nimport { getApiKey } from './state';\nimport { openTab } from './links';\n\nasync function maybeAutoOpenLink(push: { iden?: string; type: string; url?: string; created?: number }): Promise<boolean> {\n  if (!push.iden || push.type !== 'link' || !push.url) return false;\n  const created = typeof push.created === 'number' ? push.created : 0;\n  const lastAuto = (await storageRepository.getLastAutoOpenCutoff()) ?? 0;\n  const maxOpenedCreated = await getMaxOpenedCreated();\n\n  // MRU skip check with log\n  if (await hasOpenedIden(push.iden)) {\n    debugLogger.general('DEBUG', 'Auto-open skip (MRU)', { iden: push.iden });\n    return false;\n  }\n\n  // Created-time guards stay unchanged\n  if (!(created > lastAuto && created > maxOpenedCreated)) {\n    debugLogger.general('DEBUG', 'Auto-open skip (created guard)', {\n      iden: push.iden,\n      created,\n      lastAuto,\n      maxOpenedCreated,\n    });\n    return false;\n  }\n\n  try {\n    await openTab(push.url!);\n    await markOpened(push.iden!, created);\n    debugLogger.general('DEBUG', 'MRU marked opened', {\n      iden: push.iden,\n      created,\n    });\n    const nextCutoff = Math.max(lastAuto, created);\n    await storageRepository.setLastAutoOpenCutoff(nextCutoff);\n    debugLogger.general('INFO', 'Advanced lastAutoOpenCutoff', {\n      old: lastAuto,\n      new: nextCutoff,\n    });\n    return true;\n  } catch (e) {\n    debugLogger.general('WARN', `AutoOpen: failed to open iden=${push.iden}: ${(e as Error).message}`);\n    return false;\n  }\n}\n\nexport async function maybeAutoOpenLinkWithDismiss(push: { iden?: string; type: string; url?: string; created?: number }): Promise<boolean> {\n  const opened = await maybeAutoOpenLink(push);\n  if (!opened || !push.iden) return false;\n\n  if (await storageRepository.getDismissAfterAutoOpen()) {\n    try {\n      const apiKey = getApiKey();\n      if (apiKey) {\n        await dismissPush(push.iden, apiKey);\n        debugLogger.general('INFO', `AutoOpen: dismissed iden=${push.iden} after auto-open`);\n      }\n    } catch (e) {\n      debugLogger.general('WARN', `AutoOpen: dismiss failed for iden=${push.iden}: ${(e as Error).message}`);\n    }\n  }\n  return true;\n}", "/**\n * Utility functions for background service worker\n */\n\nimport { debugLogger } from \"../lib/logging\";\nimport { performanceMonitor } from \"../lib/perf\";\nimport { sessionCache, hydrateCutoff, setLastModifiedCutoffSafe } from \"../app/session\";\nimport { fetchIncrementalPushes } from \"../app/api/client\";\nimport { storageRepository } from \"../infrastructure/storage/storage.repository\";\nimport {\n  getApiKey,\n  setPollingMode,\n  isPollingMode,\n} from \"./state\";\nimport type { Push } from \"../types/domain\";\nimport { createNotificationWithTimeout } from \"../app/notifications\";\nimport { ensureConfigLoaded } from \"../app/reconnect\";\nimport { globalEventBus } from \"../lib/events/event-bus\";\nimport { ServiceWorkerState } from \"./state-machine\";\nimport { stateMachine } from \"./index\";\nimport { maybeAutoOpenLinkWithDismiss } from \"./processing\";\n\n// Guard flag to prevent concurrent context menu setup\n// Ensures idempotent behavior when multiple startup events fire\nlet isSettingUpContextMenu = false;\n\n/**\n * Connection status for icon updates\n */\nexport type ConnectionStatus =\n  | \"connected\"\n  | \"connecting\"\n  | \"disconnected\"\n  | \"degraded\";\n\n/**\n * Sanitize text to prevent XSS attacks\n * Removes HTML tags and dangerous characters\n *\n * DEFENSE-IN-DEPTH STRATEGY:\n * 1. This function provides basic sanitization for Chrome notification content\n * 2. The extension's CSP (Content Security Policy) provides strong XSS protection\n * 3. UI code (popup, options, etc.) uses textContent instead of innerHTML for user data\n * 4. This regex-based approach is sufficient for notification text (not rendered as HTML)\n *\n * NOTE: For HTML rendering, use textContent or a library like DOMPurify.\n * The popup's displayPushes() function correctly uses textContent for all user data.\n */\nfunction sanitizeText(text: string): string {\n  if (!text) return \"\";\n\n  // Remove HTML tags\n  let sanitized = text.replace(/<[^>]*>/g, \"\");\n\n  // Remove script-like content\n  sanitized = sanitized.replace(/javascript:/gi, \"\");\n  sanitized = sanitized.replace(/on\\w+\\s*=/gi, \"\");\n\n  // Trim and limit length\n  sanitized = sanitized.trim().substring(0, 1000);\n\n  return sanitized;\n}\n\n/**\n * Sanitize URL to prevent XSS attacks\n * Validates URL format and ensures it's safe\n */\nfunction sanitizeUrl(url: string): string {\n  if (!url) return \"\";\n\n  try {\n    const urlObj = new URL(url);\n    // Only allow http/https protocols\n    if (urlObj.protocol !== \"http:\" && urlObj.protocol !== \"https:\") {\n      return \"\";\n    }\n    return url;\n  } catch {\n    debugLogger.general(\"WARN\", \"Invalid URL provided\", { url });\n    return \"\";\n  }\n}\n\n/**\n * Validates if a given URL belongs to trusted domains for image loading.\n * This includes Pushbullet domains and Google secure content domains.\n * @param urlString The URL to validate.\n * @returns True if the URL is from a trusted domain, false otherwise.\n */\nfunction isTrustedImageUrl(urlString: string): boolean {\n  if (!urlString) {\n    return false;\n  }\n\n  try {\n    const url = new URL(urlString);\n    // Trust Pushbullet domains and Google secure content domains\n    return (\n      url.hostname.endsWith(\".pushbullet.com\") ||\n      url.hostname.endsWith(\".pushbulletusercontent.com\") ||\n      /^lh[0-9]\\.googleusercontent\\.com$/.test(url.hostname)\n    );\n  } catch {\n    debugLogger.general(\"WARN\", \"Could not parse URL for domain check\", {\n      url: urlString,\n    });\n    return false;\n  }\n}\n\n/**\n * Update extension icon tooltip to show current state\n */\nexport function updateExtensionTooltip(stateDescription: string): void {\n  try {\n    chrome.action.setTitle({ title: stateDescription });\n    debugLogger.general(\"DEBUG\", \"Updated extension tooltip\", {\n      stateDescription,\n    });\n  } catch (error) {\n    debugLogger.general(\"ERROR\", \"Exception setting tooltip\", {\n      stateDescription,\n      error: (error as Error).message,\n    });\n  }\n}\n\n/**\n * Update extension icon based on connection status\n * Uses badge color instead of different icon files since service workers have issues loading icons\n */\nexport function updateConnectionIcon(status: ConnectionStatus): void {\n  try {\n    // Set badge text\n    const badgeText = \" \";\n\n    // Set badge color\n    const badgeColor =\n      status === \"connected\"\n        ? \"#4CAF50\" // Green\n        : status === \"connecting\"\n          ? \"#FFC107\" // Yellow\n          : status === \"degraded\"\n            ? \"#00BCD4\" // Cyan\n            : \"#F44336\"; // Red\n\n    chrome.action.setBadgeText({ text: badgeText });\n    chrome.action.setBadgeBackgroundColor({ color: badgeColor });\n\n    debugLogger.general(\"DEBUG\", \"Updated connection status badge\", {\n      status,\n      badgeText,\n      badgeColor,\n    });\n  } catch (error) {\n    debugLogger.general(\n      \"ERROR\",\n      \"Exception setting badge\",\n      {\n        status,\n        error: (error as Error).message,\n      },\n      error as Error,\n    );\n  }\n}\n\nfunction upsertPushes(\n  existing: Push[],\n  incoming: Push[]\n): [updated: Push[], newOnes: Push[]] {\n  const map = new Map(existing.map(p => [p.iden, p]));\n  const newOnes: Push[] = [];\n\n  for (const p of incoming) {\n    if (map.has(p.iden)) {\n      map.set(p.iden, { ...map.get(p.iden)!, ...p }); // merge updates like dismissed\n    } else {\n      newOnes.push(p);\n      map.set(p.iden, p);\n    }\n  }\n\n  // Keep most-recent-first, cap length to prevent unbounded growth (e.g., 200)\n  const updated = Array.from(map.values()).sort((a, b) => (b.created || 0) - (a.created || 0)).slice(0, 200);\n  return [updated, newOnes];\n}\n\n/**\n * Refresh pushes from API and show notifications for new ones\n */\nexport async function refreshPushes(\n  notificationDataStore?: Map<string, Push>,\n): Promise<void> {\n  await ensureConfigLoaded(); // already present in background flow\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot refresh pushes - no API key');\n    return;\n  }\n\n  try {\n    // ========================================\n    // PIPELINE 1: Incremental Auto-Open Pipeline\n    // ========================================\n    // Fetch only NEW pushes since last check for auto-opening\n\n    debugLogger.general('DEBUG', 'Pipeline 1: Checking for new pushes (incremental)');\n\n    const cutoff = sessionCache.lastModifiedCutoff ?? (await storageRepository.getLastModifiedCutoff()) ?? 0;\n    const incrementalPushes = await fetchIncrementalPushes(apiKey, cutoff, 100);\n\n    debugLogger.general('INFO', 'Pipeline 1: Incremental fetch complete', {\n      newPushCount: incrementalPushes.length,\n      cutoff,\n    });\n\n    if (incrementalPushes.length === 0) {\n      debugLogger.general('INFO', 'Pipeline 1: No new pushes to process');\n      return; // Nothing new, exit early\n    }\n\n    // Update cutoff timestamp\n    const maxModified = Math.max(\n      cutoff,\n      ...incrementalPushes.map((p) => (typeof p.modified === 'number' ? p.modified : 0))\n    );\n\n    if (maxModified > cutoff) {\n      sessionCache.lastModifiedCutoff = maxModified;\n      await setLastModifiedCutoffSafe(maxModified);\n\n      debugLogger.general('INFO', 'Pipeline 1 Updated cutoff via safe setter', {\n        old: cutoff,\n        new: maxModified,\n      });\n    }\n\n    // ========================================\n    // PIPELINE 2: Update Display Data\n    // ========================================\n    // Merge new pushes into display array using upsert\n\n    debugLogger.general('DEBUG', 'Pipeline 2: Updating display pushes');\n\n    const [updatedDisplayPushes, newPushes] = upsertPushes(\n      sessionCache.recentPushes ?? [],\n      incrementalPushes\n    );\n\n    sessionCache.recentPushes = updatedDisplayPushes;\n    sessionCache.lastUpdated = Date.now();\n\n    debugLogger.general('INFO', 'Pipeline 2: Display updated', {\n      totalDisplayPushes: updatedDisplayPushes.length,\n      newPushes: newPushes.length,\n    });\n\n    // ========================================\n    // Process New Pushes (Notifications & Auto-Open)\n    // ========================================\n    // Only notify and auto-open for truly NEW pushes (from newPushes array)\n\n    let openedThisRun = 0;\n    const cap = await storageRepository.getMaxAutoOpenPerReconnect();\n\n    for (const push of newPushes) {\n      debugLogger.general('INFO', 'Processing new push', {\n        pushIden: push.iden,\n        pushType: push.type,\n      });\n\n      // Show notification\n      void showPushNotification(push, notificationDataStore).catch((error) => {\n        debugLogger.general('ERROR', 'Failed to show notification', {\n          pushIden: push.iden,\n        }, error);\n      });\n\n      // Auto-open links if enabled\n      // Pre-check: if threshold already reached, log once and skip further opens\n      if (openedThisRun >= cap) {\n        debugLogger.general('WARN', 'Auto-open links capped', {\n          opened: openedThisRun,\n          total: newPushes.length,\n          cap,\n        });\n        continue; // No more auto-open attempts this run\n      }\n\n      const opened = await maybeAutoOpenLinkWithDismiss(push);\n      if (opened) {\n        openedThisRun += 1;\n\n        // Post-check: if we just hit threshold, log now\n        if (openedThisRun >= cap) {\n          debugLogger.general('WARN', 'Auto-open links capped', {\n            opened: openedThisRun,\n            total: newPushes.length,\n            cap,\n          });\n          // Do not attempt further opens in this run; loop continues but pre-check will skip them\n        }\n      }\n    }\n\n    // Notify popup of updated data\n    chrome.runtime\n      .sendMessage({\n        action: 'pushesUpdated',\n        pushes: sessionCache.recentPushes,\n      })\n      .catch(() => undefined);\n\n  } catch (error) {\n    debugLogger.general('ERROR', 'Incremental refresh failed', {}, error as Error);\n    performanceMonitor.recordHealthCheckFailure();\n  }\n}\n\n/**\n * Counter for notification IDs\n */\nlet counter = 0;\n\n/**\n * Show push notification\n */\nexport async function showPushNotification(\n  push: Push,\n  notificationDataStore?: Map<string, Push>,\n): Promise<void> {\n  try {\n    // --- NEW GUARD CLAUSE: START ---\n    // This specifically catches the empty push that follows an SMS deletion.\n    // It checks for a push that is 'sms_changed' but has an empty or missing 'notifications' array.\n    if (\n      (push as any).type === \"sms_changed\" &&\n      (!(push as any).notifications || (push as any).notifications.length === 0)\n    ) {\n      debugLogger.notifications(\n        \"INFO\",\n        \"Ignoring sms_changed push with no notification content (deletion event).\",\n        { pushIden: push.iden },\n      );\n      return; // Exit the function immediately.\n    }\n    // --- NEW GUARD CLAUSE: END ---\n\n    const notificationId = `pushbullet-push-${counter++}-${Date.now()}`;\n    const baseOptions = {\n      iconUrl: chrome.runtime.getURL(\"icons/icon128.png\"),\n    };\n\n    let notificationOptions: chrome.notifications.NotificationOptions = {\n      ...baseOptions,\n      type: \"basic\",\n      title: \"Pushbullet\",\n      message: \"New push received\",\n    };\n\n    // Handle undecrypted pushes first\n    if (push.encrypted && \"ciphertext\" in push) {\n      notificationOptions = {\n        ...baseOptions,\n        type: \"basic\",\n        title: \"Pushbullet\",\n        message:\n          \"An encrypted push was received. To view future encrypted pushes you need to add the correct end2end password in options\",\n      };\n      debugLogger.notifications(\n        \"INFO\",\n        \"Showing notification for undecrypted push\",\n      );\n    } else if ((push as any).type === \"sms_changed\") {\n      // The condition is now much simpler because the guard clause at the top\n      // has already guaranteed that if we get here, the 'notifications' array\n      // exists and is not empty.\n\n      debugLogger.notifications(\n        \"DEBUG\",\n        \"Complete sms_changed push object received\",\n        { push },\n      );\n      const sms = (push as any).notifications[0];\n\n      // This redundant check is now removed, as the guard clause handles all empty cases.\n      // if (!sms.body) { ... }\n\n      const title = sms.title || \"New SMS\";\n      const message = sms.body; // We can trust that 'body' exists.\n      const imageUrl = sms.image_url;\n\n      if (imageUrl && isTrustedImageUrl(imageUrl)) {\n        try {\n          debugLogger.notifications(\n            \"DEBUG\",\n            \"Fetching contact photo for SMS notification\",\n            {\n              imageUrl,\n            },\n          );\n\n          // Fetch the image and convert to data URL to avoid CORS issues\n          const response = await fetch(imageUrl);\n\n          if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n          }\n\n          const blob = await response.blob();\n\n          // Convert blob to data URL\n          const reader = new FileReader();\n          const dataUrl = await new Promise<string>((resolve, reject) => {\n            reader.onloadend = () => resolve(reader.result as string);\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n          });\n\n          debugLogger.notifications(\"DEBUG\", \"Contact photo converted to data URL\", {\n            originalUrl: imageUrl,\n            dataUrlLength: dataUrl.length,\n            blobSize: blob.size,\n            blobType: blob.type,\n          });\n\n          // Use data URL for notification (avoids CORS issues)\n          notificationOptions = {\n            ...baseOptions,\n            type: \"basic\",\n            title: title,\n            message: message,\n            iconUrl: dataUrl,\n          };\n\n          debugLogger.notifications(\n            \"INFO\",\n            \"Showing business card SMS notification with contact photo\",\n            {\n              title,\n              hasIcon: true,\n            },\n          );\n        } catch (error) {\n          debugLogger.notifications(\n            \"WARN\",\n            \"Failed to fetch/convert contact photo, showing SMS without image\",\n            {\n              imageUrl,\n              error: (error as Error).message,\n            },\n          );\n\n          // Fallback: notification without image\n          notificationOptions = {\n            ...baseOptions,\n            type: \"basic\",\n            title: title,\n            message: message,\n          };\n        }\n      } else {\n        // Regular SMS without photo\n        notificationOptions = {\n          ...baseOptions,\n          type: \"basic\",\n          title: title,\n          message: message,\n        };\n\n        debugLogger.notifications(\"INFO\", \"Showing basic notification for SMS\", {\n          title,\n          hasImage: false,\n        });\n      }\n    } else {\n      // Standard handler for note, link, and file\n      let title = \"Pushbullet\";\n      let message = \"\";\n\n      if (push.type === \"note\") {\n        title = push.title || \"New Note\";\n        message = push.body || \"\";\n\n        notificationOptions = {\n          ...baseOptions,\n          type: \"basic\",\n          title: title,\n          message: message,\n        };\n      } else if (push.type === \"link\") {\n        title = push.title || push.url || \"New Link\";\n        message = push.url || \"\";\n\n        notificationOptions = {\n          ...baseOptions,\n          type: \"basic\",\n          title: title,\n          message: message,\n        };\n      } else if (push.type === \"file\") {\n        // Security validation for image URLs in file pushes\n        debugLogger.notifications(\n          \"DEBUG\",\n          \"Complete file push object received\",\n          { push },\n        );\n\n        let fileTitle = \"New File\";\n        let fileMessage = \"\";\n\n        if ((push as any).title) {\n          // MMS-style file push\n          fileTitle = (push as any).title;\n          fileMessage =\n            (push as any).body || `Image (${(push as any).file_type})`;\n        } else {\n          // Regular file push\n          fileTitle = `New File: ${(push as any).file_name || \"unknown file\"}`;\n          fileMessage = (push as any).body || (push as any).file_type || \"\";\n        }\n\n        // Security validation for image URLs - check both image_url and file_url\n        const imageUrl = (push as any).image_url;\n        const fileUrl = (push as any).file_url;\n\n        // Determine which URL to use for image preview\n        let previewUrl = null;\n        if (imageUrl && isTrustedImageUrl(imageUrl)) {\n          previewUrl = imageUrl;\n        } else if (\n          fileUrl &&\n          isTrustedImageUrl(fileUrl) &&\n          (push as any).file_type?.startsWith(\"image/\")\n        ) {\n          previewUrl = fileUrl;\n        }\n\n        if (previewUrl) {\n          // Show image notification for trusted Pushbullet URLs\n          notificationOptions = {\n            ...baseOptions,\n            type: \"image\",\n            title: fileTitle,\n            message: fileMessage,\n            imageUrl: previewUrl,\n          };\n          debugLogger.notifications(\n            \"INFO\",\n            \"Showing image notification for trusted file push\",\n            {\n              fileName: (push as any).file_name,\n              previewUrl: previewUrl,\n            },\n          );\n        } else {\n          // Fallback to basic notification for security\n          notificationOptions = {\n            ...baseOptions,\n            type: \"basic\",\n            title: fileTitle,\n            message: fileMessage,\n          };\n          if (imageUrl && !isTrustedImageUrl(imageUrl)) {\n            debugLogger.notifications(\n              \"WARN\",\n              \"Ignored image from untrusted domain for file push\",\n              {\n                imageUrl: imageUrl,\n              },\n            );\n          }\n        }\n      } else if (push.type === \"mirror\") {\n        // Format title as \"AppName: SenderName\" for better clarity\n        const mirrorTitle =\n          push.application_name && push.title\n            ? `${push.application_name}: ${push.title}`\n            : push.title || push.application_name || \"Notification\";\n        const mirrorMessage = push.body || \"\";\n        const iconData = (push as any).icon;\n\n        // Check if mirror has an icon (base64 image data)\n        if (iconData && typeof iconData === 'string' && iconData.startsWith('/9j/')) {\n          debugLogger.notifications(\"DEBUG\", \"Processing mirror notification icon\", {\n            iconDataLength: iconData.length,\n            title: mirrorTitle,\n          });\n\n          // Icon is already base64 JPEG data, just add data URL prefix\n          const dataUrl = `data:image/jpeg;base64,${iconData}`;\n\n          notificationOptions = {\n            ...baseOptions,\n            type: \"basic\",\n            title: mirrorTitle,\n            message: mirrorMessage,\n            iconUrl: dataUrl,\n          };\n\n          debugLogger.notifications(\"INFO\", \"Showing mirror notification with icon\", {\n            title: mirrorTitle,\n            hasIcon: true,\n            application: push.application_name,\n          });\n        } else {\n          // Security validation for image URLs (fallback)\n          const mirrorImageUrl = (push as any).image_url;\n          if (mirrorImageUrl && isTrustedImageUrl(mirrorImageUrl)) {\n            notificationOptions = {\n              ...baseOptions,\n              type: \"image\",\n              title: mirrorTitle,\n              message: mirrorMessage,\n              imageUrl: mirrorImageUrl,\n            };\n            debugLogger.notifications(\n              \"INFO\",\n              \"Showing image notification for trusted mirrored push\",\n              { pushType: push.type },\n            );\n          } else {\n            // No icon, show basic notification\n            notificationOptions = {\n              ...baseOptions,\n              type: \"basic\",\n              title: mirrorTitle,\n              message: mirrorMessage,\n            };\n\n            debugLogger.notifications(\"INFO\", \"Showing mirror notification without icon\", {\n              title: mirrorTitle,\n              hasIcon: false,\n              application: push.application_name,\n            });\n          }\n        }\n      } else {\n        // Default handler for other types\n        const defaultTitle = \"Pushbullet\";\n        const defaultMessage = `New ${push.type}`;\n\n        notificationOptions = {\n          ...baseOptions,\n          type: \"basic\",\n          title: defaultTitle,\n          message: defaultMessage,\n        };\n        debugLogger.notifications(\"INFO\", \"Showing basic notification\", {\n          pushType: push.type,\n        });\n      }\n    }\n\n    // Ensure all required properties are defined\n    const finalNotificationOptions: chrome.notifications.NotificationCreateOptions =\n      {\n        type: notificationOptions.type || \"basic\",\n        title: notificationOptions.title || \"Pushbullet\",\n        message: notificationOptions.message || \"New push received\",\n        iconUrl:\n          notificationOptions.iconUrl ||\n          chrome.runtime.getURL(\"icons/icon128.png\"),\n      };\n\n    // Add optional properties if they exist\n    if (notificationOptions.imageUrl) {\n      finalNotificationOptions.imageUrl = notificationOptions.imageUrl;\n    }\n\n    await chrome.notifications.create(notificationId, finalNotificationOptions);\n\n    if (notificationDataStore) {\n      notificationDataStore.set(notificationId, push);\n    }\n\n    performanceMonitor.recordNotificationCreated();\n    debugLogger.notifications(\"INFO\", \"Push notification created\", {\n      notificationId,\n      pushType: push.type,\n    });\n  } catch (error) {\n    performanceMonitor.recordNotificationFailed();\n    debugLogger.notifications(\n      \"ERROR\",\n      \"Failed to show push notification\",\n      { pushIden: push.iden },\n      error as Error,\n    );\n  }\n}\n\n/**\n * Check if we should enter polling mode\n */\nexport function checkPollingMode(): void {\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n\n  if (qualityMetrics.consecutiveFailures >= 3 && !isPollingMode()) {\n    debugLogger.general(\n      \"WARN\",\n      \"Entering polling mode due to consecutive failures\",\n      {\n        consecutiveFailures: qualityMetrics.consecutiveFailures,\n      },\n    );\n\n    setPollingMode(true);\n\n    // Start polling alarm\n    chrome.alarms.create(\"pollingFallback\", { periodInMinutes: 1 });\n\n    debugLogger.general(\"INFO\", \"Polling mode activated\", {\n      interval: \"1 minute\",\n    });\n  }\n}\n\n/**\n * Stop polling mode\n */\nexport function stopPollingMode(): void {\n  if (isPollingMode()) {\n    debugLogger.general(\"INFO\", \"Stopping polling mode - WebSocket reconnected\");\n    setPollingMode(false);\n    chrome.alarms.clear(\"pollingFallback\");\n  }\n}\n\n/**\n * Perform polling fetch\n */\nexport async function performPollingFetch(): Promise<void> {\n  await hydrateCutoff();\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general(\"WARN\", \"Cannot perform polling fetch - no API key\");\n    return;\n  }\n  debugLogger.general('DEBUG', 'Performing polling fetch (incremental)');\n  await refreshPushes(); // now incremental via refreshPushes\n}\n\n/**\n * Perform WebSocket health check\n */\nexport function performWebSocketHealthCheck(\n  websocketClient: any,\n  connectFn: () => void,\n): void {\n  const apiKey = getApiKey();\n\n  debugLogger.websocket(\n    \"DEBUG\",\n    \"[HealthCheck] Running WebSocket health check\",\n    {\n      hasClient:\n        !!websocketClient,\n      hasApiKey:\n        !!apiKey,\n      isConnected:\n        websocketClient?.isConnected() ??\n        false,\n      readyState:\n        websocketClient?.[\n          \"ws\"\n        ]\n          ?.readyState ??\n        \"N/A\",\n    },\n  );\n\n  // Case 1: No client or disconnected\n  if (\n    !websocketClient ||\n    !websocketClient.isConnected()\n  ) {\n    debugLogger.websocket(\n      \"WARN\",\n      \"[HealthCheck] WebSocket is null or disconnected\",\n      {\n        hasApiKey:\n          !!apiKey,\n        currentState:\n          stateMachine.getCurrentState(),\n      },\n    );\n\n    if (apiKey) {\n      // NEW: Check current state before reconnecting\n      const currentState =\n        stateMachine.getCurrentState();\n\n      // If we're in IDLE with an API key, we need to bootstrap recovery\n      if (\n        currentState ===\n        ServiceWorkerState.IDLE\n      ) {\n        debugLogger.websocket(\n          \"WARN\",\n          \"[HealthCheck] Detected IDLE state with API key - triggering recovery\",\n        );\n\n        // Use state machine transition instead of direct connect\n        stateMachine\n          .transition(\n            \"ATTEMPT_RECONNECT\",\n            {\n              hasApiKey: true,\n            },\n          )\n          .catch(\n            (\n              error,\n            ) => {\n              debugLogger.websocket(\n                \"ERROR\",\n                \"[HealthCheck] Failed to trigger recovery\",\n                null,\n                error as Error,\n              );\n              // Fallback to direct connection\n              connectFn();\n            },\n          );\n      } else if (\n        currentState ===\n          ServiceWorkerState.DEGRADED ||\n        currentState ===\n          ServiceWorkerState.RECONNECTING\n      ) {\n        // Normal reconnection for expected states\n        connectFn();\n      } else {\n        debugLogger.websocket(\n          \"DEBUG\",\n          \"[HealthCheck] Skipping reconnect - unexpected state\",\n          {\n            currentState,\n          },\n        );\n      }\n    } else {\n      debugLogger.websocket(\n        \"DEBUG\",\n        \"[HealthCheck] No API key - cannot reconnect\",\n      );\n    }\n    return;\n  }\n\n  // Case 2: Client exists and connected - check health\n  if (\n    !websocketClient.isConnectionHealthy()\n  ) {\n    debugLogger.websocket(\n      \"WARN\",\n      \"[HealthCheck] Connection unhealthy - emitting disconnect event\",\n    );\n    globalEventBus.emit(\n      \"websocket:disconnected\",\n    );\n  }\n}\n\n/**\n * Update popup connection state\n */\nexport function updatePopupConnectionState(state: string): void {\n  chrome.runtime\n    .sendMessage({\n      action: \"connectionStateChanged\",\n      state: state,\n    })\n    .catch(() => {\n      // Popup may not be open\n    });\n}\n\n/**\n * Setup context menu\n * Idempotent - safe to call from multiple event listeners\n */\nexport function setupContextMenu(): void {\n  // Guard against concurrent setup attempts\n  if (isSettingUpContextMenu) {\n    debugLogger.general(\n      \"INFO\",\n      \"Context menu setup already in progress, skipping\",\n    );\n    return;\n  }\n\n  isSettingUpContextMenu = true;\n\n  try {\n    chrome.contextMenus.removeAll(() => {\n      // Check for errors from removeAll\n      if (chrome.runtime.lastError) {\n        debugLogger.general(\n          \"ERROR\",\n          \"Failed to remove existing context menus\",\n          {\n            error: chrome.runtime.lastError.message,\n          },\n        );\n        isSettingUpContextMenu = false;\n        return;\n      }\n\n      // Now that menus are removed, create new ones\n      try {\n        chrome.contextMenus.create({\n          id: \"push-link\",\n          title: \"Push this link\",\n          contexts: [\"link\"],\n        });\n        if (chrome.runtime.lastError) {\n          const lastError = chrome.runtime.lastError as any;\n          const errorMessage = lastError.message || \"Unknown error\";\n          debugLogger.general(\"ERROR\", \"Failed to create push-link menu\", {\n            error: errorMessage,\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: \"push-page\",\n          title: \"Push this page\",\n          contexts: [\"page\"],\n        });\n        if (chrome.runtime.lastError) {\n          const lastError = chrome.runtime.lastError as any;\n          const errorMessage = lastError.message || \"Unknown error\";\n          debugLogger.general(\"ERROR\", \"Failed to create push-page menu\", {\n            error: errorMessage,\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: \"push-selection\",\n          title: \"Push selected text\",\n          contexts: [\"selection\"],\n        });\n        if (chrome.runtime.lastError) {\n          const lastError = chrome.runtime.lastError as any;\n          const errorMessage = lastError.message || \"Unknown error\";\n          debugLogger.general(\"ERROR\", \"Failed to create push-selection menu\", {\n            error: errorMessage,\n          });\n        }\n\n        chrome.contextMenus.create({\n          id: \"push-image\",\n          title: \"Push this image\",\n          contexts: [\"image\"],\n        });\n        if (chrome.runtime.lastError) {\n          const lastError = chrome.runtime.lastError as any;\n          const errorMessage = lastError.message || \"Unknown error\";\n          debugLogger.general(\"ERROR\", \"Failed to create push-image menu\", {\n            error: errorMessage,\n          });\n        }\n\n        debugLogger.general(\"INFO\", \"Context menu created successfully\");\n      } finally {\n        // Always clear the guard flag when done\n        isSettingUpContextMenu = false;\n      }\n    });\n  } catch (error) {\n    debugLogger.general(\n      \"ERROR\",\n      \"Failed to create context menu\",\n      null,\n      error as Error,\n    );\n    isSettingUpContextMenu = false;\n  }\n}\n\n/**\n * Push a link\n */\nexport async function pushLink(url: string, title?: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general(\"WARN\", \"Cannot push link - no API key\");\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedUrl = sanitizeUrl(url);\n  const sanitizedTitle = sanitizeText(title || \"Link\");\n\n  if (!sanitizedUrl) {\n    debugLogger.general(\"ERROR\", \"Invalid URL provided\", { url });\n    return;\n  }\n\n  try {\n    const response = await fetch(\"https://api.pushbullet.com/v2/pushes\", {\n      method: \"POST\",\n      headers: {\n        \"Access-Token\": apiKey,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        type: \"link\",\n        title: sanitizedTitle,\n        url: sanitizedUrl,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push link: ${response.status}`);\n    }\n\n    debugLogger.general(\"INFO\", \"Link pushed successfully\", { url, title });\n\n    createNotificationWithTimeout(\"pushbullet-link-sent\", {\n      type: \"basic\",\n      iconUrl: \"icons/icon128.png\",\n      title: \"Link Sent\",\n      message: title || url,\n    });\n  } catch (error) {\n    debugLogger.general(\n      \"ERROR\",\n      \"Failed to push link\",\n      { url, title },\n      error as Error,\n    );\n  }\n}\n\n/**\n * Push a note\n */\nexport async function pushNote(title: string, body: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general(\"WARN\", \"Cannot push note - no API key\");\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedTitle = sanitizeText(title);\n  const sanitizedBody = sanitizeText(body);\n\n  try {\n    const response = await fetch(\"https://api.pushbullet.com/v2/pushes\", {\n      method: \"POST\",\n      headers: {\n        \"Access-Token\": apiKey,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        type: \"note\",\n        title: sanitizedTitle,\n        body: sanitizedBody,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push note: ${response.status}`);\n    }\n\n    debugLogger.general(\"INFO\", \"Note pushed successfully\", { title });\n\n    createNotificationWithTimeout(\"pushbullet-note-sent\", {\n      type: \"basic\",\n      iconUrl: \"icons/icon128.png\",\n      title: \"Note Sent\",\n      message: title,\n    });\n  } catch (error) {\n    debugLogger.general(\n      \"ERROR\",\n      \"Failed to push note\",\n      { title },\n      error as Error,\n    );\n  }\n}\n", "/**\n * Service Worker State Machine\n * \n * This module implements a State Machine Pattern to centralize all service worker\n * lifecycle logic. Instead of scattered state flags (initializationState.inProgress,\n * isPollingMode, etc.), we have a single, explicit state machine.\n * \n * Benefits:\n * - Predictable behavior (single currentState variable)\n * - Explicit transitions (transition('WS_CONNECTED'))\n * - No invalid states (state machine ensures only valid transitions)\n * - Easy to debug (state transitions are logged)\n * - Easy to test (can test each state and transition independently)\n * \n * See ADR 0005 for full design documentation.\n */\n\nimport { debugLogger } from '../lib/logging';\nimport { updateExtensionTooltip, updateConnectionIcon } from './utils';\n\n/**\n * Service Worker States\n * \n * These represent all possible states the service worker can be in.\n */\nexport enum ServiceWorkerState {\n  IDLE = 'idle',                 // Fresh start, no API key\n  INITIALIZING = 'initializing', // API key present, fetching session data\n  READY = 'ready',               // Authenticated, WebSocket connected\n  DEGRADED = 'degraded',         // Authenticated, using polling fallback\n  RECONNECTING = 'reconnecting', // Attempting to restore real-time connection\n  ERROR = 'error',               // Permanent, unrecoverable error\n}\n\n/**\n * Service Worker Events\n * \n * These are the events that can trigger state transitions.\n */\nexport type ServiceWorkerEvent =\n  | 'STARTUP'            // onInstalled or onStartup\n  | 'API_KEY_SET'        // User saves a new API key\n  | 'INIT_SUCCESS'       // Session data successfully fetched\n  | 'INIT_FAILURE'       // Session data fetching failed\n  | 'WS_CONNECTED'       // WebSocket connected successfully\n  | 'WS_DISCONNECTED'    // WebSocket disconnected (transient error)\n  | 'WS_PERMANENT_ERROR' // WebSocket disconnected (permanent error)\n  | 'ATTEMPT_RECONNECT'  // Health check triggered reconnect attempt\n  | 'LOGOUT';            // User logged out\n\n/**\n * State Machine Callbacks\n * \n * These callbacks are called when entering/exiting states.\n * They allow the state machine to trigger side effects without\n * being tightly coupled to the background script.\n */\nexport interface StateMachineCallbacks {\n  onInitialize?: (data?: any) => Promise<void>;\n  onConnectWebSocket?: () => void;\n  onStartPolling?: () => void;\n  onStopPolling?: () => void;\n  onShowError?: (error: string) => void;\n  onClearData?: () => Promise<void>;\n  onDisconnectWebSocket?: () => void;\n}\n\n/**\n * Service Worker State Machine\n * \n * Manages the lifecycle of the service worker through explicit states and transitions.\n */\nexport class ServiceWorkerStateMachine {\n  private currentState: ServiceWorkerState = ServiceWorkerState.IDLE;\n  private callbacks: StateMachineCallbacks;\n\n  private constructor(callbacks: StateMachineCallbacks) {\n    this.callbacks = callbacks;\n    debugLogger.general('INFO', '[StateMachine] Initialized', { initialState: this.currentState });\n  }\n\n  /**\n   * Create a new state machine instance with hydrated state from storage\n   *\n   * This static factory method is the only way to create a ServiceWorkerStateMachine.\n   * It reads the last known state from chrome.storage.local and initializes the\n   * state machine with that state, ensuring continuity across service worker restarts.\n   *\n   * @param callbacks - The callbacks to use for state transitions\n   * @returns A promise that resolves to a fully initialized state machine\n   */\n  public static async create(callbacks: StateMachineCallbacks): Promise<ServiceWorkerStateMachine> {\n    const instance = new ServiceWorkerStateMachine(callbacks);\n\n    try {\n      const { lastKnownState } = await chrome.storage.local.get('lastKnownState');\n\n      // --- START MODIFICATION ---\n      // Clear terminal and transient states on extension reload\n      // These states imply active connections that no longer exist after reload\n      if (lastKnownState === ServiceWorkerState.ERROR) {\n        debugLogger.general(\n          \"WARN\",\n          \"[StateMachine] Hydrated to ERROR state. Reverting to IDLE to force re-initialization.\",\n        );\n        instance.currentState = ServiceWorkerState.IDLE;\n      } else if (\n        lastKnownState === ServiceWorkerState.RECONNECTING ||\n        lastKnownState === ServiceWorkerState.DEGRADED\n      ) {\n        // These states imply active connection attempts that are now stale after reload\n        debugLogger.general(\n          \"INFO\",\n          \"[StateMachine] Hydrated to transient state. Resetting to IDLE to re-establish connection.\",\n          {\n            staleState: lastKnownState,\n          },\n        );\n        instance.currentState = ServiceWorkerState.IDLE;\n      } else if (\n        lastKnownState &&\n        Object.values(ServiceWorkerState).includes(lastKnownState)\n      ) {\n        instance.currentState = lastKnownState as ServiceWorkerState;\n        debugLogger.general(\"INFO\", \"[StateMachine] Hydrated state from storage\", {\n          restoredState: instance.currentState,\n        });\n      }\n      // --- END MODIFICATION ---\n      else {\n        debugLogger.general('INFO', '[StateMachine] No valid state in storage, using default', {\n          initialState: instance.currentState\n        });\n      }\n    } catch (error) {\n      debugLogger.storage('ERROR', '[StateMachine] Failed to hydrate state, defaulting to IDLE', null, error as Error);\n      instance.currentState = ServiceWorkerState.IDLE;\n    }\n\n    // After hydrating its state, the state machine is now the source of truth.\n    // It is now its responsibility to set the initial UI to match its state.\n\n    // 1. Update the tooltip.\n    updateExtensionTooltip(instance.getStateDescription());\n\n    // 2. Update the icon badge color.\n    switch (instance.currentState) {\n    case ServiceWorkerState.READY:\n      updateConnectionIcon(\"connected\");\n      break;\n    case ServiceWorkerState.INITIALIZING:\n    case ServiceWorkerState.RECONNECTING:\n      updateConnectionIcon(\"connecting\");\n      break;\n    case ServiceWorkerState.DEGRADED:\n      updateConnectionIcon(\"degraded\");\n      break;\n    case ServiceWorkerState.ERROR:\n    case ServiceWorkerState.IDLE:\n      updateConnectionIcon(\"disconnected\"); // Red\n      break;\n    }\n\n    return instance;\n  }\n\n  /**\n   * Get the current state\n   */\n  public getCurrentState(): ServiceWorkerState {\n    return this.currentState;\n  }\n\n  /**\n   * Check if in a specific state\n   */\n  public isInState(state: ServiceWorkerState): boolean {\n    return this.currentState === state;\n  }\n\n  /**\n   * Transition to a new state based on an event\n   * \n   * @param event - The event that triggers the transition\n   * @param data - Optional data to pass to the state entry handler\n   */\n  public async transition(event: ServiceWorkerEvent, data?: any): Promise<void> {\n    const nextState = this.getNextState(event, data);\n\n    if (nextState !== this.currentState) {\n      debugLogger.general('INFO', `[StateMachine] Transition`, {\n        from: this.currentState,\n        event,\n        to: nextState\n      });\n\n      // Run exit actions for the old state\n      await this.onStateExit(this.currentState, nextState);\n\n      // Change state\n      const previousState = this.currentState;\n      this.currentState = nextState;\n\n      // Run entry actions for the new state\n      await this.onStateEnter(this.currentState, previousState, data);\n\n      // ICON PERSISTENCE FIX: Persist state to storage so icon badge survives service worker restarts\n      // This ensures users always see the correct extension state (error, connected, etc.)\n      // even after Chrome shuts down the service worker or the browser is restarted\n      try {\n        await chrome.storage.local.set({\n          lastKnownState: this.currentState,\n          lastKnownStateDescription: this.getStateDescription()\n        });\n        debugLogger.storage('DEBUG', '[StateMachine] Persisted new state to storage', { state: this.currentState });\n      } catch (error) {\n        debugLogger.storage('ERROR', '[StateMachine] Failed to persist state', null, error as Error);\n      }\n    } else {\n      debugLogger.general('DEBUG', `[StateMachine] No transition`, {\n        state: this.currentState,\n        event\n      });\n    }\n  }\n\n  /**\n   * Determine the next state based on current state and event\n   *\n   * This implements the state transition table from ADR 0005.\n   */\n  private getNextState(event: ServiceWorkerEvent, data?: any): ServiceWorkerState {\n    // LOGOUT can happen from any state\n    if (event === 'LOGOUT') {\n      return ServiceWorkerState.IDLE;\n    }\n\n    // STARTUP event handling: When service worker restarts, we need to re-initialize\n    // if we have an API key, regardless of the current state. This handles the case\n    // where the state machine was hydrated to READY/DEGRADED but the service worker\n    // has restarted and needs to restore the session.\n    if (event === 'STARTUP') {\n      if (data?.hasApiKey) {\n        // If we're already in INITIALIZING, stay there to avoid duplicate initialization\n        if (this.currentState === ServiceWorkerState.INITIALIZING) {\n          return ServiceWorkerState.INITIALIZING;\n        }\n        // From any other state, transition to INITIALIZING to restore session\n        return ServiceWorkerState.INITIALIZING;\n      } else {\n        // No API key, go to IDLE\n        return ServiceWorkerState.IDLE;\n      }\n    }\n\n    switch (this.currentState) {\n    case ServiceWorkerState.IDLE:\n      if (event === 'API_KEY_SET') {\n        return ServiceWorkerState.INITIALIZING;\n      }\n      // NEW: Allow recovery from idle when we have credentials\n      if (event === 'ATTEMPT_RECONNECT') {\n        // Check if we have an API key\n        const hasApiKey = data?.hasApiKey === true;\n        if (hasApiKey) {\n          debugLogger.general('INFO', '[StateMachine] Attempting recovery from IDLE with existing API key');\n          return ServiceWorkerState.INITIALIZING;\n        }\n      }\n      return ServiceWorkerState.IDLE;\n\n    case ServiceWorkerState.INITIALIZING:\n      if (event === 'INIT_SUCCESS') {\n        return ServiceWorkerState.READY;\n      }\n      if (event === 'INIT_FAILURE') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.READY:\n      if (event === 'WS_DISCONNECTED') {\n        return ServiceWorkerState.DEGRADED;\n      }\n      if (event === 'WS_PERMANENT_ERROR') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.DEGRADED:\n      if (event === 'WS_CONNECTED') {\n        return ServiceWorkerState.READY;\n      }\n      if (event === 'WS_PERMANENT_ERROR') {\n        return ServiceWorkerState.ERROR;\n      }\n      if (event === 'ATTEMPT_RECONNECT') {\n        return ServiceWorkerState.RECONNECTING;\n      }\n      break;\n\n    case ServiceWorkerState.RECONNECTING:\n      // Rule 1: If connection succeeds, go to READY (green).\n      if (event === 'WS_CONNECTED') {\n        return ServiceWorkerState.READY;\n      }\n      // Rule 2: If connection fails, go back to DEGRADED (cyan) to wait for the next attempt.\n      if (event === 'WS_DISCONNECTED') {\n        return ServiceWorkerState.DEGRADED;\n      }\n      // Rule 3: If it's a permanent error, go to ERROR (red).\n      if (event === 'WS_PERMANENT_ERROR') {\n        return ServiceWorkerState.ERROR;\n      }\n      break;\n\n    case ServiceWorkerState.ERROR: {\n      // ERROR state should allow recovery attempts\n      switch (event) {\n      case 'ATTEMPT_RECONNECT':\n        // User manually triggered reconnect (e.g., from popup)\n        return ServiceWorkerState.RECONNECTING;\n\n      case 'API_KEY_SET':\n        // User reconfigured API key - try initializing again\n        return ServiceWorkerState.INITIALIZING;\n\n      default:\n        // Stay in ERROR state for all other events\n        return ServiceWorkerState.ERROR;\n      }\n    }\n    }\n\n    // No valid transition found, stay in current state\n    return this.currentState;\n  }\n\n  /**\n   * Handle entering a new state\n   * \n   * This is where side effects happen (calling callbacks).\n   */\n  private async onStateEnter(\n    state: ServiceWorkerState,\n    previousState: ServiceWorkerState,\n    data?: any\n  ): Promise<void> {\n    // debugLogger.general('DEBUG', `[StateMachine] Entering state`, { state, previousState });\n    debugLogger.general('DEBUG', `[StateMachine] Entering state: ${state} (from ${previousState})`, { state, previousState });\n\n    // Update extension tooltip to show current state\n    updateExtensionTooltip(this.getStateDescription());\n\n    switch (state) {\n    case ServiceWorkerState.IDLE:\n      updateConnectionIcon(\"disconnected\");  // Red\n      // Clean slate - clear all data\n      if (this.callbacks.onClearData) {\n        await this.callbacks.onClearData();\n      }\n      if (this.callbacks.onDisconnectWebSocket) {\n        this.callbacks.onDisconnectWebSocket();\n      }\n      break;\n\n    case ServiceWorkerState.INITIALIZING:\n      // The INITIALIZING state is now responsible for the \"connecting\" UI.\n      updateConnectionIcon('connecting');\n      // Start initialization process\n      if (this.callbacks.onInitialize) {\n        try {\n          await this.callbacks.onInitialize(data);\n          // Initialization succeeded - transition to READY\n          await this.transition('INIT_SUCCESS');\n        } catch (error) {\n          // Initialization failed - transition to ERROR\n          debugLogger.general('ERROR', '[StateMachine] Initialization failed', null, error as Error);\n          await this.transition('INIT_FAILURE');\n        }\n      }\n      break;\n\n    case ServiceWorkerState.READY:\n      updateConnectionIcon(\"connected\");\n\n      // Clear any stored error context when successfully reaching READY state\n      try {\n        await chrome.storage.local.remove('lastError');\n        debugLogger.storage('DEBUG', 'Cleared lastError on successful recovery');\n      } catch (e) {\n        debugLogger.storage('WARN', 'Failed to clear lastError', null, e as Error);\n      }\n\n      // Stop polling if we were in DEGRADED mode\n      if (previousState === ServiceWorkerState.DEGRADED && this.callbacks.onStopPolling) {\n        this.callbacks.onStopPolling();\n      }\n      // Connect WebSocket if coming from INITIALIZING\n      if (previousState === ServiceWorkerState.INITIALIZING && this.callbacks.onConnectWebSocket) {\n        this.callbacks.onConnectWebSocket();\n      }\n      break;\n\n    case ServiceWorkerState.DEGRADED:\n      // When we ENTER the DEGRADED state, we start polling\n      debugLogger.general('WARN', 'Entering DEGRADED state. Starting polling fallback.');\n      // Directly update the icon to reflect the new state\n      updateConnectionIcon('degraded');\n      // Call the callback for consistency\n      if (this.callbacks.onStartPolling) {\n        this.callbacks.onStartPolling();\n      }\n      break;\n\n    case ServiceWorkerState.RECONNECTING:\n      // Update icon to yellow (connecting)\n      updateConnectionIcon('connecting');\n      // Now, actually start the connection attempt\n      if (this.callbacks.onConnectWebSocket) {\n        this.callbacks.onConnectWebSocket();\n      }\n      break;\n\n    case ServiceWorkerState.ERROR: {\n      // Update icon to red (disconnected)\n      updateConnectionIcon('disconnected');\n\n      // Store error context for debugging\n      try {\n        await chrome.storage.local.set({\n          lastError: {\n            timestamp: Date.now(),\n            message: data?.error || 'Unknown error',\n            previousState: previousState\n          }\n        });\n      } catch (e) {\n        debugLogger.storage('ERROR', 'Failed to store error context', null, e as Error);\n      }\n\n      // Show error notification\n      if (this.callbacks.onShowError) {\n        this.callbacks.onShowError('Service worker encountered an error');\n      }\n\n      // --- NEW: Automatic recovery attempt ---\n      // Schedule automatic reconnection attempt after 30 seconds\n      // This prevents the extension from being permanently stuck\n      const RECOVERY_DELAY_MS = 30000; // 30 seconds\n\n      chrome.alarms.create('auto-recovery-from-error', {\n        delayInMinutes: RECOVERY_DELAY_MS / 60000\n      });\n\n      debugLogger.general('INFO', '[StateMachine] Scheduled automatic recovery', {\n        delayMs: RECOVERY_DELAY_MS,\n        currentState: this.currentState\n      });\n\n      break;\n    }\n    }\n  }\n\n  /**\n   * Handle exiting a state\n   * \n   * Optional cleanup logic when leaving a state.\n   */\n  private async onStateExit(\n    state: ServiceWorkerState,\n    nextState: ServiceWorkerState\n  ): Promise<void> {\n    // debugLogger.general('DEBUG', `[StateMachine] Exiting state`, { state, nextState });\n    debugLogger.general('DEBUG', `[StateMachine] Exiting state: ${state} -> ${nextState}`, { state, nextState });\n\n\n    // When we EXIT the DEGRADED state, we must stop polling\n    if (state === ServiceWorkerState.DEGRADED) {\n      debugLogger.general('INFO', 'Exiting DEGRADED state. Stopping polling fallback.');\n      if (this.callbacks.onStopPolling) {\n        this.callbacks.onStopPolling();\n      }\n    }\n  }\n\n  /**\n   * Get a human-readable description of the current state\n   */\n  public getStateDescription(): string {\n    switch (this.currentState) {\n    case ServiceWorkerState.IDLE:\n      return 'Idle - No API key configured';\n    case ServiceWorkerState.INITIALIZING:\n      return 'Initializing - Fetching session data';\n    case ServiceWorkerState.READY:\n      return 'Ready - Connected via WebSocket';\n    case ServiceWorkerState.DEGRADED:\n      return 'Degraded - Using polling fallback';\n    case ServiceWorkerState.RECONNECTING:\n      return 'Reconnecting - Attempting to restore real-time connection';\n    case ServiceWorkerState.ERROR:\n      return 'Error - Unrecoverable error occurred';\n    default:\n      return 'Unknown state';\n    }\n  }\n}\n\n", "import { storageRepository } from '../infrastructure/storage/storage.repository';\r\nimport { getUserInfoWithTimeoutRetry, fetchDevices } from '../app/api/client';\r\nimport { sessionCache, hydrateCutoff } from '../app/session';\r\nimport { debugLogger } from '../lib/logging';\r\nimport { startCriticalKeepalive, stopCriticalKeepalive } from './keepalive';\r\nimport { setApiKey } from './state';\r\nimport { ensureDebugConfigLoadedOnce } from './index';\r\nimport type { User } from '../types/domain';\r\n\r\n// *** ADD THESE 3 IMPORTS ***\r\nimport {\r\n  loadSessionCache,\r\n  saveSessionCache,\r\n} from \"../infrastructure/storage/indexed-db\";\r\nimport {\r\n  isCacheFresh,\r\n  refreshSessionInBackground,\r\n  getInitPromise,\r\n  setInitPromise,\r\n  clearInitPromise,\r\n} from \"../app/session\";\r\n\r\n\r\n\r\nexport async function orchestrateInitialization(\r\n  trigger: string,\r\n  connectWs: () => void,\r\n): Promise<void> {\r\n  // *** SINGLETON CHECK: Prevent duplicate initialization ***\r\n  const existingInit = getInitPromise();\r\n  if (existingInit) {\r\n    debugLogger.general('INFO',\r\n      'Initialization already in progress, awaiting existing promise',\r\n      { trigger, source: 'orchestrateInitialization' },\r\n    );\r\n\r\n    try {\r\n      await existingInit;\r\n      debugLogger.general('INFO',\r\n        'Existing initialization completed successfully',\r\n        { trigger },\r\n      );\r\n      return; // Exit early - work is done\r\n    } catch (error) {\r\n      debugLogger.general('WARN',\r\n        'Existing initialization failed, will create new attempt',\r\n        { trigger, error: (error as Error).message },\r\n      );\r\n      // Fall through to create new initialization\r\n    }\r\n  }\r\n\r\n  // *** CREATE WRAPPED INITIALIZATION PROMISE ***\r\n  const initializationPromise = (async (): Promise<string | null> => {\r\n    // START keepalive BEFORE any async work\r\n    startCriticalKeepalive();\r\n\r\n    try {\r\n      await ensureDebugConfigLoadedOnce();\r\n      const apiKey = await storageRepository.getApiKey();\r\n\r\n      if (!apiKey) {\r\n        debugLogger.general('WARN',\r\n          'No API key available, skipping initialization',\r\n        );\r\n        return null;\r\n      }\r\n\r\n      // CRITICAL: hydrate in-memory state before anything uses getApiKey()\r\n      setApiKey(apiKey);\r\n      await hydrateCutoff();\r\n\r\n      debugLogger.general('INFO', 'Starting orchestrated initialization', {\r\n        trigger,\r\n      });\r\n\r\n      // *** STEP 1: Try to load session from IndexedDB ***\r\n      const cachedSession = await loadSessionCache();\r\n      const DOWNTIME_THRESHOLD = 3600000; // 1 hour\r\n      const isLongDowntime = cachedSession && (Date.now() - cachedSession.cachedAt > DOWNTIME_THRESHOLD);\r\n      if (isLongDowntime) {\r\n        debugLogger.general('WARN', 'Long downtime (>1h) detected, forcing full network reinit');\r\n      }\r\n\r\n      if (cachedSession && !isLongDowntime && isCacheFresh(cachedSession)) {\r\n        // Cache is fresh! Use it immediately\r\n        debugLogger.general('INFO', 'Hydrating session from IndexedDB cache', {\r\n          cacheAge: `${Math.round((Date.now() - cachedSession.cachedAt) / 1000)}s`,\r\n          deviceCount: cachedSession.devices.length,\r\n          pushCount: cachedSession.recentPushes.length,\r\n        });\r\n\r\n        // Copy all cached fields into sessionCache\r\n        Object.assign(sessionCache, cachedSession);\r\n\r\n        // Connect WebSocket immediately (non-blocking)\r\n        connectWs();\r\n\r\n        // Start background refresh (non-blocking)\r\n        void refreshSessionInBackground(apiKey);\r\n\r\n        debugLogger.general('INFO',\r\n          'Initialization completed using cache (background refresh queued)',\r\n          { trigger },\r\n        );\r\n\r\n        return apiKey; // Success with cached data\r\n      }\r\n\r\n      // *** Cache is stale or missing - proceed with full network initialization ***\r\n      debugLogger.general('INFO',\r\n        'Cache stale or missing, performing full network init',\r\n        {\r\n          hasCachedSession: !!cachedSession,\r\n          cacheAge: cachedSession?.cachedAt\r\n            ? `${Math.round((Date.now() - cachedSession.cachedAt) / 1000)}s`\r\n            : 'N/A',\r\n        },\r\n      );\r\n\r\n      // *** STEP 2: Prime UI with old cached user info if available ***\r\n      const cachedUser = await storageRepository.getUserInfoCache();\r\n      if (cachedUser) {\r\n        sessionCache.userInfo = cachedUser;\r\n        debugLogger.general('INFO', 'Loaded stale user info from legacy cache');\r\n      }\r\n\r\n      // *** STEP 3: Fire critical network calls in parallel ***\r\n      const userP = getUserInfoWithTimeoutRetry(apiKey)\r\n        .then(async (u: User) => {\r\n          sessionCache.userInfo = u;\r\n          await storageRepository.setUserInfoCache(u);\r\n          debugLogger.general('INFO', 'User info fetched and cached');\r\n        })\r\n        .catch((e: unknown) => {\r\n          debugLogger.api('WARN',\r\n            'users/me timed out or failed; using cache if present',\r\n            { error: String(e) },\r\n          );\r\n        });\r\n\r\n      const devicesP = fetchDevices(apiKey).then((d) => {\r\n        sessionCache.devices = d;\r\n        debugLogger.general('INFO', 'Devices fetched', { count: d.length });\r\n      });\r\n\r\n      // *** STEP 4: Start WebSocket immediately ***\r\n      const wsP = Promise.resolve().then(() => connectWs());\r\n\r\n      // *** STEP 5: Await devices + ws for functional readiness ***\r\n      const results = await Promise.allSettled([devicesP, wsP]);\r\n\r\n      debugLogger.general('INFO', 'Functional ready: devices + ws initialized', {\r\n        trigger: trigger,\r\n        results: results.map((r, i) => ({ index: i, status: r.status })),\r\n      });\r\n\r\n      // *** STEP 6: Save session to IndexedDB for next wake-up ***\r\n      try {\r\n        // Ensure session cache is marked as authenticated\r\n        sessionCache.isAuthenticated = true;\r\n        sessionCache.lastUpdated = Date.now();\r\n\r\n        await saveSessionCache(sessionCache);\r\n\r\n        // *** UPDATE IN-MEMORY TIMESTAMP ***\r\n        sessionCache.cachedAt = Date.now();\r\n\r\n        debugLogger.general('INFO',\r\n          'Session cache saved to IndexedDB after network init',\r\n          {\r\n            deviceCount: sessionCache.devices.length,\r\n            pushCount: sessionCache.recentPushes.length,\r\n            chatCount: sessionCache.chats.length,\r\n            cachedAt: sessionCache.cachedAt, // \u2190 Shows correct value\r\n          },\r\n        );\r\n      } catch (error) {\r\n        // Non-fatal: Cache save failure shouldn't block initialization\r\n        debugLogger.general('WARN',\r\n          'Failed to save session cache to IndexedDB',\r\n          null,\r\n          error as Error,\r\n        );\r\n      }\r\n\r\n      debugLogger.general('INFO', 'Background service worker initialized', {\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      // *** STEP 7: User info can resolve later (non-blocking) ***\r\n      await userP.catch(() => {\r\n        /* Ignore errors here as we already logged */\r\n      });\r\n\r\n      return apiKey; // Success with network data\r\n    } catch (error) {\r\n      debugLogger.general('ERROR', 'Orchestrated initialization failed', {\r\n        trigger,\r\n        error: (error as Error).message,\r\n      });\r\n      throw error; // Re-throw to mark promise as rejected\r\n    } finally {\r\n      // ALWAYS stop keepalive, even if initialization fails\r\n      stopCriticalKeepalive();\r\n    }\r\n  })();\r\n\r\n  // *** REGISTER THIS PROMISE AS THE GLOBAL SINGLETON ***\r\n  setInitPromise(initializationPromise);\r\n\r\n  // *** AWAIT THE PROMISE AND CLEANUP ***\r\n  try {\r\n    await initializationPromise;\r\n\r\n    debugLogger.general('INFO',\r\n      'orchestrateInitialization completed successfully',\r\n      {\r\n        trigger,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n    );\r\n  } catch (error) {\r\n    debugLogger.general('ERROR',\r\n      'orchestrateInitialization failed',\r\n      { trigger },\r\n      error as Error,\r\n    );\r\n    throw error; // Re-throw for caller\r\n  } finally {\r\n    // *** ALWAYS CLEAR THE SINGLETON PROMISE ***\r\n    clearInitPromise();\r\n  }\r\n}", "type Task = () => Promise<void>;\nconst queue: Task[] = [];\n\nexport function enqueuePostConnect(task: Task): void { queue.push(task); }\nexport async function runPostConnect(): Promise<void> {\n  while (queue.length) {\n    const t = queue.shift()!;\n    try { await t(); } catch { /* swallow and continue */ }\n  }\n}", "/**\n * Message sender validation for security\n * Prevents external extensions/pages from sending privileged messages\n */\n\nimport { debugLogger } from '../logging';\n\n/**\n * Validate that message sender is from this extension\n */\nexport function isValidSender(sender: chrome.runtime.MessageSender): boolean {\n  // Must have a valid sender object\n  if (!sender) {\n    debugLogger.general('WARN', 'Message received with no sender');\n    return false;\n  }\n\n  // Must be from this extension\n  if (sender.id !== chrome.runtime.id) {\n    debugLogger.general('WARN', 'Message received from external extension', {\n      senderId: sender.id,\n      expectedId: chrome.runtime.id\n    });\n    return false;\n  }\n\n  // Must be from an extension page (not a content script)\n  if (sender.url) {\n    const extensionUrl = chrome.runtime.getURL('');\n    if (!sender.url.startsWith(extensionUrl)) {\n      debugLogger.general('WARN', 'Message received from non-extension URL', {\n        senderUrl: sender.url,\n        expectedPrefix: extensionUrl\n      });\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * List of privileged actions that require sender validation\n */\nconst PRIVILEGED_ACTIONS = new Set([\n  'apiKeyChanged',\n  'logout',\n  'settingsChanged',\n  'deviceNicknameChanged',\n  'autoOpenLinksChanged',\n  'encryptionPasswordChanged',\n  'debugModeChanged',\n  'pushNote',\n  'pushLink',\n  'pushFile'\n]);\n\n/**\n * Check if an action requires privileged access\n */\nexport function isPrivilegedAction(action: string): boolean {\n  return PRIVILEGED_ACTIONS.has(action);\n}\n\n/**\n * Validate sender for privileged actions\n * Returns true if valid, false if should be rejected\n */\nexport function validatePrivilegedMessage(\n  action: string,\n  sender: chrome.runtime.MessageSender\n): boolean {\n  if (!isPrivilegedAction(action)) {\n    // Non-privileged actions don't need validation\n    return true;\n  }\n\n  if (!isValidSender(sender)) {\n    debugLogger.general('ERROR', 'Rejected privileged action from invalid sender', {\n      action,\n      senderId: sender?.id,\n      senderUrl: sender?.url\n    });\n    return false;\n  }\n\n  return true;\n}\n\n", "/**\r\n * Background Service Worker - Main Entry Point\r\n * Pushbullet Chrome Extension (Manifest V3)\r\n */\r\n\r\nimport {\r\n  debugLogger,\r\n  debugConfigManager,\r\n  globalErrorTracker,\r\n} from \"../lib/logging\";\r\nimport { performanceMonitor } from \"../lib/perf\";\r\nimport { initTracker, wsStateMonitor } from \"../lib/monitoring\";\r\nimport { WebSocketClient } from \"../app/ws/client\";\r\nimport {\r\n  sessionCache,\r\n  initializeSessionCache,\r\n  refreshSessionCache,\r\n  resetSessionCache,\r\n  handleInvalidCursorRecovery,\r\n  getInitPromise,\r\n} from \"../app/session\";\r\nimport {\r\n  fetchDevices,\r\n  updateDeviceNickname,\r\n  fetchRecentPushes,\r\n} from \"../app/api/client\";\r\nimport { installDiagnosticsMessageHandler } from \"./diagnostics\";\r\nimport { ensureConfigLoaded } from \"../app/reconnect\";\r\nimport { checkPushTypeSupport, SUPPORTED_PUSH_TYPES } from \"../app/push-types\";\r\nimport { PushbulletCrypto } from \"../lib/crypto\";\r\nimport { storageRepository } from \"../infrastructure/storage/storage.repository\";\r\nimport { MessageAction } from \"../types/domain\";\r\nimport { globalEventBus } from \"../lib/events/event-bus\";\r\nimport { ServiceWorkerStateMachine, ServiceWorkerState } from \"./state-machine\";\r\nimport {\r\n  getApiKey,\r\n  setApiKey,\r\n  getDeviceIden,\r\n  setDeviceIden,\r\n  getDeviceNickname,\r\n  setDeviceNickname,\r\n  getAutoOpenLinks,\r\n  setAutoOpenLinks,\r\n  getNotificationTimeout,\r\n  setNotificationTimeout,\r\n  setWebSocketClient,\r\n  WEBSOCKET_URL,\r\n} from \"./state\";\r\nimport {\r\n  refreshPushes,\r\n  showPushNotification,\r\n  checkPollingMode,\r\n  stopPollingMode,\r\n  performPollingFetch,\r\n  performWebSocketHealthCheck,\r\n  updatePopupConnectionState,\r\n  pushLink,\r\n  pushNote,\r\n} from \"./utils\";\r\nimport { autoOpenOfflineLinks } from \"./links\";\r\nimport { orchestrateInitialization } from \"./startup\";\r\nimport { maybeAutoOpenLinkWithDismiss } from \"./processing\";\r\nimport { runPostConnect } from \"../realtime/postConnectQueue\";\r\nimport { validatePrivilegedMessage } from \"../lib/security/message-validation\";\r\nimport { handleKeepaliveAlarm } from \"./keepalive\";\r\nimport type { Push } from \"../types/domain\";\r\nimport { isLinkPush } from \"../types/domain\";\r\nimport {\r\n  saveSessionCache,\r\n  clearSessionCache,\r\n} from \"../infrastructure/storage/indexed-db\";\r\n\r\n// Load debug configuration (single-flight)\r\nlet loadDebugConfigOnce: Promise<void> | null = null;\r\n\r\nexport function ensureDebugConfigLoadedOnce(): Promise<void> {\r\n  if (!loadDebugConfigOnce) {\r\n    loadDebugConfigOnce = (async () => {\r\n      try {\r\n        await debugConfigManager.loadConfig();\r\n        debugLogger.general(\r\n          \"INFO\",\r\n          \"Debug configuration loaded (single-flight)\",\r\n        );\r\n      } catch (e) {\r\n        debugLogger.general(\r\n          \"WARN\",\r\n          \"Failed to load debug configuration (single-flight)\",\r\n          { error: (e as Error).message },\r\n        );\r\n      }\r\n    })();\r\n  }\r\n  return loadDebugConfigOnce;\r\n}\r\n\r\n// Store notification data for detail view\r\n// SECURITY FIX (M-06): Limit store size to prevent memory leak\r\nconst notificationDataStore = new Map<string, Push>();\r\nconst MAX_NOTIFICATION_STORE_SIZE = 100;\r\n\r\n/**\r\n * Add notification to store with size limit\r\n */\r\nexport function addToNotificationStore(id: string, push: Push): void {\r\n  // Remove oldest entries if at capacity\r\n  if (notificationDataStore.size >= MAX_NOTIFICATION_STORE_SIZE) {\r\n    const firstKey = notificationDataStore.keys().next().value;\r\n    if (firstKey) {\r\n      notificationDataStore.delete(firstKey);\r\n    }\r\n  }\r\n  notificationDataStore.set(id, push);\r\n}\r\n\r\n/**\r\n * Get notification store (for passing to utils)\r\n */\r\nexport function getNotificationStore(): Map<string, Push> {\r\n  return notificationDataStore;\r\n}\r\n\r\n/**\r\n * Attempts to get the API key from storage with retries.\r\n *\r\n * RACE CONDITION FIX: The chrome.storage API can be transiently unavailable\r\n * immediately after a service worker restart, returning empty results even when\r\n * data exists. This function implements a retry mechanism to handle this MV3\r\n * lifecycle issue.\r\n *\r\n * @param attempts - Number of retry attempts (default: 3)\r\n * @param delay - Delay in milliseconds between attempts (default: 100)\r\n * @returns The API key string, or null if not found after all retries\r\n */\r\n\r\n// Initialize WebSocket client\r\nlet websocketClient: WebSocketClient | null = null;\r\n\r\n// READY promotion safety-net guard\r\nlet ranReconnectAutoOpen = false; // guard per reconnect [file:9]\r\n\r\nasync function promoteToReadyIfConnected() {\r\n  if (!websocketClient?.isConnectionHealthy?.()) return;\r\n  await stateMachineReady;\r\n  const inRecovery =\r\n    stateMachine.isInState(ServiceWorkerState.RECONNECTING) ||\r\n    stateMachine.isInState(ServiceWorkerState.DEGRADED);\r\n  if (inRecovery) {\r\n    stateMachine.transition(\"WS_CONNECTED\");\r\n    void runPostConnect();\r\n    void maybeRunReconnectAutoOpen();\r\n  }\r\n}\r\n\r\nasync function maybeRunReconnectAutoOpen() {\r\n  if (ranReconnectAutoOpen) return; // idempotent per reconnect [file:9]\r\n  ranReconnectAutoOpen = true; // set guard [file:9]\r\n  const apiKey = getApiKey(); // must exist now [file:9]\r\n  if (!apiKey) return; // safety [file:9]\r\n  const storedCutoff = (await storageRepository.getLastModifiedCutoff()) ?? 0; // fetch persisted cutoff [file:9]\r\n  const sessionCutoff = sessionCache.lastModifiedCutoff ?? storedCutoff; // choose best cutoff [file:9]\r\n  try {\r\n    await autoOpenOfflineLinks(apiKey, sessionCutoff); // open missed link pushes up to cap [file:9]\r\n  } catch (e) {\r\n    debugLogger.general(\"ERROR\", \"Auto-open on reconnect failed\", {\r\n      error: String(e),\r\n    }); // log errors [file:9]\r\n  }\r\n}\r\n\r\n// Register WebSocket event listeners ONCE at module load\r\n// These should NOT be removed/re-registered on each connect\r\nglobalEventBus.on(\"websocket:tickle:push\", async () => {\r\n  try {\r\n    await refreshPushes(notificationDataStore);\r\n  } finally {\r\n    await promoteToReadyIfConnected();\r\n  }\r\n});\r\n\r\nglobalEventBus.on(\"websocket:tickle:device\", async () => {\r\n  const apiKey = getApiKey();\r\n  if (apiKey) {\r\n    const devices = await fetchDevices(apiKey);\r\n    sessionCache.devices = devices;\r\n    sessionCache.lastUpdated = Date.now();\r\n\r\n    chrome.runtime\r\n      .sendMessage({\r\n        action: MessageAction.SESSION_DATA_UPDATED,\r\n        devices: devices,\r\n        userInfo: sessionCache.userInfo,\r\n        recentPushes: sessionCache.recentPushes,\r\n        autoOpenLinks: sessionCache.autoOpenLinks,\r\n        deviceNickname: sessionCache.deviceNickname,\r\n      })\r\n      .catch(() => {});\r\n  }\r\n});\r\n\r\nglobalEventBus.on(\"websocket:push\", async (push: Push | any) => {\r\n  // RACE CONDITION FIX: Ensure configuration is loaded before processing push\r\n  await ensureConfigLoaded();\r\n\r\n  // Track push received\r\n  performanceMonitor.recordPushReceived();\r\n\r\n  let decryptedPush: Push = push;\r\n  let decryptionFailed = false;\r\n\r\n  // Check if push is encrypted\r\n  if (\"encrypted\" in push && push.encrypted && \"ciphertext\" in push) {\r\n    try {\r\n      // Get encryption password from storage repository\r\n      const password = await storageRepository.getEncryptionPassword();\r\n\r\n      if (password && sessionCache.userInfo) {\r\n        debugLogger.general(\"INFO\", \"Decrypting encrypted push\", {\r\n          pushIden: push.iden,\r\n        });\r\n\r\n        const decrypted = await PushbulletCrypto.decryptPush(\r\n          push as any,\r\n          password,\r\n          sessionCache.userInfo.iden,\r\n        );\r\n\r\n        decryptedPush = decrypted as Push;\r\n\r\n        debugLogger.general(\"INFO\", \"Push decrypted successfully\", {\r\n          pushType: decryptedPush.type,\r\n        });\r\n\r\n        // ADD THIS - Full dump of decrypted data (for debugging)\r\n        debugLogger.general(\"DEBUG\", \"FULL DECRYPTED PUSH DATA\", {\r\n          completeData: decryptedPush,\r\n        });\r\n      } else {\r\n        debugLogger.general(\r\n          \"WARN\",\r\n          \"Cannot decrypt push - no encryption password set\",\r\n        );\r\n        decryptionFailed = true;\r\n      }\r\n    } catch (error) {\r\n      debugLogger.general(\r\n        \"ERROR\",\r\n        \"Failed to decrypt push\",\r\n        { error: (error as Error).message },\r\n        error as Error,\r\n      );\r\n      decryptionFailed = true;\r\n    }\r\n  }\r\n\r\n  // \u2705 FIX: Skip type checking if decryption failed\r\n  // For encrypted pushes, we can't check type until after decryption\r\n  if (decryptionFailed) {\r\n    debugLogger.general(\r\n      \"WARN\",\r\n      \"Skipping encrypted push due to decryption failure\",\r\n      {\r\n        pushIden: push.iden,\r\n        hasEncryptionPassword:\r\n          !!(await storageRepository.getEncryptionPassword()),\r\n      },\r\n    );\r\n    return; // Exit early - can't process without decrypting\r\n  }\r\n\r\n  // \u2705 FIX: Verify type field exists after decryption\r\n  if (!decryptedPush.type) {\r\n    debugLogger.general(\"ERROR\", \"Push has no type field after decryption\", {\r\n      pushIden: (decryptedPush as any).iden,\r\n      pushData: decryptedPush,\r\n    });\r\n    return;\r\n  }\r\n\r\n  // --- FILTERING LOGIC: Only process supported push types ---\r\n  const typeCheck = checkPushTypeSupport(decryptedPush.type);\r\n\r\n  if (!typeCheck.supported) {\r\n    // Log unsupported push types as WARNING for visibility\r\n    if (typeCheck.category === \"known-unsupported\") {\r\n      debugLogger.general(\"WARN\", \"Received known unsupported push type\", {\r\n        pushType: decryptedPush.type,\r\n        pushIden: decryptedPush.iden,\r\n        category: typeCheck.category,\r\n        reason: \"This push type is not supported by the extension\",\r\n        supportedTypes: SUPPORTED_PUSH_TYPES,\r\n      });\r\n    } else if (typeCheck.category === \"unknown\") {\r\n      debugLogger.general(\"WARN\", \"Received unknown push type\", {\r\n        pushType: decryptedPush.type,\r\n        pushIden: decryptedPush.iden,\r\n        category: typeCheck.category,\r\n        reason: \"This is a new or unrecognized push type\",\r\n        supportedTypes: SUPPORTED_PUSH_TYPES,\r\n        // Include full push data for investigation\r\n        fullPushData: decryptedPush,\r\n      });\r\n    }\r\n\r\n    // Exit early - don't process unsupported pushes\r\n    return;\r\n  }\r\n\r\n  // If we reach here, the push is supported and should be processed\r\n  debugLogger.general(\"INFO\", \"Processing supported push type\", {\r\n    pushType: decryptedPush.type,\r\n    pushIden: decryptedPush.iden,\r\n  });\r\n\r\n  // ADD THIS - Dump for Mirror Messages\r\n  if (decryptedPush.type === \"mirror\") {\r\n    // Log full mirror message data to see all available fields\r\n    debugLogger.general(\"DEBUG\", \"FULL MIRROR MESSAGE DATA\", {\r\n      completeMirrorData: decryptedPush,\r\n    });\r\n  }\r\n\r\n  // Update cache (prepend)\r\n  if (sessionCache.recentPushes) {\r\n    sessionCache.recentPushes.unshift(decryptedPush);\r\n    // Save the updated cache (with the new push) to our database.\r\n    saveSessionCache(sessionCache);\r\n    sessionCache.lastUpdated = Date.now();\r\n\r\n    chrome.runtime\r\n      .sendMessage({\r\n        action: MessageAction.PUSHES_UPDATED,\r\n        pushes: sessionCache.recentPushes,\r\n      })\r\n      .catch(() => {});\r\n  }\r\n\r\n  // FIX: Don't await - let notifications show immediately without blocking\r\n  // This allows multiple notifications to appear concurrently\r\n  showPushNotification(decryptedPush, notificationDataStore).catch((error) => {\r\n    debugLogger.general(\"ERROR\", \"Failed to show notification\", null, error);\r\n    performanceMonitor.recordNotificationFailed();\r\n  });\r\n\r\n  // Auto-open links if setting is enabled\r\n  const autoOpenLinks = getAutoOpenLinks();\r\n  if (autoOpenLinks && isLinkPush(decryptedPush)) {\r\n    await maybeAutoOpenLinkWithDismiss({\r\n      iden: decryptedPush.iden,\r\n      type: decryptedPush.type,\r\n      url: decryptedPush.url,\r\n      created: decryptedPush.created,\r\n    });\r\n  }\r\n\r\n  await promoteToReadyIfConnected();\r\n});\r\n\r\n// If you already emit a generic event for all WS messages, use it:\r\nglobalEventBus.on(\"websocket:message\", async () => {\r\n  await promoteToReadyIfConnected(); // READY promotion safety-net [file:9]\r\n});\r\n\r\nglobalEventBus.on(\"websocket:connected\", async () => {\r\n  debugLogger.websocket(\r\n    \"INFO\",\r\n    \"WebSocket connected - post-connect tasks starting\",\r\n  );\r\n  await stateMachineReady;\r\n  stateMachine.transition(\"WS_CONNECTED\");\r\n  void runPostConnect();\r\n  void maybeRunReconnectAutoOpen();\r\n});\r\n\r\nglobalEventBus.on(\"websocket:disconnected\", async () => {\r\n  await stateMachineReady;\r\n  stateMachine.transition(\"WS_DISCONNECTED\");\r\n});\r\n\r\nglobalEventBus.on(\"websocket:polling:check\", () => {\r\n  checkPollingMode();\r\n});\r\n\r\nglobalEventBus.on(\"websocket:polling:stop\", () => {\r\n  stopPollingMode();\r\n});\r\n\r\nglobalEventBus.on(\"websocket:state\", (state: string) => {\r\n  updatePopupConnectionState(state);\r\n});\r\n\r\nglobalEventBus.on(\"state:enter:reconnecting\", () => {\r\n  ranReconnectAutoOpen = false;\r\n});\r\n\r\n// Initialize State Machine\r\n// ARCHITECTURAL CHANGE: Centralized lifecycle management\r\n// All service worker state is now managed by the state machine\r\n// STATE MACHINE HYDRATION: The state machine is created asynchronously to allow\r\n// it to hydrate its state from storage, ensuring continuity across service worker restarts\r\nlet stateMachine: ServiceWorkerStateMachine;\r\n\r\n// Define the callbacks once for reuse\r\nconst stateMachineCallbacks = {\r\n  onInitialize: async (data: any) => {\r\n    // Initialize session cache\r\n    const apiKey = data?.apiKey || getApiKey();\r\n    if (apiKey) {\r\n      // Pass connectWebSocket so it can be called upon successful initialization\r\n      await initializeSessionCache(\"state-machine\", connectWebSocket, {\r\n        setApiKey,\r\n        setDeviceIden,\r\n        setAutoOpenLinks,\r\n        setNotificationTimeout,\r\n        setDeviceNickname,\r\n      });\r\n    }\r\n  },\r\n\r\n  onStartPolling: () => {\r\n    checkPollingMode();\r\n  },\r\n  onStopPolling: () => {\r\n    stopPollingMode();\r\n  },\r\n  onShowError: (error: string) => {\r\n    debugLogger.general(\"ERROR\", \"[StateMachine] Error state\", { error });\r\n  },\r\n  onClearData: async () => {\r\n    // Clear session cache to initial state\r\n    resetSessionCache();\r\n  },\r\n  onDisconnectWebSocket: () => {\r\n    disconnectWebSocket();\r\n  },\r\n};\r\n\r\n// Create a promise that resolves when the state machine is ready\r\n// This ensures startup listeners wait for hydration to complete before attempting transitions\r\nconst stateMachineReady = ServiceWorkerStateMachine.create(\r\n  stateMachineCallbacks,\r\n).then((sm) => {\r\n  stateMachine = sm;\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"[Background] State machine initialized and ready\",\r\n    {\r\n      currentState: stateMachine.getCurrentState(),\r\n    },\r\n  );\r\n});\r\n\r\n// Install diagnostics message handler\r\ninstallDiagnosticsMessageHandler();\r\n\r\n/**\r\n * Connect to WebSocket\r\n */\r\nfunction connectWebSocket(): void {\r\n  // Guard: Don't reconnect if already connected or connecting\r\n  if (websocketClient) {\r\n    const isConnected = websocketClient.isConnected();\r\n    const isConnecting =\r\n      websocketClient.getReadyState() === WebSocket.CONNECTING;\r\n\r\n    if (isConnected || isConnecting) {\r\n      debugLogger.websocket(\r\n        \"DEBUG\",\r\n        \"WebSocket already connected/connecting, skipping duplicate call\",\r\n        {\r\n          isConnected,\r\n          isConnecting,\r\n          readyState: websocketClient.getReadyState(),\r\n        },\r\n      );\r\n      return; // EXIT EARLY - do not proceed\r\n    }\r\n  }\r\n\r\n  // SECURITY FIX (H-02): Dispose existing socket before creating new one\r\n  if (websocketClient) {\r\n    debugLogger.websocket(\r\n      \"INFO\",\r\n      \"Disposing existing WebSocket before reconnecting\",\r\n    );\r\n    websocketClient.disconnect();\r\n    websocketClient = null;\r\n  }\r\n\r\n  websocketClient = new WebSocketClient(WEBSOCKET_URL, getApiKey);\r\n  setWebSocketClient(websocketClient);\r\n\r\n  websocketClient.connect();\r\n}\r\n\r\n/**\r\n * Disconnect WebSocket\r\n */\r\nfunction disconnectWebSocket(): void {\r\n  if (websocketClient) {\r\n    websocketClient.disconnect();\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Chrome Event Listeners\r\n// ============================================================================\r\n\r\n/**\r\n * Alarm listener\r\n */\r\nchrome.alarms.onAlarm.addListener(async (alarm) => {\r\n  // Handle critical keepalive FIRST\r\n  if (handleKeepaliveAlarm(alarm)) {\r\n    return; // Handled by keepalive utility\r\n  }\r\n\r\n  if (alarm.name === \"keepalive\") {\r\n    // Minimal work to prevent termination\r\n    debugLogger.general(\"DEBUG\", \"Keepalive heartbeat\"); // existing [file:9]\r\n    if (websocketClient?.isConnectionHealthy?.()) {\r\n      await stateMachineReady;\r\n      const notReady = !stateMachine.isInState(ServiceWorkerState.READY);\r\n      if (notReady) {\r\n        stateMachine.transition(\"WS_CONNECTED\");\r\n        void runPostConnect();\r\n        void maybeRunReconnectAutoOpen();\r\n      }\r\n    }\r\n\r\n    // Verify critical state integrity\r\n    const apiKey = getApiKey();\r\n    if (!apiKey) {\r\n      debugLogger.general(\"WARN\", \"Keepalive: API key missing, reloading\");\r\n      await ensureConfigLoaded(\r\n        {\r\n          setApiKey,\r\n          setDeviceIden,\r\n          setAutoOpenLinks,\r\n          setDeviceNickname,\r\n          setNotificationTimeout,\r\n        },\r\n        {\r\n          getApiKey,\r\n          getDeviceIden,\r\n          getAutoOpenLinks,\r\n          getDeviceNickname,\r\n          getNotificationTimeout,\r\n        },\r\n      );\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (alarm.name === \"logFlush\") {\r\n    await debugLogger.flush();\r\n    return;\r\n  }\r\n\r\n  // NEW: Handle auto-recovery from ERROR state\r\n  if (alarm.name === \"auto-recovery-from-error\") {\r\n    debugLogger.general(\r\n      \"INFO\",\r\n      \"[Alarm] Auto-recovery timer fired, attempting to reconnect\",\r\n    );\r\n\r\n    const apiKey = getApiKey();\r\n    if (apiKey) {\r\n      await stateMachine.transition(\"ATTEMPT_RECONNECT\", {\r\n        hasApiKey: true,\r\n      });\r\n    } else {\r\n      debugLogger.general(\"WARN\", \"[Alarm] Cannot auto-recover - no API key\");\r\n    }\r\n  }\r\n\r\n  // Ensure state machine is ready\r\n  await stateMachineReady;\r\n\r\n  if (alarm.name === \"longSleepRecovery\") {\r\n    const apiKey = getApiKey();\r\n    if (apiKey && (await stateMachineReady, stateMachine.isInState(ServiceWorkerState.IDLE) || stateMachine.isInState(ServiceWorkerState.ERROR))) {\r\n      debugLogger.general(\"INFO\", \"[Alarm] Long sleep recovery triggered\");\r\n      await stateMachine.transition(\"ATTEMPT_RECONNECT\", { hasApiKey: true });\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Handle our two main periodic alarms.\r\n  if (alarm.name === \"websocketHealthCheck\") {\r\n    const currentState = stateMachine.getCurrentState();\r\n\r\n    debugLogger.general(\r\n      \"DEBUG\",\r\n      \"[Alarm] Health check alarm fired\",\r\n      {\r\n        currentState,\r\n        hasWebSocketClient: !!websocketClient,\r\n      },\r\n    );\r\n\r\n    if (stateMachine.isInState(ServiceWorkerState.DEGRADED)) {\r\n      // Degraded mode: use polling fallback\r\n      await performPollingFetch();\r\n\r\n      // Check if we should escalate\r\n      const consecutiveFailures =\r\n        performanceMonitor.getQualityMetrics().consecutiveFailures;\r\n      if (consecutiveFailures >= 3) {\r\n        debugLogger.general(\r\n          \"WARN\",\r\n          \"[Degraded] Too many failures, escalating to ERROR\",\r\n        );\r\n        await stateMachine.transition(\"WS_PERMANENT_ERROR\");\r\n      } else {\r\n        // Try to reconnect WebSocket\r\n        await stateMachine.transition(\"ATTEMPT_RECONNECT\");\r\n      }\r\n    } else if (stateMachine.isInState(ServiceWorkerState.IDLE)) {\r\n      // NEW: Handle orphaned IDLE state\r\n      const apiKey = getApiKey();\r\n      if (apiKey) {\r\n        debugLogger.general(\r\n          \"WARN\",\r\n          \"[Alarm] Health check found IDLE state with API key - attempting recovery\",\r\n        );\r\n        await stateMachine.transition(\"ATTEMPT_RECONNECT\", {\r\n          hasApiKey: true,\r\n        });\r\n      } else {\r\n        debugLogger.general(\r\n          \"DEBUG\",\r\n          \"[Alarm] IDLE state without API key - nothing to do\",\r\n        );\r\n      }\r\n    } else {\r\n      // Normal state: perform health check\r\n      performWebSocketHealthCheck(websocketClient, connectWebSocket);\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * Context menu click handler\r\n */\r\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\r\n  // RACE CONDITION FIX: Ensure configuration is loaded before processing context menu action\r\n  await ensureConfigLoaded();\r\n\r\n  if (!getApiKey()) {\r\n    chrome.notifications.create(\"pushbullet-no-api-key\", {\r\n      type: \"basic\",\r\n      iconUrl: \"icons/icon128.png\",\r\n      title: \"Pushbullet\",\r\n      message: \"Please set your API key in the extension popup\",\r\n    });\r\n    return;\r\n  }\r\n\r\n  switch (info.menuItemId) {\r\n  case \"push-link\":\r\n    if (info.linkUrl && tab) {\r\n      pushLink(info.linkUrl, tab.title);\r\n    }\r\n    break;\r\n  case \"push-page\":\r\n    if (tab && tab.url) {\r\n      pushLink(tab.url, tab.title);\r\n    }\r\n    break;\r\n  case \"push-selection\":\r\n    if (info.selectionText && tab) {\r\n      pushNote(\"Selection from \" + (tab.title || \"page\"), info.selectionText);\r\n    }\r\n    break;\r\n  case \"push-image\":\r\n    if (info.srcUrl && tab) {\r\n      pushLink(info.srcUrl, \"Image from \" + (tab.title || \"page\"));\r\n    }\r\n    break;\r\n  }\r\n});\r\n\r\n/**\r\n * Message listener for popup communication\r\n */\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n  // SECURITY FIX (C-04): Validate sender for privileged actions\r\n  // Prevents external extensions/pages from sending privileged messages\r\n  if (!validatePrivilegedMessage(message.action, sender)) {\r\n    debugLogger.general(\r\n      \"ERROR\",\r\n      \"Rejected privileged message from untrusted sender\",\r\n      {\r\n        action: message.action,\r\n        senderId: sender?.id,\r\n        senderUrl: sender?.url,\r\n      },\r\n    );\r\n    sendResponse({ success: false, error: \"Unauthorized\" });\r\n    return false;\r\n  } else if (message.action === MessageAction.LOG) {\r\n    // Handler for centralized logging from other scripts (e.g., popup)\r\n    if (message.payload) {\r\n      const { level, message: logMessage, data } = message.payload;\r\n      const prefix = \"[POPUP]\"; // Add a prefix to identify the source\r\n\r\n      switch (level) {\r\n      case \"ERROR\":\r\n        debugLogger.general(\"ERROR\", `${prefix} ${logMessage}`, data);\r\n        break;\r\n      case \"WARN\":\r\n        debugLogger.general(\"WARN\", `${prefix} ${logMessage}`, data);\r\n        break;\r\n      case \"INFO\":\r\n      default:\r\n        debugLogger.general(\"INFO\", `${prefix} ${logMessage}`, data);\r\n        break;\r\n      }\r\n    }\r\n    // Return false because we are not sending a response asynchronously.\r\n    return false;\r\n  }\r\n\r\n  // Log the message (skip debug dashboard auto-refresh spam)\r\n  if (message.action !== MessageAction.GET_DEBUG_SUMMARY) {\r\n    debugLogger.general(\"DEBUG\", \"Message received\", {\r\n      type: message.type,\r\n      action: message.action,\r\n      sender: sender.id,\r\n    });\r\n  }\r\n\r\n  if (message.type === \"GET_PUSH_DATA\") {\r\n    debugLogger.general(\"DEBUG\", \"GET_PUSH_DATA request received\", {\r\n      notificationId: message.notificationId,\r\n    });\r\n\r\n    const push = notificationDataStore.get(message.notificationId);\r\n\r\n    if (push) {\r\n      debugLogger.general(\"DEBUG\", \"Push data found\", {\r\n        notificationId: message.notificationId,\r\n        pushType: push.type,\r\n      });\r\n\r\n      sendResponse({ success: true, push });\r\n    } else {\r\n      debugLogger.general(\"WARN\", \"Push data not found\", {\r\n        notificationId: message.notificationId,\r\n        storeSize: notificationDataStore.size,\r\n      });\r\n\r\n      sendResponse({ success: false, error: \"Push data not found\" });\r\n    }\r\n\r\n    return true; // IMPORTANT: Keep channel open\r\n  }\r\n\r\n  if (message.action === MessageAction.GET_SESSION_DATA) {\r\n    (async () => {\r\n      try {\r\n        // Ensure debug config is loaded\r\n        await ensureDebugConfigLoadedOnce();\r\n        // STEP 1: Load config from storage (handles service worker restarts)\r\n        await ensureConfigLoaded(\r\n          {\r\n            setApiKey,\r\n            setDeviceIden,\r\n            setAutoOpenLinks,\r\n            setDeviceNickname,\r\n            setNotificationTimeout,\r\n          },\r\n          {\r\n            getApiKey,\r\n            getDeviceIden,\r\n            getAutoOpenLinks,\r\n            getDeviceNickname,\r\n            getNotificationTimeout,\r\n          },\r\n        );\r\n\r\n        // STEP 2: Get API key after config is loaded\r\n        const apiKey = getApiKey();\r\n\r\n        // STEP 3: CRITICAL - Detect service worker wake-up\r\n        // If we have an API key in storage but session cache is empty, we need to re-initialize\r\n        const isWakeUp = apiKey && !sessionCache.isAuthenticated;\r\n\r\n        if (isWakeUp) {\r\n          debugLogger.general(\r\n            \"INFO\",\r\n            \"Service worker wake-up detected - checking for cached data\",\r\n            { timestamp: new Date().toISOString() },\r\n          );\r\n\r\n          // *** CRITICAL: Check if an init is already running ***\r\n          const existingInit = getInitPromise();\r\n\r\n          if (existingInit) {\r\n            debugLogger.general(\r\n              \"INFO\",\r\n              \"Initialization already in progress (likely from startup), awaiting completion\",\r\n              { source: \"getSessionData\" },\r\n            );\r\n\r\n            try {\r\n              await existingInit;\r\n              debugLogger.general(\r\n                \"INFO\",\r\n                \"Awaited startup initialization successfully\",\r\n              );\r\n            } catch (error) {\r\n              debugLogger.general(\r\n                \"ERROR\",\r\n                \"Startup initialization failed, popup will retry\",\r\n                null,\r\n                error as Error,\r\n              );\r\n              // Fall through to call orchestrateInitialization below\r\n            }\r\n          }\r\n\r\n          // *** USE ORCHESTRATE INITIALIZATION (has IndexedDB hydration) ***\r\n          if (!sessionCache.isAuthenticated) {\r\n            await orchestrateInitialization(\"popup-open\", connectWebSocket);\r\n          }\r\n        }\r\n\r\n        // STEP 4: Now check if we need to lazy-load recent pushes\r\n        // (This only applies if we didn't just do a full re-initialization)\r\n        const shouldFetchPushes =\r\n          !isWakeUp &&\r\n          apiKey &&\r\n          (!sessionCache.recentPushes ||\r\n            sessionCache.recentPushes.length === 0);\r\n\r\n        if (shouldFetchPushes) {\r\n          debugLogger.general(\r\n            \"INFO\",\r\n            \"Popup opened - fetching recent pushes on-demand\",\r\n          );\r\n\r\n          const pushes = await fetchRecentPushes(apiKey);\r\n          sessionCache.recentPushes = pushes;\r\n          sessionCache.lastUpdated = Date.now();\r\n\r\n          debugLogger.general(\"INFO\", \"Recent pushes fetched on-demand\", {\r\n            count: pushes.length,\r\n          });\r\n        } else if (!isWakeUp) {\r\n          debugLogger.general(\"DEBUG\", \"Popup opened - using cached pushes\", {\r\n            count: sessionCache.recentPushes?.length ?? 0,\r\n          });\r\n        }\r\n\r\n        // FORCE REFRESH DEVICES FOR POPUP - BYPASS CACHE\r\n        if (apiKey) {\r\n          debugLogger.general(\"INFO\", \"Force refreshing devices for popup\");\r\n          const devices = await fetchDevices(apiKey);\r\n          sessionCache.devices = devices;\r\n        }\r\n\r\n        // STEP 5: Apply onlyThisDevice filter to recentPushes for display\r\n        const onlyThisDevice = await storageRepository.getOnlyThisDevice() || false;\r\n        const deviceIden = await storageRepository.getDeviceIden();\r\n        const filteredPushes = onlyThisDevice && deviceIden \r\n          ? sessionCache.recentPushes.filter((p: any) => p.target_device_iden === deviceIden)\r\n          : sessionCache.recentPushes;\r\n        debugLogger.general('INFO', 'Recent pushes filtered for display', {\r\n          total: sessionCache.recentPushes.length,\r\n          filtered: filteredPushes.length,\r\n          onlyThisDevice,\r\n          hasDeviceIden: !!deviceIden\r\n        });\r\n\r\n        // STEP 5: Send response with session data\r\n        sendResponse({\r\n          isAuthenticated: !!apiKey,\r\n          userInfo: sessionCache.userInfo,\r\n          devices: sessionCache.devices,\r\n          recentPushes: filteredPushes,\r\n          chats: sessionCache.chats,\r\n          autoOpenLinks: getAutoOpenLinks(),\r\n          deviceNickname: getDeviceNickname(),\r\n          websocketConnected: websocketClient\r\n            ? websocketClient.isConnected()\r\n            : false,\r\n          state: stateMachine.getCurrentState(),\r\n        });\r\n      } catch (error) {\r\n        debugLogger.general(\"ERROR\", \"Failed to handle GETSESSIONDATA\", {\r\n          error: (error as Error).message,\r\n        });\r\n\r\n        sendResponse({\r\n          isAuthenticated: false,\r\n          userInfo: null,\r\n          devices: [],\r\n          recentPushes: [],\r\n          chats: [],\r\n          autoOpenLinks: false,\r\n          deviceNickname: \"\",\r\n          websocketConnected: false,\r\n          state: stateMachine.getCurrentState(),\r\n        });\r\n      }\r\n    })();\r\n\r\n    return true; // Keep channel open for async response\r\n  } else if (message.action === MessageAction.API_KEY_CHANGED) {\r\n    // Update API key\r\n    setApiKey(message.apiKey);\r\n\r\n    // Build promise chain\r\n    let savePromise = storageRepository.setApiKey(message.apiKey);\r\n\r\n    // Update device nickname if provided\r\n    if (message.deviceNickname) {\r\n      savePromise = savePromise.then(() => {\r\n        setDeviceNickname(message.deviceNickname);\r\n        sessionCache.deviceNickname = message.deviceNickname as string;\r\n        return storageRepository.setDeviceNickname(\r\n          message.deviceNickname as string,\r\n        );\r\n      });\r\n    }\r\n\r\n    // ARCHITECTURAL CHANGE: Use state machine instead of direct initialization\r\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\r\n    savePromise\r\n      .then(() => stateMachineReady)\r\n      .then(() => {\r\n        return stateMachine.transition(\"API_KEY_SET\", {\r\n          apiKey: message.apiKey,\r\n        });\r\n      })\r\n      .then(() => {\r\n        // Send response with session data after state machine completes\r\n        sendResponse({\r\n          isAuthenticated:\r\n            stateMachine.isInState(ServiceWorkerState.READY) ||\r\n            stateMachine.isInState(ServiceWorkerState.DEGRADED),\r\n          userInfo: sessionCache.userInfo,\r\n          devices: sessionCache.devices,\r\n          recentPushes: sessionCache.recentPushes,\r\n          chats: sessionCache.chats || [], // \u2190 ADD THIS\r\n          autoOpenLinks: sessionCache.autoOpenLinks,\r\n          deviceNickname: sessionCache.deviceNickname,\r\n          websocketConnected: websocketClient\r\n            ? websocketClient.isConnected()\r\n            : false,\r\n          state: stateMachine.getCurrentState(),\r\n        });\r\n      })\r\n      .catch((error) => {\r\n        debugLogger.general(\"ERROR\", \"Error saving API key\", null, error);\r\n        sendResponse({ success: false, error: error.message });\r\n      });\r\n\r\n    return true; // Keep message channel open for async response\r\n  } else if (message.action === MessageAction.LOGOUT) {\r\n    // ARCHITECTURAL CHANGE: Use state machine for logout\r\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\r\n    stateMachineReady\r\n      .then(() => {\r\n        return stateMachine.transition(\"LOGOUT\");\r\n      })\r\n      .then(() => {\r\n        // Clear storage via repository\r\n        return storageRepository.setApiKey(null);\r\n      })\r\n      .then(() => {\r\n        return storageRepository.setDeviceIden(null);\r\n      })\r\n      .then(() => {\r\n        return clearSessionCache();\r\n      })\r\n      .then(() => {\r\n        sendResponse({ success: true });\r\n      })\r\n      .catch((error) => {\r\n        debugLogger.general(\"ERROR\", \"Error during logout\", null, error);\r\n        sendResponse({ success: false, error: error.message });\r\n      });\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.REFRESH_SESSION) {\r\n    // RACE CONDITION FIX: Ensure configuration is loaded before processing\r\n    (async () => {\r\n      await ensureDebugConfigLoadedOnce();\r\n      await ensureConfigLoaded();\r\n\r\n      const apiKey = getApiKey();\r\n      if (apiKey) {\r\n        refreshSessionCache(apiKey)\r\n          .then(() => {\r\n            sendResponse({\r\n              isAuthenticated: true,\r\n              userInfo: sessionCache.userInfo,\r\n              devices: sessionCache.devices,\r\n              recentPushes: sessionCache.recentPushes,\r\n              chats: sessionCache.chats || [], // \u2190 ADD THIS\r\n              autoOpenLinks: sessionCache.autoOpenLinks,\r\n              deviceNickname: sessionCache.deviceNickname,\r\n              state: stateMachine.getCurrentState(),\r\n            });\r\n          })\r\n          .catch((error) => {\r\n            debugLogger.general(\r\n              \"ERROR\",\r\n              \"Error refreshing session\",\r\n              null,\r\n              error,\r\n            );\r\n            sendResponse({ isAuthenticated: false });\r\n          });\r\n      } else {\r\n        sendResponse({ isAuthenticated: false });\r\n      }\r\n    })();\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.SETTINGS_CHANGED) {\r\n    const promises: Promise<void>[] = [];\r\n\r\n    // BONUS FIX: Handle device nickname updates from \"Save All Settings\" button\r\n    if (message.settings?.deviceNickname) {\r\n      const newNickname = message.settings.deviceNickname;\r\n      const apiKey = getApiKey();\r\n      const deviceIden = getDeviceIden();\r\n\r\n      // Trigger API update if we have the required credentials\r\n      if (apiKey && deviceIden) {\r\n        promises.push(\r\n          updateDeviceNickname(apiKey, deviceIden, newNickname).then(() => {\r\n            // Only update state and storage after API success\r\n            setDeviceNickname(newNickname);\r\n            sessionCache.deviceNickname = newNickname;\r\n            return storageRepository.setDeviceNickname(newNickname);\r\n          }),\r\n        );\r\n      } else {\r\n        // No API credentials, just update local state and storage\r\n        setDeviceNickname(newNickname);\r\n        sessionCache.deviceNickname = newNickname;\r\n        promises.push(storageRepository.setDeviceNickname(newNickname));\r\n      }\r\n    }\r\n\r\n    if (message.autoOpenLinks !== undefined) {\r\n      setAutoOpenLinks(message.autoOpenLinks);\r\n      sessionCache.autoOpenLinks = message.autoOpenLinks;\r\n      promises.push(storageRepository.setAutoOpenLinks(message.autoOpenLinks));\r\n    }\r\n\r\n    if (message.notificationTimeout !== undefined) {\r\n      setNotificationTimeout(message.notificationTimeout);\r\n      promises.push(\r\n        storageRepository.setNotificationTimeout(message.notificationTimeout),\r\n      );\r\n    }\r\n\r\n    Promise.all(promises)\r\n      .then(() => {\r\n        sendResponse({ success: true });\r\n      })\r\n      .catch((error) => {\r\n        debugLogger.general(\"ERROR\", \"Error saving settings\", null, error);\r\n        sendResponse({ success: false, error: error.message });\r\n      });\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.UPDATE_DEVICE_NICKNAME) {\r\n    // RACE CONDITION FIX: Ensure configuration is loaded before processing\r\n    (async () => {\r\n      await ensureDebugConfigLoadedOnce();\r\n      await ensureConfigLoaded();\r\n\r\n      const apiKey = getApiKey();\r\n      const deviceIden = getDeviceIden();\r\n\r\n      if (apiKey && deviceIden && message.nickname) {\r\n        updateDeviceNickname(apiKey, deviceIden, message.nickname)\r\n          .then(async () => {\r\n            setDeviceNickname(message.nickname);\r\n            sessionCache.deviceNickname = message.nickname;\r\n            await storageRepository.setDeviceNickname(message.nickname);\r\n\r\n            sendResponse({ success: true });\r\n          })\r\n          .catch((error) => {\r\n            debugLogger.general(\r\n              \"ERROR\",\r\n              \"Error updating device nickname\",\r\n              null,\r\n              error,\r\n            );\r\n            sendResponse({ success: false, error: error.message });\r\n          });\r\n      } else {\r\n        sendResponse({ success: false, error: \"Missing required parameters\" });\r\n      }\r\n    })();\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.GET_DEBUG_SUMMARY) {\r\n    // Return debug summary for debug dashboard\r\n    (async () => {\r\n      // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\r\n      await stateMachineReady;\r\n\r\n      const logData = debugLogger.exportLogs();\r\n      const wsState = wsStateMonitor.getStateReport();\r\n      const perfData = performanceMonitor.exportPerformanceData();\r\n      const perfSummary = perfData.summary;\r\n\r\n      // Format websocket state for dashboard compatibility\r\n      const websocketState = {\r\n        current: {\r\n          stateText: websocketClient\r\n            ? websocketClient.isConnected()\r\n              ? \"Connected\"\r\n              : \"Disconnected\"\r\n            : \"Not initialized\",\r\n          readyState: wsState.currentState,\r\n          stateMachineState: stateMachine.getCurrentState(),\r\n          stateMachineDescription: stateMachine.getStateDescription(),\r\n        },\r\n        lastCheck: wsState.lastCheck,\r\n        historyLength: wsState.historyLength,\r\n      };\r\n\r\n      // Map performance data to match frontend expectations\r\n      // The frontend expects: { websocket, qualityMetrics, notifications }\r\n      // The backend provides: { summary: { websocket, health, quality, metrics, notifications } }\r\n      const performanceForDashboard = {\r\n        websocket: perfSummary.websocket,\r\n        qualityMetrics: {\r\n          // Map health checks\r\n          healthChecksPassed: perfSummary.health?.success || 0,\r\n          healthChecksFailed: perfSummary.health?.failure || 0,\r\n          // Map quality metrics\r\n          disconnectionCount: perfSummary.quality?.disconnections || 0,\r\n          consecutiveFailures: perfSummary.quality?.consecutiveFailures || 0,\r\n          // These metrics don't exist in the backend yet, so they'll be undefined\r\n          averageLatency: undefined,\r\n          minLatency: undefined,\r\n          maxLatency: undefined,\r\n          connectionUptime: 0,\r\n          currentUptime: 0,\r\n        },\r\n        notifications: perfSummary.notifications,\r\n      };\r\n\r\n      // MV3 LIFECYCLE TRACKING: Gather metrics for dashboard\r\n      const { restarts = 0, recoveryTimings = [] } =\r\n        await chrome.storage.local.get([\"restarts\", \"recoveryTimings\"]);\r\n      const avgRecoveryTime =\r\n        recoveryTimings.length > 0\r\n          ? recoveryTimings.reduce((a: number, b: number) => a + b, 0) /\r\n            recoveryTimings.length\r\n          : 0;\r\n\r\n      const mv3LifecycleStats = {\r\n        restarts: restarts,\r\n        wakeUpTriggers: initTracker.exportData().stats, // We already track this!\r\n        avgRecoveryTime: avgRecoveryTime.toFixed(0) + \" ms\",\r\n        // Add more stats like downtime here in the future\r\n      };\r\n\r\n      const summary = {\r\n        config: debugConfigManager.getConfig(),\r\n        logs: logData.logs, // Array of log entries\r\n        totalLogs: logData.summary.totalLogs,\r\n        performance: performanceForDashboard,\r\n        websocketState: websocketState,\r\n        initializationStats: initTracker.exportData(),\r\n        mv3LifecycleStats: mv3LifecycleStats, // Add the new data object\r\n        errors: {\r\n          total: logData.summary.errors,\r\n          last24h: logData.summary.errors, // Add last24h for dashboard\r\n          critical: [],\r\n        },\r\n      };\r\n\r\n      sendResponse({ success: true, summary });\r\n    })();\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.CLEAR_ALL_LOGS) {\r\n    // Clear all logs from memory and persistent storage\r\n    debugLogger.clearLogs().then(() => {\r\n      sendResponse({ success: true });\r\n    });\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.UPDATE_DEBUG_CONFIG) {\r\n    // Update debug configuration\r\n    if (message.config) {\r\n      debugConfigManager\r\n        .updateConfig(message.config)\r\n        .then(() => {\r\n          sendResponse({ success: true });\r\n        })\r\n        .catch((error: any) => {\r\n          debugLogger.general(\r\n            \"ERROR\",\r\n            \"Failed to update debug config\",\r\n            null,\r\n            error,\r\n          );\r\n          sendResponse({ success: false, error: error.message });\r\n        });\r\n    } else {\r\n      sendResponse({ success: false, error: \"No config provided\" });\r\n    }\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.EXPORT_DEBUG_DATA) {\r\n    // This handler gathers all debug data for exporting\r\n    debugLogger.general(\"INFO\", \"Exporting full debug data\");\r\n\r\n    // STATE MACHINE HYDRATION: Ensure state machine is ready before using it\r\n    (async () => {\r\n      await ensureDebugConfigLoadedOnce();\r\n      await stateMachineReady;\r\n\r\n      const logData = debugLogger.exportLogs();\r\n      const errorSummary = globalErrorTracker.getErrorSummary();\r\n\r\n      const dataToExport = {\r\n        timestamp: new Date().toISOString(),\r\n        version: chrome.runtime.getManifest().version,\r\n        debugLogs: logData,\r\n        performanceData: performanceMonitor.exportPerformanceData(),\r\n        systemInfo: {\r\n          websocketState: wsStateMonitor.getStateReport(),\r\n          initializationData: initTracker.exportData(),\r\n          stateMachine: {\r\n            currentState: stateMachine.getCurrentState(),\r\n            description: stateMachine.getStateDescription(),\r\n          },\r\n        },\r\n        errorData: {\r\n          summary: errorSummary,\r\n          recent: globalErrorTracker.exportErrorData().errors,\r\n        },\r\n        sessionCache: {\r\n          isAuthenticated: sessionCache.isAuthenticated,\r\n          lastUpdated: sessionCache.lastUpdated\r\n            ? new Date(sessionCache.lastUpdated).toISOString()\r\n            : \"never\",\r\n          userInfo: sessionCache.userInfo\r\n            ? { email: sessionCache.userInfo.email?.substring(0, 3) + \"***\" }\r\n            : null,\r\n          deviceCount: sessionCache.devices?.length || 0,\r\n          pushCount: sessionCache.recentPushes?.length || 0,\r\n        },\r\n      };\r\n\r\n      sendResponse({ success: true, data: dataToExport });\r\n    })();\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.GET_NOTIFICATION_DATA) {\r\n    // Return notification data for detail view\r\n    const pushData = notificationDataStore.get(message.notificationId);\r\n    if (pushData) {\r\n      sendResponse({ success: true, push: pushData });\r\n    } else {\r\n      sendResponse({ success: false, error: \"Notification not found\" });\r\n    }\r\n    return false; // Synchronous response\r\n  } else if (message.action === \"attemptReconnect\") {\r\n    debugLogger.general(\"INFO\", \"Manual reconnection requested from popup\");\r\n\r\n    (async () => {\r\n      await stateMachine.transition(\"ATTEMPT_RECONNECT\");\r\n      sendResponse({ success: true });\r\n    })();\r\n\r\n    return true; // Async response\r\n  } else if (message.action === MessageAction.SEND_PUSH) {\r\n    // Handle push sending from popup\r\n    // SERVICE WORKER AMNESIA FIX: Ensure configuration is loaded before attempting to send push\r\n    (async () => {\r\n      try {\r\n        await ensureDebugConfigLoadedOnce();\r\n        // Ensure core configuration is loaded from storage if service worker just woke up\r\n        await ensureConfigLoaded();\r\n\r\n        const apiKey = getApiKey();\r\n        if (!apiKey) {\r\n          sendResponse({\r\n            success: false,\r\n            error: \"Not logged in. Please try again.\",\r\n          });\r\n          return;\r\n        }\r\n\r\n        const pushData = message.pushData;\r\n        if (!pushData || !pushData.type) {\r\n          sendResponse({ success: false, error: \"Invalid push data\" });\r\n          return;\r\n        }\r\n\r\n        // Send push via API\r\n        const response = await fetch(\"https://api.pushbullet.com/v2/pushes\", {\r\n          method: \"POST\",\r\n          headers: {\r\n            \"Access-Token\": apiKey,\r\n            \"Content-Type\": \"application/json\",\r\n          },\r\n          body: JSON.stringify(pushData),\r\n        });\r\n\r\n        if (!response.ok) {\r\n          const errorText = await response.text();\r\n          let errorMessage = \"Failed to send push\";\r\n          try {\r\n            const errorData = JSON.parse(errorText) as {\r\n              error?: { message?: string };\r\n            };\r\n            if (errorData.error?.message) {\r\n              errorMessage = errorData.error.message;\r\n            }\r\n          } catch {\r\n            // Use default\r\n          }\r\n          throw new Error(errorMessage);\r\n        }\r\n\r\n        // Refresh pushes after sending\r\n        try {\r\n          await refreshPushes(notificationDataStore);\r\n        } catch (error) {\r\n          // Check if it's an invalid cursor error\r\n          if ((error as Error).name === \"InvalidCursorError\") {\r\n            debugLogger.general(\r\n              \"WARN\",\r\n              \"Caught invalid cursor error during push send - triggering recovery\",\r\n            );\r\n            const apiKey = getApiKey();\r\n            if (apiKey) {\r\n              await handleInvalidCursorRecovery(apiKey, connectWebSocket);\r\n            }\r\n          } else {\r\n            // Re-throw other errors\r\n            debugLogger.general(\r\n              \"ERROR\",\r\n              \"Error refreshing pushes after send\",\r\n              null,\r\n              error as Error,\r\n            );\r\n          }\r\n        }\r\n\r\n        sendResponse({ success: true });\r\n      } catch (error) {\r\n        debugLogger.general(\r\n          \"ERROR\",\r\n          \"Failed to send push\",\r\n          { pushType: message.pushData?.type },\r\n          error as Error,\r\n        );\r\n        sendResponse({ success: false, error: (error as Error).message });\r\n      }\r\n    })();\r\n\r\n    return true; // Async response\r\n  }\r\n\r\n  return false;\r\n});\r\n\r\n// Notification clicked handler\r\nchrome.notifications.onClicked.addListener((notificationId: string) => {\r\n  debugLogger.notifications(\"INFO\", \"Notification clicked\", {\r\n    notificationId,\r\n  });\r\n\r\n  // Get the push data from the notification store\r\n  const push = notificationDataStore.get(notificationId);\r\n\r\n  if (!push) {\r\n    debugLogger.notifications(\r\n      \"WARN\",\r\n      \"No push data found for clicked notification\",\r\n      {\r\n        notificationId,\r\n      },\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Open notification detail page in a popup window\r\n  const detailUrl = chrome.runtime.getURL(\r\n    `notification-detail.html?id=${encodeURIComponent(notificationId)}`,\r\n  );\r\n\r\n  chrome.windows.create(\r\n    {\r\n      url: detailUrl,\r\n      type: \"popup\",\r\n      width: 500,\r\n      height: 600,\r\n      focused: true,\r\n    },\r\n    (window) => {\r\n      if (chrome.runtime.lastError) {\r\n        debugLogger.notifications(\r\n          \"ERROR\",\r\n          \"Failed to open notification detail\",\r\n          {\r\n            notificationId,\r\n            error: chrome.runtime.lastError.message,\r\n          },\r\n        );\r\n      } else {\r\n        debugLogger.notifications(\r\n          \"INFO\",\r\n          \"Notification detail opened in popup\",\r\n          {\r\n            notificationId,\r\n            windowId: window?.id,\r\n          },\r\n        );\r\n      }\r\n    },\r\n  );\r\n\r\n  // Clear the notification after opening\r\n  chrome.notifications.clear(notificationId);\r\n});\r\n\r\n// Export debug info function for console access\r\n(globalThis as any).exportDebugInfo = function () {\r\n  return {\r\n    debugLogs: debugLogger.exportLogs(),\r\n    performanceData: performanceMonitor.exportPerformanceData(),\r\n    websocketState: wsStateMonitor.getStateReport(),\r\n    initializationData: initTracker.exportData(),\r\n    sessionCache: {\r\n      isAuthenticated: sessionCache.isAuthenticated,\r\n      lastUpdated: sessionCache.lastUpdated\r\n        ? new Date(sessionCache.lastUpdated).toISOString()\r\n        : \"never\",\r\n      userInfo: sessionCache.userInfo\r\n        ? { email: sessionCache.userInfo.email?.substring(0, 3) + \"***\" }\r\n        : null,\r\n      deviceCount: sessionCache.devices?.length || 0,\r\n      pushCount: sessionCache.recentPushes?.length || 0,\r\n    },\r\n    websocketConnected: websocketClient ? websocketClient.isConnected() : false,\r\n  };\r\n};\r\n\r\ndebugLogger.general(\"INFO\", \"Background service worker initialized\", {\r\n  timestamp: new Date().toISOString(),\r\n});\r\n\r\n// Bootstrap initialization immediately on startup/install\r\nasync function bootstrap(\r\n  trigger: \"startup\" | \"install\" | \"wakeup\",\r\n): Promise<void> {\r\n  debugLogger.general(\"INFO\", \"Bootstrap start\", { trigger });\r\n\r\n  // --- CRITICAL FIX START ---\r\n  // Ensure configuration is loaded BEFORE checking for API key\r\n  // The STARTUP event needs accurate hasApiKey state\r\n\r\n  // STEP 1: Load config (with error handling that doesn't stop execution)\r\n  await ensureConfigLoaded(\r\n    {\r\n      setApiKey,\r\n      setDeviceIden,\r\n      setAutoOpenLinks,\r\n      setDeviceNickname,\r\n      setNotificationTimeout,\r\n    },\r\n    {\r\n      getApiKey,\r\n      getDeviceIden,\r\n      getAutoOpenLinks,\r\n      getDeviceNickname,\r\n      getNotificationTimeout,\r\n    },\r\n  ).catch((error) => {\r\n    debugLogger.general(\r\n      \"ERROR\",\r\n      \"Failed to load config before STARTUP\",\r\n      null,\r\n      error as Error,\r\n    );\r\n    // Don't throw - continue execution. We'll get null from getApiKey which is fine.\r\n  });\r\n\r\n  debugLogger.general(\"DEBUG\", \"Configuration loaded before STARTUP event\");\r\n\r\n  // STEP 2: Verify what was actually loaded (CRITICAL DEBUG INFO)\r\n  const apiKey = getApiKey();\r\n  const deviceIden = getDeviceIden();\r\n  const autoOpenLinks = getAutoOpenLinks();\r\n  const deviceNickname = getDeviceNickname();\r\n\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"[BOOTSTRAP_DEBUG] Config state after ensureConfigLoaded\",\r\n    {\r\n      hasApiKey: !!apiKey,\r\n      apiKeyLength: apiKey?.length || 0,\r\n      apiKeyPrefix: apiKey ? `${apiKey.substring(0, 8)}...` : \"null\",\r\n      hasDeviceIden: !!deviceIden,\r\n      deviceIden: deviceIden || \"null\",\r\n      autoOpenLinks: autoOpenLinks,\r\n      deviceNickname: deviceNickname || \"null\",\r\n    },\r\n  );\r\n\r\n  // STEP 3: Wait for state machine and trigger STARTUP\r\n  await stateMachineReady;\r\n\r\n  debugLogger.general(\"INFO\", \"[BOOTSTRAP_DEBUG] Triggering STARTUP event\", {\r\n    hasApiKey: !!apiKey,\r\n    apiKeyLength: apiKey?.length || 0,\r\n    trigger: trigger,\r\n  });\r\n\r\n  await stateMachine.transition(\"STARTUP\", { hasApiKey: !!apiKey });\r\n\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"[BOOTSTRAP_DEBUG] STARTUP transition completed\",\r\n    {\r\n      newState: stateMachine.getCurrentState(),\r\n    },\r\n  );\r\n  // --- CRITICAL FIX END ---\r\n\r\n  // NEW: Detect orphaned session and trigger recovery\r\n  if (\r\n    apiKey &&\r\n    stateMachine.isInState(\r\n      ServiceWorkerState.IDLE,\r\n    )\r\n  ) {\r\n    debugLogger.general(\r\n      \"WARN\",\r\n      \"[Bootstrap] Detected orphaned session: have API key but state is IDLE. Triggering recovery.\",\r\n    );\r\n\r\n    // Attempt to recover by transitioning to initializing\r\n    try {\r\n      await stateMachine.transition(\r\n        \"ATTEMPT_RECONNECT\",\r\n        {\r\n          hasApiKey: true,\r\n        },\r\n      );\r\n    } catch (error) {\r\n      debugLogger.general(\r\n        \"ERROR\",\r\n        \"[Bootstrap] Failed to recover orphaned session\",\r\n        null,\r\n        error as Error,\r\n      );\r\n    }\r\n  }\r\n\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"Bootstrap completed\",\r\n    {\r\n      finalState:\r\n        stateMachine.getCurrentState(),\r\n      trigger,\r\n    },\r\n  );\r\n\r\n  // The orchestrateInitialization is now primarily driven by the state machine's\r\n  // onInitialize callback, but we can keep this for redundancy if desired.\r\n  void orchestrateInitialization(trigger, connectWebSocket);\r\n}\r\n\r\nchrome.runtime.onStartup.addListener(async () => {\r\n  await ensureDebugConfigLoadedOnce();\r\n  chrome.alarms.create('longSleepRecovery', { periodInMinutes: 5 });\r\n  void bootstrap(\"startup\");\r\n});\r\nchrome.runtime.onInstalled.addListener(async () => {\r\n  await ensureDebugConfigLoadedOnce();\r\n  void bootstrap(\"install\");\r\n});\r\n\r\n// Optional: if you also track other wake-ups, funnel them here too\r\n// chrome.alarms.onAlarm.addListener(a => {\r\n//   if (a.name === 'keepAlive' || a.name === 'recovery') { void bootstrap('wakeup'); }\r\n// });\r\n\r\n// Diagnostic function to check extension health\r\nasync function checkExtensionHealth(): Promise<void> {\r\n  const apiKey = getApiKey();\r\n  const currentState = stateMachine.getCurrentState();\r\n  const isConnected = websocketClient?.isConnected() ?? false;\r\n\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"[Diagnostic] Extension health check\",\r\n    {\r\n      hasApiKey: !!apiKey,\r\n      currentState,\r\n      isConnected,\r\n      hasWebSocketClient: !!websocketClient,\r\n      sessionAuthenticated: sessionCache.isAuthenticated,\r\n      lastUpdated: sessionCache.lastUpdated\r\n        ? new Date(sessionCache.lastUpdated).toISOString()\r\n        : \"never\",\r\n    },\r\n  );\r\n\r\n  // Check for inconsistent state\r\n  if (\r\n    apiKey &&\r\n    currentState === ServiceWorkerState.IDLE &&\r\n    !isConnected\r\n  ) {\r\n    debugLogger.general(\r\n      \"ERROR\",\r\n      \"[Diagnostic] INCONSISTENT STATE DETECTED: Have API key but in IDLE state without connection\",\r\n    );\r\n    return;\r\n  }\r\n\r\n  if (!apiKey && currentState !== ServiceWorkerState.IDLE) {\r\n    debugLogger.general(\r\n      \"ERROR\",\r\n      \"[Diagnostic] INCONSISTENT STATE DETECTED: No API key but not in IDLE state\",\r\n    );\r\n    return;\r\n  }\r\n\r\n  debugLogger.general(\r\n    \"INFO\",\r\n    \"[Diagnostic] Extension state is consistent\",\r\n  );\r\n}\r\n\r\n// Run diagnostic on startup\r\nchrome.runtime.onStartup.addListener(async () => {\r\n  await ensureDebugConfigLoadedOnce();\r\n  setTimeout(checkExtensionHealth, 5000); // Wait 5 seconds after startup\r\n});\r\n\r\nexport { stateMachine };\r\n"],
  "mappings": "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",
  "names": ["getApiKey", "apiKey", "apiKey", "error", "deviceIden", "deviceNickname", "device", "apiKey", "pushes", "apiKey", "updatedCutoff", "apiKey", "deviceIden", "deviceNickname", "autoOpenLinks", "notificationTimeout", "API_BASE_URL", "PUSHES_URL", "DEVICES_URL", "USER_INFO_URL", "isLinkPush", "apiKey", "apiKey", "notificationDataStore", "apiKey", "websocketClient", "apiKey", "ServiceWorkerState", "apiKey", "websocketClient", "apiKey", "autoOpenLinks", "deviceIden", "deviceNickname"]
}
