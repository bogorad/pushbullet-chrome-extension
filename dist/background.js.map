{
  "version": 3,
  "sources": ["../src/lib/logging/index.ts", "../src/lib/perf/index.ts", "../src/lib/monitoring/index.ts", "../src/app/notifications/index.ts", "../src/app/ws/client.ts", "../src/app/api/client.ts", "../src/app/session/index.ts", "../src/app/reconnect/index.ts", "../src/lib/crypto/index.ts", "../src/background/state.ts", "../src/background/utils.ts", "../src/lib/security/message-validation.ts", "../src/background/index.ts"],
  "sourcesContent": ["/* Logging and debug configuration (TypeScript)\n   Mirrors js/logging.js without changing behavior. */\n\nexport type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';\nexport type LogCategory = 'WEBSOCKET' | 'NOTIFICATIONS' | 'API' | 'STORAGE' | 'GENERAL' | 'PERFORMANCE' | 'ERROR';\n\nexport interface DebugConfig {\n  enabled: boolean;\n  categories: Record<LogCategory, boolean>;\n  logLevel: LogLevel;\n  maxLogEntries: number;\n  sanitizeData: boolean;\n}\n\nexport const DEBUG_CONFIG: DebugConfig = {\n  enabled: true,\n  categories: { WEBSOCKET: true, NOTIFICATIONS: true, API: true, STORAGE: true, GENERAL: true, PERFORMANCE: true, ERROR: true },\n  logLevel: 'DEBUG',\n  maxLogEntries: 1000,\n  sanitizeData: true,\n};\n\nexport interface LogEntry {\n  timestamp: string;\n  category: LogCategory;\n  level: LogLevel;\n  message: string;\n  data: unknown | null;\n  error: { name: string; message: string; stack?: string } | null;\n}\n\nexport class DebugLogger {\n  private logs: LogEntry[] = [];\n  private startTime = Date.now();\n  private performanceMarkers = new Map<string, number>();\n\n  private sanitize(data: unknown): unknown {\n    if (!DEBUG_CONFIG.sanitizeData) return data;\n    if (typeof data === 'string') {\n      if (data.length > 20 && /^[a-zA-Z0-9_-]+$/.test(data)) {\n        return data.substring(0, 4) + '***' + data.substring(data.length - 4);\n      }\n      return data;\n    }\n    if (data && typeof data === 'object') {\n      const sanitized: Record<string, unknown> | unknown[] = Array.isArray(data) ? [] : {};\n      for (const key in data as Record<string, unknown>) {\n        if (key.toLowerCase().includes('token') || key.toLowerCase().includes('key') || key.toLowerCase().includes('password')) {\n          (sanitized as any)[key] = this.sanitize((data as any)[key]);\n        } else {\n          (sanitized as any)[key] = (data as any)[key];\n        }\n      }\n      return sanitized;\n    }\n    return data;\n  }\n\n  private getTimestamp(): string {\n    const now = new Date();\n    const elapsed = Date.now() - this.startTime;\n    return `${now.toISOString()} (+${elapsed}ms)`;\n  }\n\n  log(category: LogCategory, level: LogLevel, message: string, data: unknown = null, error: Error | null = null) {\n    if (!DEBUG_CONFIG.enabled || !DEBUG_CONFIG.categories[category]) return;\n    const timestamp = this.getTimestamp();\n    const entry: LogEntry = {\n      timestamp,\n      category,\n      level,\n      message,\n      data: data ? this.sanitize(data) : null,\n      error: error ? { name: error.name, message: error.message, stack: (error as any).stack } : null,\n    };\n    if (error && level === 'ERROR') {\n      globalErrorTracker.trackError(error, { category, message, data: data ? this.sanitize(data) : null }, category);\n    }\n    this.logs.push(entry);\n    if (this.logs.length > DEBUG_CONFIG.maxLogEntries) this.logs.shift();\n\n    const prefix = `[${category}:${level}] ${timestamp}`;\n    const full = `${prefix} ${message}`;\n    const sanitized = data ? this.sanitize(data) : null;\n    switch (level) {\n      case 'ERROR':\n        if (sanitized && error) { console.error(full); console.error('  Data:', sanitized); console.error('  Error:', error); }\n        else if (sanitized) { console.error(full); console.error('  Data:', sanitized); }\n        else if (error) { console.error(full); console.error('  Error:', error); }\n        else { console.error(full); }\n        break;\n      case 'WARN':\n        if (sanitized) { console.warn(full); console.warn('  Data:', sanitized); } else { console.warn(full); }\n        break;\n      case 'INFO':\n        if (sanitized) { console.info(full); console.info('  Data:', sanitized); } else { console.info(full); }\n        break;\n      default:\n        if (sanitized) { console.log(full); console.log('  Data:', sanitized); } else { console.log(full); }\n    }\n  }\n\n  websocket(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('WEBSOCKET', level, message, data, error || null); }\n  notifications(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('NOTIFICATIONS', level, message, data, error || null); }\n  api(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('API', level, message, data, error || null); }\n  storage(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('STORAGE', level, message, data, error || null); }\n  general(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('GENERAL', level, message, data, error || null); }\n  performance(level: LogLevel, message: string, data?: unknown, error?: Error) { this.log('PERFORMANCE', level, message, data, error || null); }\n  error(message: string, data?: unknown, error?: Error) { this.log('ERROR', 'ERROR', message, data, error || null); }\n\n  startTimer(name: string) { this.performanceMarkers.set(name, Date.now()); this.performance('DEBUG', `Timer started: ${name}`); }\n  endTimer(name: string): number | null {\n    const start = this.performanceMarkers.get(name);\n    if (start) { const duration = Date.now() - start; this.performanceMarkers.delete(name); this.performance('INFO', `Timer ended: ${name}`, { duration: `${duration}ms` }); return duration; }\n    this.performance('WARN', `Timer not found: ${name}`); return null;\n  }\n  getRecentLogs(count = 50, category: LogCategory | null = null) {\n    let logs = this.logs; if (category) logs = logs.filter(l => l.category === category); return logs.slice(-count);\n  }\n  exportLogs() {\n    return {\n      config: DEBUG_CONFIG,\n      logs: this.logs,\n      summary: {\n        totalLogs: this.logs.length,\n        categories: (Object.keys(DEBUG_CONFIG.categories) as LogCategory[]).reduce((acc: Record<string, number>, cat) => { acc[cat] = this.logs.filter(l => l.category === cat).length; return acc; }, {}),\n        errors: this.logs.filter(l => l.level === 'ERROR').length,\n      }\n    };\n  }\n}\n\nexport const debugLogger = new DebugLogger();\n\nexport class DebugConfigManager {\n  async loadConfig() {\n    try {\n      debugLogger.storage('DEBUG', 'Loading debug configuration from storage');\n      const result = await new Promise<any>(resolve => { chrome.storage.local.get(['debugConfig'], (items) => resolve(items)); });\n      if (result.debugConfig) { Object.assign(DEBUG_CONFIG, result.debugConfig as Partial<DebugConfig>); debugLogger.storage('INFO', 'Debug configuration loaded from storage', DEBUG_CONFIG); }\n      else { debugLogger.storage('INFO', 'No stored debug configuration found - using defaults', DEBUG_CONFIG); }\n    } catch (error: any) { debugLogger.storage('ERROR', 'Failed to load debug configuration', null, error); }\n  }\n  async saveConfig() {\n    try { debugLogger.storage('DEBUG', 'Saving debug configuration to storage'); await new Promise(resolve => { chrome.storage.local.set({ debugConfig: DEBUG_CONFIG }, () => resolve(null)); }); debugLogger.storage('INFO', 'Debug configuration saved to storage'); }\n    catch (error: any) { debugLogger.storage('ERROR', 'Failed to save debug configuration', null, error); }\n  }\n  updateConfig(updates: Partial<DebugConfig>) { Object.assign(DEBUG_CONFIG, updates); void this.saveConfig(); debugLogger.general('INFO', 'Debug configuration updated', updates); }\n  toggleCategory(category: LogCategory) { if (Object.prototype.hasOwnProperty.call(DEBUG_CONFIG.categories, category)) { DEBUG_CONFIG.categories[category] = !DEBUG_CONFIG.categories[category]; void this.saveConfig(); debugLogger.general('INFO', `Debug category ${category} toggled`, { category, enabled: DEBUG_CONFIG.categories[category] }); } }\n  setLogLevel(level: LogLevel) { const valid: LogLevel[] = ['DEBUG','INFO','WARN','ERROR']; if (valid.includes(level)) { DEBUG_CONFIG.logLevel = level; void this.saveConfig(); debugLogger.general('INFO', `Debug log level set to ${level}`); } }\n  getConfig(): DebugConfig { return { ...DEBUG_CONFIG }; }\n  resetConfig() { const def: DebugConfig = { enabled: true, categories: { WEBSOCKET: true, NOTIFICATIONS: true, API: true, STORAGE: true, GENERAL: true, PERFORMANCE: true, ERROR: true }, logLevel: 'DEBUG', maxLogEntries: 1000, sanitizeData: true }; Object.assign(DEBUG_CONFIG, def); void this.saveConfig(); debugLogger.general('INFO', 'Debug configuration reset to defaults'); }\n}\n\nexport const debugConfigManager = new DebugConfigManager();\nvoid debugConfigManager.loadConfig();\n\nexport class GlobalErrorTracker {\n  private errors: Array<{ timestamp: string; category: string; message: string; name: string; stack?: string; context: any }>\n    = [];\n  private errorCounts = new Map<string, number>();\n  private criticalErrors: any[] = [];\n\n  trackError(error: Error, context: any = {}, category = 'GENERAL') {\n    const entry = { timestamp: new Date().toISOString(), category, message: error.message, name: error.name, stack: (error as any).stack, context };\n    this.errors.push(entry);\n    const count = (this.errorCounts.get(category) || 0) + 1; this.errorCounts.set(category, count);\n    if (count >= 5) this.criticalErrors.push(entry);\n  }\n  getErrorSummary() { const byCat: Record<string, number> = {}; this.errorCounts.forEach((v, k) => byCat[k] = v); return { total: this.errors.length, byCategory: byCat, critical: this.criticalErrors.length }; }\n  exportErrorData() { return { errors: this.errors.slice(-200), summary: this.getErrorSummary() }; }\n}\n\nexport const globalErrorTracker = new GlobalErrorTracker();\n\n// Attach listeners in SW environment; swallow if not available\ntry { self.addEventListener('error', (event: ErrorEvent) => { globalErrorTracker.trackError((event as any).error || new Error(event.message), { filename: event.filename, lineno: event.lineno, colno: event.colno, type: 'unhandled' }, 'GLOBAL'); }); } catch (_) { /* noop */ }\ntry { self.addEventListener('unhandledrejection', (event: PromiseRejectionEvent) => { globalErrorTracker.trackError((event as any).reason || new Error('Unhandled promise rejection'), { type: 'unhandled_promise' }, 'GLOBAL'); }); } catch (_) { /* noop */ }\n\n", "/* Performance monitoring (TypeScript)\n   Mirrors js/performance.js */\n\nexport class PerformanceMonitor {\n  private metrics = new Map<string, number>();\n  private notificationTimeline: Array<{ ts: number; event: string }>= [];\n  private websocketMetrics = { connectionAttempts: 0, successfulConnections: 0, messagesReceived: 0, messagesProcessed: 0, reconnectionAttempts: 0, lastConnectionTime: null as number | null, totalDowntime: 0 };\n  private notificationMetrics = { pushesReceived: 0, notificationsCreated: 0, notificationsFailed: 0, unknownTypes: 0 };\n  private healthChecks = { success: 0, failure: 0, lastCheck: null as number | null };\n  private quality = { disconnections: 0, permanentErrors: 0, consecutiveFailures: 0 };\n  private timers: Record<string, number> = {};\n\n  record(metric: string, value = 1) { const cur = this.metrics.get(metric) || 0; this.metrics.set(metric, cur + value); }\n  start(name: string) { this.timers[name] = Date.now(); }\n  end(name: string) { if (this.timers[name]) { const d = Date.now() - this.timers[name]; delete this.timers[name]; this.record(`timer:${name}`, d); return d; } return null; }\n  recordWebSocketConnection(success: boolean) { this.websocketMetrics.connectionAttempts++; if (success) { this.websocketMetrics.successfulConnections++; this.websocketMetrics.lastConnectionTime = Date.now(); this.quality.consecutiveFailures = 0; } }\n  recordWebSocketMessage(received = true, processed = false) { if (received) this.websocketMetrics.messagesReceived++; if (processed) this.websocketMetrics.messagesProcessed++; }\n  recordWebSocketReconnection() { this.websocketMetrics.reconnectionAttempts++; this.quality.consecutiveFailures++; }\n  recordHealthCheckSuccess() { this.healthChecks.success++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures = 0; }\n  recordHealthCheckFailure() { this.healthChecks.failure++; this.healthChecks.lastCheck = Date.now(); this.quality.consecutiveFailures++; }\n  recordDisconnection() { this.quality.disconnections++; }\n  recordPermanentError() { this.quality.permanentErrors++; }\n  recordNotification(event: string) { this.notificationTimeline.push({ ts: Date.now(), event }); if (this.notificationTimeline.length > 200) this.notificationTimeline.shift(); }\n  getPerformanceSummary() { return { websocket: this.websocketMetrics, health: this.healthChecks, quality: this.quality, metrics: Object.fromEntries(this.metrics) as Record<string, number> }; }\n  getQualityMetrics() { return this.quality; }\n  exportPerformanceData() { return { summary: this.getPerformanceSummary(), timeline: this.notificationTimeline.slice(-200) }; }\n}\n\nexport const performanceMonitor = new PerformanceMonitor();\n\n", "/* Monitoring (TypeScript)\n   Mirrors js/monitoring.js */\n\nexport class InitializationTracker {\n  private initializations: Array<{ source: string; timestamp: string }> = [];\n  private stats: Record<string, number> = { onInstalled: 0, onStartup: 0, onAlarm: 0, onMessage: 0, manual: 0 };\n\n  recordInitialization(source: string) {\n    this.initializations.push({ source, timestamp: new Date().toISOString() });\n    if (this.stats[source] !== undefined) this.stats[source]++;\n  }\n  exportData() { return { initializations: this.initializations.slice(-100), stats: { ...this.stats } }; }\n}\n\nexport const initTracker = new InitializationTracker();\n\nexport class WebSocketStateMonitor {\n  private stateHistory: Array<{ timestamp: number; state: string | null; duration: number }>= [];\n  private lastStateCheck = Date.now();\n  private monitoringInterval: ReturnType<typeof setInterval> | null = null;\n  private alertThresholds = { slowReceive: 15000 };\n\n  recordStateChange(newState: string) {\n    const now = Date.now();\n    const prev = this.stateHistory[this.stateHistory.length - 1];\n    const duration = prev ? now - prev.timestamp : 0;\n    this.stateHistory.push({ timestamp: now, state: newState, duration });\n    if (this.stateHistory.length > 200) this.stateHistory.shift();\n  }\n  getStateReport() {\n    const currentState = (globalThis as any).websocket && typeof (globalThis as any).websocket.readyState === 'number'\n      ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][(globalThis as any).websocket.readyState] : 'NULL';\n    return { currentState, lastCheck: new Date(this.lastStateCheck).toISOString(), historyLength: this.stateHistory.length };\n  }\n  startMonitoring() {\n    if (this.monitoringInterval) return;\n    this.monitoringInterval = setInterval(() => {\n      this.lastStateCheck = Date.now();\n      const state = (globalThis as any).websocket ? (globalThis as any).websocket.readyState : null;\n      try { (globalThis as any).debugLogger?.websocket('DEBUG', 'WebSocket state check', { state }); } catch (_) { /* noop */ }\n    }, 30000);\n  }\n  stopMonitoring() { if (this.monitoringInterval) { clearInterval(this.monitoringInterval); this.monitoringInterval = null; } }\n}\n\nexport const wsStateMonitor = new WebSocketStateMonitor();\n\n", "import { debugLogger } from '../../lib/logging';\nimport { performanceMonitor } from '../../lib/perf';\n\n// Track last disconnection notification to avoid spam\nlet lastDisconnectionNotification = 0;\nconst DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\n\n/**\n * Helper function to create notification with auto-dismiss\n */\nexport function createNotificationWithTimeout(\n  notificationId: string,\n  options: chrome.notifications.NotificationCreateOptions,\n  callback?: (id?: string) => void,\n  timeoutMs?: number\n): void {\n  // Get ABSOLUTE URL for the icon - service workers need absolute paths!\n  const iconUrl = chrome.runtime.getURL('icons/icon128.png');\n\n  // Create CLEAN options with ONLY the properties we want\n  const safeOptions: chrome.notifications.NotificationCreateOptions = {\n    type: 'basic',\n    iconUrl: iconUrl, // Use absolute URL\n    title: options.title || 'Pushbullet',\n    message: options.message || '',\n    priority: options.priority || 1\n  };\n\n  // Log what we're creating\n  debugLogger.notifications('DEBUG', 'Creating notification with safe options', {\n    notificationId,\n    iconUrl,\n    title: safeOptions.title,\n    messageLength: safeOptions.message?.length || 0\n  });\n\n  chrome.notifications.create(notificationId, safeOptions, (createdId) => {\n    // Check for errors\n    if (chrome.runtime.lastError) {\n      debugLogger.notifications('ERROR', 'Notification creation error', {\n        error: chrome.runtime.lastError.message,\n        notificationId\n      });\n    }\n\n    if (callback) callback(createdId);\n\n    // Auto-dismiss logic\n    try {\n      const timeout = timeoutMs !== undefined ? timeoutMs : 10000; // Default 10 seconds\n      if (typeof timeout === 'number' && timeout > 0) {\n        setTimeout(() => {\n          chrome.notifications.clear(createdId || notificationId, () => {});\n        }, timeout);\n      }\n    } catch (error) {\n      debugLogger.notifications('ERROR', 'Failed to set notification timeout', {\n        error: (error as Error).message\n      }, error as Error);\n    }\n  });\n}\n\n/**\n * Check if we should show a disconnection notification\n */\nexport function checkDisconnectionNotification(): void {\n  const now = Date.now();\n  const timeSinceLastNotification = now - lastDisconnectionNotification;\n\n  // Only notify if cooldown period has passed\n  if (timeSinceLastNotification < DISCONNECTION_NOTIFICATION_COOLDOWN) {\n    debugLogger.general('DEBUG', 'Disconnection notification suppressed - cooldown active', {\n      timeSinceLastNotification: `${Math.round(timeSinceLastNotification / 1000)}s`,\n      cooldownPeriod: `${DISCONNECTION_NOTIFICATION_COOLDOWN / 1000}s`\n    });\n    return;\n  }\n\n  // Check if we've been disconnected for threshold period\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n  if (qualityMetrics.consecutiveFailures >= 3) {\n    showDisconnectionNotification();\n    lastDisconnectionNotification = now;\n  }\n}\n\n/**\n * Show disconnection notification\n */\nexport function showDisconnectionNotification(): void {\n  createNotificationWithTimeout(\n    'pushbullet-disconnected',\n    {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title: 'Pushbullet Connection Issue',\n      message: 'Real-time push notifications may be delayed. Reconnecting...',\n      priority: 1\n    },\n    (notificationId) => {\n      debugLogger.general('INFO', 'Disconnection notification shown', { notificationId });\n    }\n  );\n}\n\n/**\n * Show permanent WebSocket error notification\n */\nexport function showPermanentWebSocketError(closeInfo: { code: number; reason?: string; wasClean?: boolean }): void {\n  const title = 'Pushbullet requires attention';\n  const message = `Real-time connection stopped (code ${closeInfo.code}). ${closeInfo.reason || ''}`.trim();\n\n  createNotificationWithTimeout(\n    'pushbullet-permanent-error',\n    {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title,\n      message,\n      priority: 2\n    },\n    () => {}\n  );\n\n  try {\n    chrome.action.setBadgeBackgroundColor({ color: '#d93025' });\n    chrome.action.setBadgeText({ text: 'ERR' });\n  } catch (_) {\n    // noop\n  }\n}\n\n/**\n * Clear error badge\n */\nexport function clearErrorBadge(): void {\n  try {\n    chrome.action.setBadgeText({ text: '' });\n  } catch (_) {\n    // ignore\n  }\n}\n\n", "import { performanceMonitor } from '../../lib/perf';\nimport { debugLogger } from '../../lib/logging';\nimport { wsStateMonitor } from '../../lib/monitoring';\nimport type { WebSocketMessage, Push } from '../../types/domain';\nimport { WS_READY_STATE } from '../../types/domain';\nimport { clearErrorBadge, showPermanentWebSocketError } from '../notifications';\n\nexport interface CloseInfo {\n  code: number;\n  reason?: string;\n  wasClean?: boolean;\n}\n\nexport interface WebSocketHandlers {\n  onTicklePush?: () => Promise<void>;\n  onTickleDevice?: () => Promise<void>;\n  onPush?: (push: Push) => Promise<void>;\n  onConnected?: () => void;\n  onDisconnected?: () => void;\n  checkPollingMode?: () => void;\n  stopPollingMode?: () => void;\n  updatePopupConnectionState?: (state: string) => void;\n}\n\n/**\n * WebSocket client for Pushbullet streaming API\n */\nexport class WebSocketClient {\n  private socket: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;\n  private handlers: WebSocketHandlers = {};\n\n  constructor(\n    private websocketUrl: string,\n    private getApiKey: () => string | null\n  ) {}\n\n  /**\n   * Set event handlers\n   */\n  setHandlers(handlers: WebSocketHandlers): void {\n    this.handlers = handlers;\n  }\n\n  /**\n   * Get current WebSocket instance\n   */\n  getSocket(): WebSocket | null {\n    return this.socket;\n  }\n\n  /**\n   * Get current ready state\n   */\n  getReadyState(): number | null {\n    return this.socket ? this.socket.readyState : null;\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return this.socket !== null && this.socket.readyState === WS_READY_STATE.OPEN;\n  }\n\n  /**\n   * Connect to WebSocket\n   */\n  connect(): void {\n    try {\n      const apiKey = this.getApiKey();\n      if (!apiKey) {\n        debugLogger.websocket('WARN', 'connectWebSocket called without apiKey');\n        return;\n      }\n\n      // If already open, do nothing\n      if (this.socket && this.socket.readyState === WS_READY_STATE.OPEN) {\n        debugLogger.websocket('DEBUG', 'WebSocket already open');\n        return;\n      }\n\n      const url = this.websocketUrl + apiKey;\n      debugLogger.websocket('INFO', 'Connecting to WebSocket', { url: this.websocketUrl + '***' });\n      this.reconnectAttempts = 0;\n\n      this.socket = new WebSocket(url);\n\n      this.socket.onopen = () => {\n        debugLogger.websocket('INFO', 'WebSocket connection established', { timestamp: new Date().toISOString() });\n        performanceMonitor.recordWebSocketConnection(true);\n        wsStateMonitor.startMonitoring();\n\n        if (this.handlers.stopPollingMode) {\n          this.handlers.stopPollingMode();\n        }\n\n        try {\n          clearErrorBadge();\n        } catch (_) {\n          // noop\n        }\n\n        chrome.alarms.clear('websocketReconnect', () => {});\n\n        if (this.reconnectTimeout) {\n          clearTimeout(this.reconnectTimeout);\n          this.reconnectTimeout = null;\n        }\n\n        if (this.handlers.onConnected) {\n          this.handlers.onConnected();\n        }\n\n        if (this.handlers.updatePopupConnectionState) {\n          this.handlers.updatePopupConnectionState('connected');\n        }\n      };\n\n      this.socket.onmessage = async (event) => {\n        try {\n          const data: WebSocketMessage = JSON.parse(event.data);\n          debugLogger.websocket('DEBUG', 'WebSocket message received', {\n            type: data.type,\n            subtype: 'subtype' in data ? data.subtype : undefined,\n            hasPush: 'push' in data ? !!data.push : false\n          });\n\n          switch (data.type) {\n            case 'tickle':\n              if (data.subtype === 'push' && this.handlers.onTicklePush) {\n                await this.handlers.onTicklePush();\n              } else if (data.subtype === 'device' && this.handlers.onTickleDevice) {\n                await this.handlers.onTickleDevice();\n              }\n              break;\n\n            case 'push':\n              if ('push' in data && data.push && this.handlers.onPush) {\n                await this.handlers.onPush(data.push);\n              } else {\n                debugLogger.websocket('WARN', 'Push message received without push payload');\n              }\n              break;\n\n            case 'nop':\n              debugLogger.websocket('DEBUG', 'Received nop (keep-alive) message', {\n                timestamp: new Date().toISOString()\n              });\n              break;\n\n            default:\n              debugLogger.websocket('WARN', 'Unknown WebSocket message type received', {\n                type: (data as any).type\n              });\n              break;\n          }\n        } catch (error) {\n          debugLogger.websocket('ERROR', 'Failed to process WebSocket message', null, error as Error);\n        }\n      };\n\n      this.socket.onerror = (error) => {\n        debugLogger.websocket('ERROR', 'WebSocket error occurred', {\n          error: (error as any).message || 'Unknown error',\n          readyState: this.socket ? this.socket.readyState : 'null'\n        }, error as any);\n      };\n\n      this.socket.onclose = (event) => {\n        const closeInfo: CloseInfo = {\n          code: event.code,\n          reason: event.reason || 'No reason provided',\n          wasClean: event.wasClean\n        };\n\n        debugLogger.websocket('WARN', 'WebSocket connection closed', {\n          ...closeInfo,\n          timestamp: new Date().toISOString(),\n          reconnectAttempts: this.reconnectAttempts\n        });\n\n        if (this.handlers.onDisconnected) {\n          this.handlers.onDisconnected();\n        }\n\n        if (this.handlers.updatePopupConnectionState) {\n          this.handlers.updatePopupConnectionState('disconnected');\n        }\n\n        // Permanent error: stop and notify\n        if (event.code === 1008 || event.code === 4001 || (event.code >= 4000 && event.code < 5000)) {\n          debugLogger.websocket('ERROR', 'Permanent WebSocket error - stopping reconnection attempts', closeInfo);\n          try {\n            showPermanentWebSocketError(closeInfo);\n          } catch (_) {\n            // noop\n          }\n          return;\n        }\n\n        // Transient: schedule next reconnect in ~30s (one-shot)\n        this.reconnectAttempts++;\n        performanceMonitor.recordWebSocketReconnection();\n\n        if (this.handlers.checkPollingMode) {\n          this.handlers.checkPollingMode();\n        }\n\n        debugLogger.websocket('INFO', 'Scheduling WebSocket reconnection (30s one-shot)', {\n          attempt: this.reconnectAttempts,\n          nextAttemptAt: new Date(Date.now() + 30000).toISOString()\n        });\n\n        chrome.alarms.create('websocketReconnect', { when: Date.now() + 30000 });\n      };\n    } catch (error) {\n      debugLogger.websocket('ERROR', 'Failed to create WebSocket connection', {\n        url: this.websocketUrl + '***',\n        hasApiKey: !!this.getApiKey()\n      }, error as Error);\n    }\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnect(): void {\n    if (this.socket) {\n      try {\n        debugLogger.websocket('INFO', 'Disconnecting WebSocket', {\n          readyState: this.socket.readyState\n        });\n\n        this.socket.close();\n        this.socket = null;\n\n        wsStateMonitor.stopMonitoring();\n      } catch (error) {\n        debugLogger.websocket('ERROR', 'Error disconnecting WebSocket', null, error as Error);\n      }\n    }\n  }\n\n  /**\n   * Get reconnect attempts count\n   */\n  getReconnectAttempts(): number {\n    return this.reconnectAttempts;\n  }\n\n  /**\n   * Reset reconnect attempts\n   */\n  resetReconnectAttempts(): void {\n    this.reconnectAttempts = 0;\n  }\n}\n\n", "import type { User, Device, Push, DevicesResponse, PushesResponse } from \"../../types/domain\";\nimport { debugLogger } from \"../../lib/logging\";\n\nconst API_BASE_URL = 'https://api.pushbullet.com/v2';\nconst PUSHES_URL = `${API_BASE_URL}/pushes`;\nconst DEVICES_URL = `${API_BASE_URL}/devices`;\nconst USER_INFO_URL = `${API_BASE_URL}/users/me`;\n\ntype HeadersInit = Record<string, string>;\n\nfunction authHeaders(apiKey: string): HeadersInit {\n  return { 'Access-Token': apiKey };\n}\n\nexport async function fetchUserInfo(apiKey: string): Promise<User> {\n  const startTime = Date.now();\n  debugLogger.api('INFO', 'Fetching user info', { url: USER_INFO_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(USER_INFO_URL, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to fetch user info: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'User info fetch failed', {\n        url: USER_INFO_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      throw error;\n    }\n\n    const data = await response.json();\n    debugLogger.api('INFO', 'User info fetched successfully', {\n      url: USER_INFO_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      userEmail: data.email ? data.email.substring(0, 3) + '***' : 'unknown',\n      userName: data.name || 'unknown'\n    });\n    return data;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'User info fetch error', {\n      url: USER_INFO_URL,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function fetchDevices(apiKey: string): Promise<Device[]> {\n  const startTime = Date.now();\n  debugLogger.api('INFO', 'Fetching devices', { url: DEVICES_URL, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(DEVICES_URL, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const error = new Error(`Failed to fetch devices: ${response.status} ${response.statusText}`);\n      debugLogger.api('ERROR', 'Devices fetch failed', {\n        url: DEVICES_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`\n      }, error);\n      throw error;\n    }\n\n    const data: DevicesResponse = await response.json();\n    const activeDevices = data.devices.filter(device => device.active);\n    debugLogger.api('INFO', 'Devices fetched successfully', {\n      url: DEVICES_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      totalDevices: data.devices.length,\n      activeDevices: activeDevices.length\n    });\n    return activeDevices;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'Devices fetch error', {\n      url: DEVICES_URL,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function fetchRecentPushes(apiKey: string): Promise<Push[]> {\n  const startTime = Date.now();\n  const url = `${PUSHES_URL}?limit=20`;\n  debugLogger.api('INFO', 'Fetching recent pushes', { url, hasApiKey: !!apiKey, timestamp: new Date().toISOString() });\n\n  try {\n    const response = await fetch(url, { headers: authHeaders(apiKey) });\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const error = new Error(`Failed to fetch pushes: ${response.status} ${response.statusText}`);\n      debugLogger.api('ERROR', 'Pushes fetch failed', {\n        url,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`\n      }, error);\n      throw error;\n    }\n\n    const data: PushesResponse = await response.json();\n    const filteredPushes = data.pushes.filter(push => {\n      const hasContent =\n        ('title' in push && push.title) ||\n        ('body' in push && push.body) ||\n        ('url' in push && push.url);\n      return hasContent && !push.dismissed;\n    });\n    debugLogger.api('INFO', 'Pushes fetched successfully', {\n      url,\n      status: response.status,\n      duration: `${duration}ms`,\n      totalPushes: data.pushes.length,\n      filteredPushes: filteredPushes.length,\n      pushTypes: filteredPushes.map(p => p.type).join(', ')\n    });\n    return filteredPushes;\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    debugLogger.api('ERROR', 'Pushes fetch error', {\n      url,\n      duration: `${duration}ms`,\n      error: (error as Error).message\n    }, error as Error);\n    throw error;\n  }\n}\n\nexport async function registerDevice(\n  apiKey: string,\n  deviceIden: string | null,\n  deviceNickname: string\n): Promise<{ deviceIden: string; needsUpdate: boolean }> {\n  debugLogger.general('INFO', 'Starting device registration process', {\n    hasApiKey: !!apiKey,\n    currentDeviceIden: deviceIden,\n    deviceNickname,\n    timestamp: new Date().toISOString()\n  });\n\n  // Check if registration is already in progress\n  const result = await new Promise<{ deviceRegistrationInProgress?: boolean }>(resolve => {\n    chrome.storage.local.get(['deviceRegistrationInProgress'], (items) => resolve(items as any));\n  });\n\n  if (result.deviceRegistrationInProgress) {\n    debugLogger.general('INFO', 'Device registration already in progress - waiting for completion');\n    return new Promise(resolve => {\n      const listener = (changes: { [key: string]: chrome.storage.StorageChange }) => {\n        if (changes.deviceRegistrationInProgress && !changes.deviceRegistrationInProgress.newValue) {\n          chrome.storage.onChanged.removeListener(listener);\n          debugLogger.general('INFO', 'Device registration completed by another process');\n          resolve({ deviceIden: deviceIden || '', needsUpdate: false });\n        }\n      };\n      chrome.storage.onChanged.addListener(listener);\n    });\n  }\n\n  try {\n    await chrome.storage.local.set({ deviceRegistrationInProgress: true });\n\n    // Check if device is already registered\n    const storageResult = await new Promise<{ deviceIden?: string }>(resolve => {\n      chrome.storage.local.get(['deviceIden'], (items) => resolve(items as any));\n    });\n\n    if (storageResult.deviceIden) {\n      const existingIden = storageResult.deviceIden;\n      debugLogger.general('INFO', 'Device already registered', { deviceIden: existingIden, deviceNickname });\n\n      try {\n        await updateDeviceNickname(apiKey, existingIden, deviceNickname);\n        await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n        return { deviceIden: existingIden, needsUpdate: false };\n      } catch (error) {\n        debugLogger.general('WARN', 'Failed to update existing device, will re-register', {\n          error: (error as Error).message,\n          deviceIden: existingIden\n        });\n        await chrome.storage.local.remove(['deviceIden']);\n      }\n    }\n\n    // Register new device\n    debugLogger.general('INFO', 'Registering new device with Pushbullet API', { deviceNickname, url: DEVICES_URL });\n\n    const registrationData = {\n      nickname: deviceNickname,\n      model: 'Chrome',\n      manufacturer: 'Google',\n      push_token: '',\n      app_version: 8623,\n      icon: 'browser',\n      has_sms: false,\n      type: 'chrome'\n    };\n\n    debugLogger.api('INFO', 'Sending device registration request', {\n      url: DEVICES_URL,\n      method: 'POST',\n      deviceData: registrationData\n    });\n\n    const startTime = Date.now();\n    const response = await fetch(DEVICES_URL, {\n      method: 'POST',\n      headers: {\n        ...authHeaders(apiKey),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(registrationData)\n    });\n\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to register device: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'Device registration failed', {\n        url: DEVICES_URL,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n      throw error;\n    }\n\n    const device: Device = await response.json();\n    const newDeviceIden = device.iden;\n\n    debugLogger.api('INFO', 'Device registered successfully', {\n      url: DEVICES_URL,\n      status: response.status,\n      duration: `${duration}ms`,\n      deviceIden: newDeviceIden,\n      deviceNickname: device.nickname\n    });\n\n    // Save device iden to storage\n    await chrome.storage.local.set({ deviceIden: newDeviceIden } as any);\n    await chrome.storage.local.set({ deviceRegistrationInProgress: false } as any);\n\n    debugLogger.general('INFO', 'Device registration completed', {\n      deviceIden: newDeviceIden,\n      deviceNickname: device.nickname\n    });\n\n    return { deviceIden: newDeviceIden, needsUpdate: false };\n  } catch (error) {\n    await chrome.storage.local.set({ deviceRegistrationInProgress: false });\n    debugLogger.general('ERROR', 'Error in registerDevice function', {\n      errorMessage: (error as Error).message,\n      errorStack: (error as Error).stack\n    });\n    throw error;\n  }\n}\n\nexport async function updateDeviceNickname(\n  apiKey: string,\n  deviceIden: string,\n  newNickname: string\n): Promise<void> {\n  debugLogger.general('INFO', 'Updating device nickname', {\n    deviceIden,\n    newNickname,\n    timestamp: new Date().toISOString()\n  });\n\n  try {\n    const url = `${DEVICES_URL}/${deviceIden}`;\n    const startTime = Date.now();\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        ...authHeaders(apiKey),\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ nickname: newNickname })\n    });\n\n    const duration = Date.now() - startTime;\n\n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      const error = new Error(`Failed to update device nickname: ${response.status} ${response.statusText} - ${errorText}`);\n      debugLogger.api('ERROR', 'Device nickname update failed', {\n        url,\n        status: response.status,\n        statusText: response.statusText,\n        duration: `${duration}ms`,\n        errorText\n      }, error);\n      throw error;\n    }\n\n    const device: Device = await response.json();\n    debugLogger.api('INFO', 'Device nickname updated successfully', {\n      url,\n      status: response.status,\n      duration: `${duration}ms`,\n      deviceIden,\n      newNickname: device.nickname\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Error in updateDeviceNickname function', {\n      errorMessage: (error as Error).message,\n      errorStack: (error as Error).stack\n    });\n    throw error;\n  }\n}\n\n", "import type { SessionCache, InitializationState } from '../../types/domain';\nimport { debugLogger } from '../../lib/logging';\nimport { fetchUserInfo, fetchDevices, fetchRecentPushes, registerDevice } from '../api/client';\n\n// Session cache state\nexport const sessionCache: SessionCache = {\n  userInfo: null,\n  devices: [],\n  recentPushes: [],\n  isAuthenticated: false,\n  lastUpdated: 0,\n  autoOpenLinks: true,\n  deviceNickname: 'Chrome'\n};\n\n// Initialization state tracking\nexport const initializationState: InitializationState = {\n  inProgress: false,\n  completed: false,\n  error: null,\n  timestamp: null\n};\n\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.sync\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\nexport async function initializeSessionCache(\n  source = 'unknown',\n  connectWebSocketFn?: () => void,\n  stateSetters?: {\n    setApiKey: (key: string | null) => void;\n    setDeviceIden: (iden: string | null) => void;\n    setAutoOpenLinks: (value: boolean) => void;\n    setDeviceNickname: (nickname: string) => void;\n    setNotificationTimeout: (timeout: number) => void;\n  }\n): Promise<string | null> {\n  if (initializationState.inProgress) {\n    throw new Error('Initialization already in progress');\n  }\n\n  if (initializationState.completed) {\n    debugLogger.general('WARN', 'Already initialized, skipping', {\n      source,\n      previousTimestamp: initializationState.timestamp\n    });\n    return null;\n  }\n\n  initializationState.inProgress = true;\n\n  try {\n    debugLogger.general('INFO', 'Initializing session cache', {\n      source,\n      timestamp: new Date().toISOString()\n    });\n\n    // Load core settings from sync storage\n    debugLogger.storage('DEBUG', 'Loading initial configuration from sync storage');\n    const result = await new Promise<{\n      apiKey?: string;\n      deviceIden?: string;\n      autoOpenLinks?: boolean;\n      deviceNickname?: string;\n      notificationTimeout?: number;\n    }>(resolve => {\n      chrome.storage.sync.get(\n        ['apiKey', 'deviceIden', 'autoOpenLinks', 'deviceNickname', 'notificationTimeout'],\n        (items) => resolve(items as any)\n      );\n    });\n\n    // Get API key (stored in plain text)\n    const apiKeyValue = result.apiKey || null;\n    const deviceIdenValue = result.deviceIden || null;\n\n    if (stateSetters) {\n      stateSetters.setApiKey(apiKeyValue);\n      stateSetters.setDeviceIden(deviceIdenValue);\n    }\n\n    // Set defaults for missing values\n    let autoOpenLinksValue = true;\n    let notificationTimeoutValue = 10000;\n    let deviceNicknameValue = 'Chrome';\n\n    if (result.autoOpenLinks === undefined) {\n      await chrome.storage.sync.set({ autoOpenLinks: true });\n    } else {\n      autoOpenLinksValue = result.autoOpenLinks;\n    }\n\n    if (result.notificationTimeout === undefined) {\n      await chrome.storage.sync.set({ notificationTimeout: 10000 });\n    } else {\n      notificationTimeoutValue = result.notificationTimeout;\n    }\n\n    if (result.deviceNickname === undefined || result.deviceNickname === null) {\n      await chrome.storage.sync.set({ deviceNickname: 'Chrome' });\n    } else {\n      deviceNicknameValue = result.deviceNickname;\n    }\n\n    if (stateSetters) {\n      stateSetters.setAutoOpenLinks(autoOpenLinksValue);\n      stateSetters.setNotificationTimeout(notificationTimeoutValue);\n      stateSetters.setDeviceNickname(deviceNicknameValue);\n    }\n\n    sessionCache.autoOpenLinks = autoOpenLinksValue;\n    sessionCache.deviceNickname = deviceNicknameValue;\n\n    debugLogger.storage('INFO', 'Loaded configuration from sync storage', {\n      hasApiKey: !!result.apiKey,\n      hasDeviceIden: !!result.deviceIden,\n      autoOpenLinks: autoOpenLinksValue,\n      deviceNickname: deviceNicknameValue,\n      notificationTimeout: notificationTimeoutValue\n    });\n\n    debugLogger.general('DEBUG', 'API key status', {\n      hasApiKey: !!apiKeyValue,\n      apiKeyLength: apiKeyValue ? apiKeyValue.length : 0\n    });\n\n    if (apiKeyValue) {\n      debugLogger.general('INFO', 'API key available - initializing session data');\n\n      // Fetch user info\n      const userInfo = await fetchUserInfo(apiKeyValue);\n      sessionCache.userInfo = userInfo;\n\n      // Fetch devices\n      const devices = await fetchDevices(apiKeyValue);\n      sessionCache.devices = devices;\n\n      // Fetch recent pushes\n      const pushes = await fetchRecentPushes(apiKeyValue);\n      sessionCache.recentPushes = pushes;\n\n      // Update session cache\n      sessionCache.isAuthenticated = true;\n      sessionCache.lastUpdated = Date.now();\n\n      debugLogger.general('INFO', 'Session cache populated successfully', {\n        hasUserInfo: !!sessionCache.userInfo,\n        deviceCount: sessionCache.devices.length,\n        pushCount: sessionCache.recentPushes.length,\n        lastUpdated: new Date(sessionCache.lastUpdated).toISOString()\n      });\n\n      // Register device\n      await registerDevice(apiKeyValue, deviceIdenValue, deviceNicknameValue);\n\n      // Connect WebSocket if function provided\n      if (connectWebSocketFn) {\n        connectWebSocketFn();\n      }\n\n      // Start periodic health check\n      chrome.alarms.create('websocketHealthCheck', { periodInMinutes: 5 });\n      debugLogger.general('DEBUG', 'WebSocket health check alarm created', { interval: '5 minutes' });\n    } else {\n      debugLogger.general('WARN', 'No API key available - session cache not initialized');\n    }\n\n    initializationState.completed = true;\n    initializationState.timestamp = Date.now();\n    debugLogger.general('INFO', 'Initialization completed successfully', {\n      source,\n      timestamp: new Date(initializationState.timestamp).toISOString()\n    });\n\n    return apiKeyValue;\n  } catch (error) {\n    initializationState.error = error as Error;\n    debugLogger.general('ERROR', 'Error initializing session cache', {\n      error: (error as Error).message || (error as Error).name || 'Unknown error'\n    }, error as Error);\n    sessionCache.isAuthenticated = false;\n    throw error;\n  } finally {\n    initializationState.inProgress = false;\n  }\n}\n\nexport async function refreshSessionCache(apiKeyParam: string): Promise<void> {\n  debugLogger.general('INFO', 'Refreshing session cache', { \n    hasApiKey: !!apiKeyParam, \n    timestamp: new Date().toISOString() \n  });\n\n  try {\n    if (apiKeyParam) {\n      debugLogger.general('DEBUG', 'API key available - refreshing session data');\n\n      // Fetch user info\n      debugLogger.general('DEBUG', 'Refreshing user info');\n      const userInfo = await fetchUserInfo(apiKeyParam);\n      sessionCache.userInfo = userInfo;\n\n      // Fetch devices\n      debugLogger.general('DEBUG', 'Refreshing devices');\n      const devices = await fetchDevices(apiKeyParam);\n      sessionCache.devices = devices;\n\n      // Fetch recent pushes\n      debugLogger.general('DEBUG', 'Refreshing recent pushes');\n      const pushes = await fetchRecentPushes(apiKeyParam);\n      sessionCache.recentPushes = pushes;\n\n      // Update session cache\n      sessionCache.isAuthenticated = true;\n      sessionCache.lastUpdated = Date.now();\n\n      debugLogger.general('INFO', 'Session cache refreshed successfully', { \n        hasUserInfo: !!sessionCache.userInfo, \n        deviceCount: sessionCache.devices.length, \n        pushCount: sessionCache.recentPushes.length, \n        lastUpdated: new Date(sessionCache.lastUpdated).toISOString() \n      });\n    } else {\n      debugLogger.general('WARN', 'No API key available - cannot refresh session cache');\n      sessionCache.isAuthenticated = false;\n    }\n  } catch (error) {\n    debugLogger.general('ERROR', 'Error refreshing session cache', { \n      error: (error as Error).message \n    }, error as Error);\n    throw error;\n  }\n}\n\n", "import { debugLogger } from '../../lib/logging';\n\n// NO DECRYPTION - API key is stored in plain text in chrome.storage.sync\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n/**\n * Ensure critical configuration is loaded from storage\n * Used for service worker wake-ups to rehydrate state\n *\n * @param stateSetters - Object containing state setter functions\n * @param stateGetters - Object containing state getter functions\n */\nexport function ensureConfigLoaded(\n  stateSetters?: {\n    setApiKey: (key: string | null) => void;\n    setDeviceIden: (iden: string | null) => void;\n    setAutoOpenLinks: (value: boolean) => void;\n    setDeviceNickname: (nickname: string) => void;\n    setNotificationTimeout: (timeout: number) => void;\n  },\n  stateGetters?: {\n    getApiKey: () => string | null;\n    getDeviceIden: () => string | null;\n    getAutoOpenLinks: () => boolean;\n    getDeviceNickname: () => string;\n    getNotificationTimeout: () => number;\n  }\n): Promise<void> {\n  return new Promise((resolve) => {\n    try {\n      if (!stateSetters || !stateGetters) {\n        // No state management provided, just resolve\n        resolve();\n        return;\n      }\n\n      const needsApiKey = !stateGetters.getApiKey();\n      const needsNickname = stateGetters.getDeviceNickname() === null || stateGetters.getDeviceNickname() === undefined;\n      const needsAutoOpen = stateGetters.getAutoOpenLinks() === null || stateGetters.getAutoOpenLinks() === undefined;\n      const needsTimeout = stateGetters.getNotificationTimeout() === null || stateGetters.getNotificationTimeout() === undefined;\n      const needsSync = needsApiKey || needsNickname || needsAutoOpen || needsTimeout;\n\n      const finish = () => {\n        try {\n          debugLogger.storage('DEBUG', 'ensureConfigLoaded completed', {\n            hasApiKey: !!stateGetters.getApiKey(),\n            hasDeviceIden: !!stateGetters.getDeviceIden(),\n            autoOpenLinks: stateGetters.getAutoOpenLinks(),\n            notificationTimeout: stateGetters.getNotificationTimeout(),\n            deviceNickname: stateGetters.getDeviceNickname()\n          });\n        } catch (err) {\n          // Swallow logging/storage errors in ensureConfigLoaded\n        }\n        resolve();\n      };\n\n      const loadLocal = () => {\n        chrome.storage.local.get(['deviceIden'], (lres) => {\n          try {\n            if (!stateGetters.getDeviceIden() && lres && lres.deviceIden) {\n              stateSetters.setDeviceIden(lres.deviceIden);\n            }\n          } catch (err) {\n            // Swallow logging/storage errors in ensureConfigLoaded\n          }\n          finish();\n        });\n      };\n\n      if (needsSync) {\n        chrome.storage.sync.get(\n          ['apiKey', 'deviceNickname', 'autoOpenLinks', 'notificationTimeout'],\n          (res) => {\n            try {\n              if (!stateGetters.getApiKey() && res && res.apiKey) {\n                // API key is stored in plain text\n                stateSetters.setApiKey(res.apiKey);\n              }\n              if (needsNickname && res && res.deviceNickname !== undefined) {\n                stateSetters.setDeviceNickname(res.deviceNickname);\n              }\n              if (needsAutoOpen && res && res.autoOpenLinks !== undefined) {\n                stateSetters.setAutoOpenLinks(res.autoOpenLinks);\n              }\n              if (needsTimeout && res && res.notificationTimeout !== undefined) {\n                stateSetters.setNotificationTimeout(res.notificationTimeout);\n              }\n            } catch (err) {\n              // Swallow logging/storage errors in ensureConfigLoaded\n            }\n            loadLocal();\n          }\n        );\n      } else {\n        loadLocal();\n      }\n    } catch (e) {\n      try {\n        debugLogger.storage('WARN', 'ensureConfigLoaded encountered an error', {\n          error: e && (e as Error).message\n        });\n      } catch (err) {\n        // Ignore\n      }\n      resolve();\n    }\n  });\n}\n\n", "/**\n * Pushbullet End-to-End Encryption (E2EE) Decryption\n * \n * Based on Pushbullet's E2EE specification:\n * - Key derivation: PBKDF2 with HMAC-SHA256\n * - Encryption: AES-256-GCM\n * - Encoding: Base64\n */\n\nimport type { Push } from '../../types/domain';\n\nexport class PushbulletCrypto {\n  /**\n   * Generate encryption/decryption key from password\n   * @param password - User's encryption password\n   * @param userIden - User's iden (used as salt)\n   * @returns Derived key for AES-GCM\n   */\n  static async deriveKey(password: string, userIden: string): Promise<CryptoKey> {\n    // Check if Web Crypto API is available\n    if (!globalThis.crypto || !crypto.subtle) {\n      throw new Error('Web Crypto API unavailable - requires HTTPS or localhost');\n    }\n\n    // Convert password to bytes\n    const encoder = new TextEncoder();\n    const passwordBytes = encoder.encode(password);\n    \n    // Import password as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      passwordBytes,\n      { name: 'PBKDF2' },\n      false,\n      ['deriveBits', 'deriveKey']\n    );\n    \n    // Use user iden as salt\n    const salt = encoder.encode(userIden);\n    \n    // Derive key using PBKDF2\n    const key = await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: salt,\n        iterations: 30000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      { name: 'AES-GCM', length: 256 },\n      false,\n      ['decrypt']\n    );\n    \n    return key;\n  }\n  \n  /**\n   * Decrypt an encrypted message\n   * @param encodedMessage - Base64 encoded encrypted message\n   * @param key - Decryption key\n   * @returns Decrypted message object\n   */\n  static async decryptMessage(encodedMessage: string, key: CryptoKey): Promise<unknown> {\n    try {\n      // Decode from base64\n      const encryptedData = this.base64ToBytes(encodedMessage);\n      \n      // Parse the encoded message format:\n      // version (1 byte) + tag (16 bytes) + iv (12 bytes) + ciphertext (rest)\n      const version = encryptedData[0];\n      \n      if (version !== 49) { // ASCII '1'\n        throw new Error(`Unsupported encryption version: ${version}`);\n      }\n      \n      const tag = encryptedData.slice(1, 17);        // 16 bytes\n      const iv = encryptedData.slice(17, 29);        // 12 bytes (96 bits)\n      const ciphertext = encryptedData.slice(29);    // Rest\n      \n      // Combine ciphertext and tag for AES-GCM\n      const combined = new Uint8Array(ciphertext.length + tag.length);\n      combined.set(ciphertext);\n      combined.set(tag, ciphertext.length);\n      \n      // Decrypt using AES-GCM\n      const decrypted = await crypto.subtle.decrypt(\n        {\n          name: 'AES-GCM',\n          iv: iv,\n          tagLength: 128 // 16 bytes = 128 bits\n        },\n        key,\n        combined\n      );\n      \n      // Convert decrypted bytes to string\n      const decoder = new TextDecoder();\n      const decryptedText = decoder.decode(decrypted);\n      \n      // Parse as JSON\n      return JSON.parse(decryptedText);\n    } catch (error) {\n      // SECURITY FIX (M-04): Don't log sensitive crypto data\n      console.error('Decryption error - check encryption password');\n      throw new Error('Failed to decrypt message. Check your encryption password.');\n    }\n  }\n  \n  /**\n   * Convert base64 string to Uint8Array\n   * @param base64 - Base64 encoded string\n   * @returns Decoded bytes\n   */\n  static base64ToBytes(base64: string): Uint8Array {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n  \n  /**\n   * Decrypt a Pushbullet encrypted push\n   * @param encryptedPush - Push object with 'encrypted' and 'ciphertext' fields\n   * @param password - User's encryption password\n   * @param userIden - User's iden\n   * @returns Decrypted push data\n   */\n  static async decryptPush(encryptedPush: Push, password: string, userIden: string): Promise<Push> {\n    if (!encryptedPush.encrypted || !encryptedPush.ciphertext) {\n      throw new Error('Push is not encrypted');\n    }\n    \n    // Derive key from password\n    const key = await this.deriveKey(password, userIden);\n    \n    // Decrypt the ciphertext\n    const decryptedData = await this.decryptMessage(encryptedPush.ciphertext, key);\n    \n    // Return decrypted push with original metadata\n    return {\n      ...encryptedPush,\n      ...(decryptedData as object),\n      encrypted: false // Mark as decrypted\n    } as Push;\n  }\n}\n\n", "/**\n * Global state management for background service worker\n */\n\nimport type { InitializationState } from '../types/domain';\nimport { WebSocketClient } from '../app/ws/client';\n\n// API constants\nexport const API_BASE_URL = 'https://api.pushbullet.com/v2';\nexport const PUSHES_URL = `${API_BASE_URL}/pushes`;\nexport const DEVICES_URL = `${API_BASE_URL}/devices`;\nexport const USER_INFO_URL = `${API_BASE_URL}/users/me`;\nexport const WEBSOCKET_URL = 'wss://stream.pushbullet.com/websocket/';\n\n// Global state variables\nlet apiKey: string | null = null;\nlet deviceIden: string | null = null;\nlet deviceNickname = 'Chrome';\nlet autoOpenLinks = true;\nlet notificationTimeout = 10000;\nlet websocketClient: WebSocketClient | null = null;\nlet pollingMode = false;\nlet lastDisconnectionNotification = 0;\n\n// Constants\nexport const DISCONNECTION_NOTIFICATION_COOLDOWN = 300000; // 5 minutes\nexport const DISCONNECTION_NOTIFICATION_THRESHOLD = 300000; // 5 minutes\n\n// Initialization state\nexport const initializationState: InitializationState = {\n  inProgress: false,\n  completed: false,\n  error: null,\n  timestamp: null\n};\n\n// NO ENCRYPTION/DECRYPTION - API key is stored in plain text\n// The crypto module is ONLY for decrypting E2EE push messages, NOT the API key!\n\n// Getters and setters\nexport function getApiKey(): string | null {\n  return apiKey;\n}\n\nexport function setApiKey(key: string | null): void {\n  apiKey = key;\n}\n\nexport function getDeviceIden(): string | null {\n  return deviceIden;\n}\n\nexport function setDeviceIden(iden: string | null): void {\n  deviceIden = iden;\n}\n\nexport function getDeviceNickname(): string {\n  return deviceNickname;\n}\n\nexport function setDeviceNickname(nickname: string): void {\n  deviceNickname = nickname;\n}\n\nexport function getAutoOpenLinks(): boolean {\n  return autoOpenLinks;\n}\n\nexport function setAutoOpenLinks(value: boolean): void {\n  autoOpenLinks = value;\n}\n\nexport function getNotificationTimeout(): number {\n  return notificationTimeout;\n}\n\nexport function setNotificationTimeout(timeout: number): void {\n  notificationTimeout = timeout;\n}\n\nexport function getWebSocketClient(): WebSocketClient | null {\n  return websocketClient;\n}\n\nexport function setWebSocketClient(client: WebSocketClient | null): void {\n  websocketClient = client;\n}\n\nexport function isPollingMode(): boolean {\n  return pollingMode;\n}\n\nexport function setPollingMode(mode: boolean): void {\n  pollingMode = mode;\n}\n\nexport function getLastDisconnectionNotification(): number {\n  return lastDisconnectionNotification;\n}\n\nexport function setLastDisconnectionNotification(timestamp: number): void {\n  lastDisconnectionNotification = timestamp;\n}\n\n", "/**\n * Utility functions for background service worker\n */\n\nimport { debugLogger } from '../lib/logging';\nimport { performanceMonitor } from '../lib/perf';\nimport { sessionCache } from '../app/session';\nimport { fetchRecentPushes, fetchDevices } from '../app/api/client';\nimport { getApiKey, setPollingMode, isPollingMode } from './state';\nimport type { Push } from '../types/domain';\nimport { createNotificationWithTimeout } from '../app/notifications';\n\n// Counter to ensure unique notification IDs\nlet notificationCounter = 0;\n\n/**\n * Connection status for icon updates\n */\nexport type ConnectionStatus = 'connected' | 'connecting' | 'disconnected';\n\n/**\n * Sanitize text to prevent XSS attacks\n * Removes HTML tags and dangerous characters\n */\nfunction sanitizeText(text: string): string {\n  if (!text) return '';\n\n  // Remove HTML tags\n  let sanitized = text.replace(/<[^>]*>/g, '');\n\n  // Remove script-like content\n  sanitized = sanitized.replace(/javascript:/gi, '');\n  sanitized = sanitized.replace(/on\\w+\\s*=/gi, '');\n\n  // Trim and limit length\n  sanitized = sanitized.trim().substring(0, 1000);\n\n  return sanitized;\n}\n\n/**\n * Sanitize URL to ensure it's safe\n */\nfunction sanitizeUrl(url: string): string {\n  if (!url) return '';\n\n  try {\n    const parsed = new URL(url);\n    // Only allow http and https protocols\n    if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {\n      return '';\n    }\n    return parsed.href;\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Update extension icon based on connection status\n * Uses badge color instead of different icon files since service workers have issues loading icons\n */\nexport function updateConnectionIcon(status: ConnectionStatus): void {\n  try {\n    // Set badge text\n    const badgeText = status === 'connected' ? '\u25CF' :\n                      status === 'connecting' ? '\u25D0' :\n                      '\u25CB';\n\n    // Set badge color\n    const badgeColor = status === 'connected' ? '#4CAF50' :  // Green\n                       status === 'connecting' ? '#FFC107' :  // Yellow\n                       '#F44336';  // Red\n\n    chrome.action.setBadgeText({ text: badgeText });\n    chrome.action.setBadgeBackgroundColor({ color: badgeColor });\n\n    debugLogger.general('DEBUG', 'Updated connection status badge', { status, badgeText, badgeColor });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Exception setting badge', {\n      status,\n      error: (error as Error).message\n    }, error as Error);\n  }\n}\n\n/**\n * Refresh pushes from API and show notifications for new ones\n */\nexport async function refreshPushes(notificationDataStore?: Map<string, Push>): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot refresh pushes - no API key');\n    return;\n  }\n\n  try {\n    debugLogger.general('DEBUG', 'Refreshing pushes from API');\n\n    // Get current push idens to detect new ones\n    const oldPushIdens = new Set(sessionCache.recentPushes.map(p => p.iden));\n\n    const pushes = await fetchRecentPushes(apiKey);\n\n    // Find NEW pushes (not in old cache)\n    const newPushes = pushes.filter(p => !oldPushIdens.has(p.iden));\n\n    debugLogger.general('INFO', 'Pushes refreshed successfully', {\n      totalPushes: pushes.length,\n      newPushes: newPushes.length\n    });\n\n    // Update cache\n    sessionCache.recentPushes = pushes;\n    sessionCache.lastUpdated = Date.now();\n\n    // Show notifications for NEW pushes\n    for (const push of newPushes) {\n      debugLogger.general('INFO', 'Showing notification for new push from tickle', {\n        pushIden: push.iden,\n        pushType: push.type\n      });\n      // Don't await - fire and forget\n      showPushNotification(push, notificationDataStore).catch((error) => {\n        debugLogger.general('ERROR', 'Failed to show notification', { pushIden: push.iden }, error);\n      });\n    }\n\n    // Notify popup\n    chrome.runtime.sendMessage({\n      action: 'pushesUpdated',\n      pushes: pushes\n    }).catch(() => {\n      // Popup may not be open\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to refresh pushes', null, error as Error);\n  }\n}\n\n/**\n * Show push notification\n */\nexport async function showPushNotification(push: Push, notificationDataStore?: Map<string, Push>): Promise<void> {\n  try {\n    // Log the full push object for debugging\n    debugLogger.notifications('INFO', 'Showing push notification', {\n      pushType: push.type,\n      hasTitle: !!('title' in push && push.title),\n      pushKeys: Object.keys(push),\n      pushJson: JSON.stringify(push)\n    });\n\n    let title = 'Pushbullet';\n    let message = '';\n    const iconUrl = 'icons/icon128.png'; // Always use local icon\n\n    // Handle different push types\n    const pushType = push.type;\n\n    if (pushType === 'note') {\n      title = push.title || 'Note';\n      message = push.body || '';\n    } else if (pushType === 'link') {\n      title = push.title || 'Link';\n      message = push.url || '';\n    } else if (pushType === 'file') {\n      title = push.file_name || 'File';\n      message = push.body || push.file_url || '';\n    } else if (pushType === 'mirror') {\n      title = push.title || push.application_name || 'Notification';\n      message = push.body || '';\n    } else if (pushType === 'sms_changed') {\n      // SMS notification from phone\n      const smsData = push as any;\n      if (smsData.notifications && smsData.notifications.length > 0) {\n        const sms = smsData.notifications[0];\n        title = sms.title || 'SMS';\n        message = sms.body || '';\n      } else {\n        title = 'SMS';\n        message = 'New SMS received';\n      }\n    } else if (pushType === 'dismissal') {\n      // Don't show notifications for dismissals\n      debugLogger.notifications('DEBUG', 'Skipping dismissal push notification');\n      return;\n    } else {\n      // Unknown type - show raw data\n      title = 'Push';\n      message = JSON.stringify(push).substring(0, 200);\n      debugLogger.notifications('WARN', 'Unknown push type', { pushType, push });\n    }\n\n    // Create notification with GUARANTEED unique ID\n    // Use counter + timestamp to ensure no ID collisions even for rapid notifications\n    const notificationId = `pushbullet-push-${++notificationCounter}-${Date.now()}`;\n\n    // Store push data for detail view (SECURITY FIX M-06: uses size-limited store)\n    if (notificationDataStore) {\n      // Import addToNotificationStore from background/index.ts would create circular dependency\n      // So we just use the Map directly here - the size limit is enforced in background/index.ts\n      notificationDataStore.set(notificationId, push);\n    }\n\n    createNotificationWithTimeout(\n      notificationId,\n      {\n        type: 'basic',\n        iconUrl, // Always use local icon, never external URLs\n        title: title.substring(0, 100), // Limit title length\n        message: message.substring(0, 200), // Limit message length\n        priority: 1\n      },\n      (createdId) => {\n        debugLogger.notifications('INFO', 'Push notification created', {\n          notificationId: createdId,\n          pushType: push.type\n        });\n        performanceMonitor.recordNotification('push_notification_created');\n      }\n    );\n  } catch (error) {\n    debugLogger.notifications('ERROR', 'Failed to show push notification', {\n      error: (error as Error).message,\n      pushType: push.type\n    }, error as Error);\n  }\n}\n\n/**\n * Check if we should enter polling mode\n */\nexport function checkPollingMode(): void {\n  const qualityMetrics = performanceMonitor.getQualityMetrics();\n  \n  if (qualityMetrics.consecutiveFailures >= 3 && !isPollingMode()) {\n    debugLogger.general('WARN', 'Entering polling mode due to consecutive failures', {\n      consecutiveFailures: qualityMetrics.consecutiveFailures\n    });\n    \n    setPollingMode(true);\n    \n    // Start polling alarm\n    chrome.alarms.create('pollingFallback', { periodInMinutes: 1 });\n    \n    debugLogger.general('INFO', 'Polling mode activated', { interval: '1 minute' });\n  }\n}\n\n/**\n * Stop polling mode\n */\nexport function stopPollingMode(): void {\n  if (isPollingMode()) {\n    debugLogger.general('INFO', 'Stopping polling mode - WebSocket reconnected');\n    setPollingMode(false);\n    chrome.alarms.clear('pollingFallback');\n  }\n}\n\n/**\n * Perform polling fetch\n */\nexport async function performPollingFetch(): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot perform polling fetch - no API key');\n    return;\n  }\n\n  debugLogger.general('DEBUG', 'Performing polling fetch', { \n    timestamp: new Date().toISOString() \n  });\n\n  try {\n    // Fetch recent pushes\n    const pushes = await fetchRecentPushes(apiKey);\n\n    // Check for new pushes\n    const latestPush = pushes[0];\n    if (latestPush && sessionCache.recentPushes[0]?.iden !== latestPush.iden) {\n      debugLogger.general('INFO', 'New push detected via polling', {\n        pushId: latestPush.iden,\n        pushType: latestPush.type\n      });\n\n      // Update session cache\n      sessionCache.recentPushes = pushes;\n\n      // Notify popup\n      chrome.runtime.sendMessage({\n        action: 'pushesUpdated',\n        pushes: pushes\n      }).catch(() => {});\n    }\n  } catch (error) {\n    debugLogger.general('ERROR', 'Polling fetch failed', null, error as Error);\n  }\n}\n\n/**\n * Perform WebSocket health check\n */\nexport function performWebSocketHealthCheck(wsClient: any, connectFn: () => void): void {\n  const apiKey = getApiKey();\n  \n  // If we have an API key but WebSocket is not connected, reconnect\n  if (apiKey && (!wsClient || !wsClient.isConnected())) {\n    debugLogger.websocket('WARN', 'Health check failed - WebSocket not connected', {\n      hasWebSocket: !!wsClient,\n      isConnected: wsClient ? wsClient.isConnected() : false\n    });\n\n    performanceMonitor.recordHealthCheckFailure();\n    connectFn();\n  } else if (wsClient && wsClient.isConnected()) {\n    debugLogger.websocket('DEBUG', 'Health check passed - WebSocket connected');\n    performanceMonitor.recordHealthCheckSuccess();\n  } else {\n    debugLogger.websocket('DEBUG', 'Health check skipped - no API key');\n  }\n}\n\n/**\n * Update popup connection state\n */\nexport function updatePopupConnectionState(state: string): void {\n  chrome.runtime.sendMessage({\n    action: 'connectionStateChanged',\n    state: state\n  }).catch(() => {\n    // Popup may not be open\n  });\n}\n\n/**\n * Setup context menu\n */\nexport function setupContextMenu(): void {\n  try {\n    chrome.contextMenus.removeAll(() => {\n      chrome.contextMenus.create({\n        id: 'push-link',\n        title: 'Push this link',\n        contexts: ['link']\n      });\n\n      chrome.contextMenus.create({\n        id: 'push-page',\n        title: 'Push this page',\n        contexts: ['page']\n      });\n\n      chrome.contextMenus.create({\n        id: 'push-selection',\n        title: 'Push selected text',\n        contexts: ['selection']\n      });\n\n      chrome.contextMenus.create({\n        id: 'push-image',\n        title: 'Push this image',\n        contexts: ['image']\n      });\n\n      debugLogger.general('INFO', 'Context menu created');\n    });\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to create context menu', null, error as Error);\n  }\n}\n\n/**\n * Push a link\n */\nexport async function pushLink(url: string, title?: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot push link - no API key');\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedUrl = sanitizeUrl(url);\n  const sanitizedTitle = sanitizeText(title || 'Link');\n\n  if (!sanitizedUrl) {\n    debugLogger.general('ERROR', 'Invalid URL provided', { url });\n    return;\n  }\n\n  try {\n    const response = await fetch('https://api.pushbullet.com/v2/pushes', {\n      method: 'POST',\n      headers: {\n        'Access-Token': apiKey,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        type: 'link',\n        title: sanitizedTitle,\n        url: sanitizedUrl\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push link: ${response.status}`);\n    }\n\n    debugLogger.general('INFO', 'Link pushed successfully', { url, title });\n    \n    createNotificationWithTimeout(\n      'pushbullet-link-sent',\n      {\n        type: 'basic',\n        iconUrl: 'icons/icon128.png',\n        title: 'Link Sent',\n        message: title || url\n      }\n    );\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to push link', { url, title }, error as Error);\n  }\n}\n\n/**\n * Push a note\n */\nexport async function pushNote(title: string, body: string): Promise<void> {\n  const apiKey = getApiKey();\n  if (!apiKey) {\n    debugLogger.general('WARN', 'Cannot push note - no API key');\n    return;\n  }\n\n  // Sanitize inputs to prevent XSS\n  const sanitizedTitle = sanitizeText(title);\n  const sanitizedBody = sanitizeText(body);\n\n  try {\n    const response = await fetch('https://api.pushbullet.com/v2/pushes', {\n      method: 'POST',\n      headers: {\n        'Access-Token': apiKey,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        type: 'note',\n        title: sanitizedTitle,\n        body: sanitizedBody\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to push note: ${response.status}`);\n    }\n\n    debugLogger.general('INFO', 'Note pushed successfully', { title });\n    \n    createNotificationWithTimeout(\n      'pushbullet-note-sent',\n      {\n        type: 'basic',\n        iconUrl: 'icons/icon128.png',\n        title: 'Note Sent',\n        message: title\n      }\n    );\n  } catch (error) {\n    debugLogger.general('ERROR', 'Failed to push note', { title }, error as Error);\n  }\n}\n\n", "/**\n * Message sender validation for security\n * Prevents external extensions/pages from sending privileged messages\n */\n\nimport { debugLogger } from '../logging';\n\n/**\n * Validate that message sender is from this extension\n */\nexport function isValidSender(sender: chrome.runtime.MessageSender): boolean {\n  // Must have a valid sender object\n  if (!sender) {\n    debugLogger.general('WARN', 'Message received with no sender');\n    return false;\n  }\n\n  // Must be from this extension\n  if (sender.id !== chrome.runtime.id) {\n    debugLogger.general('WARN', 'Message received from external extension', {\n      senderId: sender.id,\n      expectedId: chrome.runtime.id\n    });\n    return false;\n  }\n\n  // Must be from an extension page (not a content script)\n  if (sender.url) {\n    const extensionUrl = chrome.runtime.getURL('');\n    if (!sender.url.startsWith(extensionUrl)) {\n      debugLogger.general('WARN', 'Message received from non-extension URL', {\n        senderUrl: sender.url,\n        expectedPrefix: extensionUrl\n      });\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * List of privileged actions that require sender validation\n */\nconst PRIVILEGED_ACTIONS = new Set([\n  'apiKeyChanged',\n  'logout',\n  'settingsChanged',\n  'deviceNicknameChanged',\n  'autoOpenLinksChanged',\n  'encryptionPasswordChanged',\n  'debugModeChanged',\n  'pushNote',\n  'pushLink',\n  'pushFile'\n]);\n\n/**\n * Check if an action requires privileged access\n */\nexport function isPrivilegedAction(action: string): boolean {\n  return PRIVILEGED_ACTIONS.has(action);\n}\n\n/**\n * Validate sender for privileged actions\n * Returns true if valid, false if should be rejected\n */\nexport function validatePrivilegedMessage(\n  action: string,\n  sender: chrome.runtime.MessageSender\n): boolean {\n  if (!isPrivilegedAction(action)) {\n    // Non-privileged actions don't need validation\n    return true;\n  }\n\n  if (!isValidSender(sender)) {\n    debugLogger.general('ERROR', 'Rejected privileged action from invalid sender', {\n      action,\n      senderId: sender?.id,\n      senderUrl: sender?.url\n    });\n    return false;\n  }\n\n  return true;\n}\n\n", "/**\n * Background Service Worker - Main Entry Point\n * Pushbullet Chrome Extension (Manifest V3)\n */\n\nimport { debugLogger, debugConfigManager } from '../lib/logging';\nimport { performanceMonitor } from '../lib/perf';\nimport { initTracker, wsStateMonitor } from '../lib/monitoring';\nimport { WebSocketClient } from '../app/ws/client';\nimport { sessionCache, initializeSessionCache, refreshSessionCache, initializationState } from '../app/session';\nimport { fetchDevices, updateDeviceNickname } from '../app/api/client';\nimport { ensureConfigLoaded } from '../app/reconnect';\nimport { PushbulletCrypto } from '../lib/crypto';\nimport {\n  getApiKey,\n  setApiKey,\n  getDeviceIden,\n  setDeviceIden,\n  getDeviceNickname,\n  setDeviceNickname,\n  getAutoOpenLinks,\n  setAutoOpenLinks,\n  getNotificationTimeout,\n  setNotificationTimeout,\n  setWebSocketClient,\n  WEBSOCKET_URL\n} from './state';\nimport {\n  refreshPushes,\n  showPushNotification,\n  checkPollingMode,\n  stopPollingMode,\n  performPollingFetch,\n  performWebSocketHealthCheck,\n  updatePopupConnectionState,\n  setupContextMenu,\n  pushLink,\n  pushNote,\n  updateConnectionIcon\n} from './utils';\nimport { validatePrivilegedMessage } from '../lib/security/message-validation';\nimport type { Push } from '../types/domain';\n\n// Load debug configuration\ndebugConfigManager.loadConfig();\n\n// Store notification data for detail view\n// SECURITY FIX (M-06): Limit store size to prevent memory leak\nconst notificationDataStore = new Map<string, Push>();\nconst MAX_NOTIFICATION_STORE_SIZE = 100;\n\n/**\n * Add notification to store with size limit\n */\nexport function addToNotificationStore(id: string, push: Push): void {\n  // Remove oldest entries if at capacity\n  if (notificationDataStore.size >= MAX_NOTIFICATION_STORE_SIZE) {\n    const firstKey = notificationDataStore.keys().next().value;\n    if (firstKey) {\n      notificationDataStore.delete(firstKey);\n    }\n  }\n  notificationDataStore.set(id, push);\n}\n\n/**\n * Get notification store (for passing to utils)\n */\nexport function getNotificationStore(): Map<string, Push> {\n  return notificationDataStore;\n}\n\n// Initialize WebSocket client\nlet websocketClient: WebSocketClient | null = null;\n\n/**\n * Connect to WebSocket\n */\nfunction connectWebSocket(): void {\n  // Set connecting status\n  updateConnectionIcon('connecting');\n\n  // SECURITY FIX (H-02): Dispose existing socket before creating new one\n  if (websocketClient) {\n    debugLogger.websocket('INFO', 'Disposing existing WebSocket before reconnecting');\n    websocketClient.disconnect();\n    websocketClient = null;\n  }\n\n  websocketClient = new WebSocketClient(WEBSOCKET_URL, getApiKey);\n  setWebSocketClient(websocketClient);\n\n  // Set up handlers\n  websocketClient.setHandlers({\n      onTicklePush: async () => {\n        await refreshPushes(notificationDataStore);\n      },\n      onTickleDevice: async () => {\n        const apiKey = getApiKey();\n        if (apiKey) {\n          const devices = await fetchDevices(apiKey);\n          sessionCache.devices = devices;\n          sessionCache.lastUpdated = Date.now();\n\n          chrome.runtime.sendMessage({\n            action: 'sessionDataUpdated',\n            devices: devices,\n            userInfo: sessionCache.userInfo,\n            recentPushes: sessionCache.recentPushes,\n            autoOpenLinks: sessionCache.autoOpenLinks,\n            deviceNickname: sessionCache.deviceNickname\n          }).catch(() => {});\n        }\n      },\n      onPush: async (push: Push) => {\n        let decryptedPush = push;\n\n        // Check if push is encrypted\n        if ('encrypted' in push && push.encrypted && 'ciphertext' in push) {\n          try {\n            // Get encryption password from local storage\n            const result = await chrome.storage.local.get(['encryptionPassword']);\n            const password = result.encryptionPassword;\n\n            if (password && sessionCache.userInfo) {\n              debugLogger.general('INFO', 'Decrypting encrypted push', {\n                pushIden: push.iden\n              });\n\n              const decrypted = await PushbulletCrypto.decryptPush(\n                push as any,\n                password,\n                sessionCache.userInfo.iden\n              );\n\n              decryptedPush = decrypted as Push;\n              debugLogger.general('INFO', 'Push decrypted successfully', {\n                pushType: decryptedPush.type\n              });\n            } else {\n              debugLogger.general('WARN', 'Cannot decrypt push - no encryption password set');\n            }\n          } catch (error) {\n            debugLogger.general('ERROR', 'Failed to decrypt push', {\n              error: (error as Error).message\n            }, error as Error);\n          }\n        }\n\n        // Update cache (prepend)\n        if (sessionCache.recentPushes) {\n          sessionCache.recentPushes.unshift(decryptedPush);\n          sessionCache.lastUpdated = Date.now();\n\n          chrome.runtime.sendMessage({\n            action: 'pushesUpdated',\n            pushes: sessionCache.recentPushes\n          }).catch(() => {});\n        }\n\n        // FIX: Don't await - let notifications show immediately without blocking\n        // This allows multiple notifications to appear concurrently\n        showPushNotification(decryptedPush, notificationDataStore).catch((error) => {\n          debugLogger.general('ERROR', 'Failed to show notification', null, error);\n        });\n      },\n      onConnected: () => {\n        stopPollingMode();\n        updateConnectionIcon('connected');\n      },\n      onDisconnected: () => {\n        updateConnectionIcon('disconnected');\n      },\n      checkPollingMode: () => {\n        checkPollingMode();\n      },\n      stopPollingMode: () => {\n        stopPollingMode();\n      },\n      updatePopupConnectionState: (state: string) => {\n        updatePopupConnectionState(state);\n      }\n    });\n\n  websocketClient.connect();\n}\n\n/**\n * Disconnect WebSocket\n */\nfunction disconnectWebSocket(): void {\n  if (websocketClient) {\n    websocketClient.disconnect();\n  }\n}\n\n// ============================================================================\n// Chrome Event Listeners\n// ============================================================================\n\n/**\n * Extension installed/updated\n */\nchrome.runtime.onInstalled.addListener(() => {\n  debugLogger.general('INFO', 'Pushbullet extension installed/updated', {\n    reason: 'onInstalled',\n    timestamp: new Date().toISOString()\n  });\n\n  // Set initial icon to disconnected (with small delay to ensure Chrome is ready)\n  setTimeout(() => updateConnectionIcon('disconnected'), 100);\n\n  initTracker.recordInitialization('onInstalled');\n  setupContextMenu();\n  initializeSessionCache('onInstalled', connectWebSocket, {\n    setApiKey,\n    setDeviceIden,\n    setAutoOpenLinks,\n    setDeviceNickname,\n    setNotificationTimeout\n  });\n});\n\n/**\n * Browser startup\n */\nchrome.runtime.onStartup.addListener(() => {\n  debugLogger.general('INFO', 'Browser started - reinitializing Pushbullet extension', {\n    reason: 'onStartup',\n    timestamp: new Date().toISOString()\n  });\n\n  // Set initial icon to disconnected (with small delay to ensure Chrome is ready)\n  setTimeout(() => updateConnectionIcon('disconnected'), 100);\n\n  initTracker.recordInitialization('onStartup');\n  setupContextMenu();\n  initializeSessionCache('onStartup', connectWebSocket, {\n    setApiKey,\n    setDeviceIden,\n    setAutoOpenLinks,\n    setDeviceNickname,\n    setNotificationTimeout\n  });\n});\n\n/**\n * Notification click listener\n */\nchrome.notifications.onClicked.addListener((notificationId) => {\n  debugLogger.notifications('INFO', 'Notification clicked', { notificationId });\n\n  // Get push data from store\n  const pushData = notificationDataStore.get(notificationId);\n\n  if (pushData) {\n    // Open notification detail page in a new window\n    chrome.windows.create({\n      url: `notification-detail.html?id=${encodeURIComponent(notificationId)}`,\n      type: 'popup',\n      width: 600,\n      height: 500,\n      focused: true\n    });\n  }\n\n  // Clear the notification\n  chrome.notifications.clear(notificationId);\n});\n\n/**\n * Alarm listener\n */\nchrome.alarms.onAlarm.addListener((alarm) => {\n  if (alarm.name === 'websocketReconnect' && getApiKey()) {\n    debugLogger.websocket('INFO', 'Reconnection alarm triggered', {\n      alarmName: alarm.name,\n      hasApiKey: !!getApiKey(),\n      scheduledTime: alarm.scheduledTime ? new Date(alarm.scheduledTime).toISOString() : 'unknown'\n    });\n    connectWebSocket();\n  } else if (alarm.name === 'websocketReconnect') {\n    debugLogger.websocket('WARN', 'Reconnection alarm triggered but no API key available');\n  } else if (alarm.name === 'websocketHealthCheck') {\n    performWebSocketHealthCheck(websocketClient, connectWebSocket);\n  } else if (alarm.name === 'pollingFallback') {\n    performPollingFetch();\n  }\n});\n\n/**\n * Context menu click handler\n */\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (!getApiKey()) {\n    chrome.notifications.create('pushbullet-no-api-key', {\n      type: 'basic',\n      iconUrl: 'icons/icon128.png',\n      title: 'Pushbullet',\n      message: 'Please set your API key in the extension popup'\n    });\n    return;\n  }\n\n  switch (info.menuItemId) {\n    case 'push-link':\n      if (info.linkUrl && tab) {\n        pushLink(info.linkUrl, tab.title);\n      }\n      break;\n    case 'push-page':\n      if (tab && tab.url) {\n        pushLink(tab.url, tab.title);\n      }\n      break;\n    case 'push-selection':\n      if (info.selectionText && tab) {\n        pushNote('Selection from ' + (tab.title || 'page'), info.selectionText);\n      }\n      break;\n    case 'push-image':\n      if (info.srcUrl && tab) {\n        pushLink(info.srcUrl, 'Image from ' + (tab.title || 'page'));\n      }\n      break;\n  }\n});\n\n/**\n * Message listener for popup communication\n */\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  debugLogger.general('DEBUG', 'Message received from popup', {\n    action: message.action,\n    hasApiKey: !!message.apiKey,\n    timestamp: new Date().toISOString()\n  });\n\n  // SECURITY FIX (C-04): Validate sender for privileged actions\n  // Prevents external extensions/pages from sending privileged messages\n  if (!validatePrivilegedMessage(message.action, sender)) {\n    debugLogger.general('ERROR', 'Rejected privileged message from untrusted sender', {\n      action: message.action,\n      senderId: sender?.id,\n      senderUrl: sender?.url\n    });\n    sendResponse({ success: false, error: 'Unauthorized' });\n    return false;\n  }\n\n  if (message.action === 'getSessionData') {\n    // Detect service worker wake-up: if we have an API key but session cache is not initialized\n    const apiKey = getApiKey();\n    if (apiKey && !sessionCache.isAuthenticated && sessionCache.lastUpdated === 0) {\n      // Check if initialization is already in progress\n      if (initializationState.inProgress) {\n        debugLogger.general('DEBUG', 'Initialization already in progress - waiting for completion');\n\n        // Wait for initialization to complete (max 10 seconds)\n        const maxWait = 10000;\n        const startTime = Date.now();\n        const checkInterval = setInterval(() => {\n          if (initializationState.completed || Date.now() - startTime > maxWait) {\n            clearInterval(checkInterval);\n            sendResponse({\n              isAuthenticated: sessionCache.isAuthenticated,\n              userInfo: sessionCache.userInfo,\n              devices: sessionCache.devices,\n              recentPushes: sessionCache.recentPushes,\n              autoOpenLinks: sessionCache.autoOpenLinks,\n              deviceNickname: sessionCache.deviceNickname,\n              websocketConnected: websocketClient ? websocketClient.isConnected() : false\n            });\n          }\n        }, 100);\n        return true; // Keep message channel open\n      }\n\n      debugLogger.general('WARN', 'Service worker wake-up detected - session cache not initialized', {\n        hasApiKey: !!apiKey,\n        isAuthenticated: sessionCache.isAuthenticated,\n        lastUpdated: sessionCache.lastUpdated\n      });\n\n      // Ensure config is loaded\n      ensureConfigLoaded(\n        { setApiKey, setDeviceIden, setAutoOpenLinks, setDeviceNickname, setNotificationTimeout },\n        { getApiKey, getDeviceIden, getAutoOpenLinks, getDeviceNickname, getNotificationTimeout }\n      ).then(() => {\n        // Re-initialize session cache\n        initializeSessionCache('onMessage', connectWebSocket, {\n          setApiKey,\n          setDeviceIden,\n          setAutoOpenLinks,\n          setDeviceNickname,\n          setNotificationTimeout\n        }).then(() => {\n          sendResponse({\n            isAuthenticated: true,\n            userInfo: sessionCache.userInfo,\n            devices: sessionCache.devices,\n            recentPushes: sessionCache.recentPushes,\n            autoOpenLinks: sessionCache.autoOpenLinks,\n            deviceNickname: sessionCache.deviceNickname,\n            websocketConnected: websocketClient ? websocketClient.isConnected() : false\n          });\n        }).catch((error) => {\n          debugLogger.general('ERROR', 'Error re-initializing session cache', null, error);\n          sendResponse({ isAuthenticated: false });\n        });\n      });\n\n      return true; // Async response\n    }\n\n    // Check if session cache is stale (older than 5 minutes)\n    const isStale = sessionCache.lastUpdated > 0 && (Date.now() - sessionCache.lastUpdated) > 300000;\n\n    if (sessionCache.isAuthenticated && !isStale) {\n      // Return cached session data\n      sendResponse({\n        isAuthenticated: true,\n        userInfo: sessionCache.userInfo,\n        devices: sessionCache.devices,\n        recentPushes: sessionCache.recentPushes,\n        autoOpenLinks: sessionCache.autoOpenLinks,\n        deviceNickname: sessionCache.deviceNickname,\n        websocketConnected: websocketClient ? websocketClient.isConnected() : false\n      });\n    } else if (sessionCache.isAuthenticated && isStale) {\n      // Refresh session cache in the background\n      const apiKey = getApiKey();\n      if (apiKey) {\n        refreshSessionCache(apiKey).then(() => {\n          sendResponse({\n            isAuthenticated: true,\n            userInfo: sessionCache.userInfo,\n            devices: sessionCache.devices,\n            recentPushes: sessionCache.recentPushes,\n            autoOpenLinks: sessionCache.autoOpenLinks,\n            deviceNickname: sessionCache.deviceNickname,\n            websocketConnected: websocketClient ? websocketClient.isConnected() : false\n          });\n        }).catch((error) => {\n          debugLogger.general('ERROR', 'Error refreshing session cache', null, error);\n          sendResponse({ isAuthenticated: false });\n        });\n\n        return true; // Async response\n      }\n    } else {\n      // Not authenticated\n      sendResponse({ isAuthenticated: false });\n    }\n  } else if (message.action === 'apiKeyChanged') {\n    // Update API key\n    setApiKey(message.apiKey);\n\n    // Save API key to storage (plain text)\n    chrome.storage.sync.set({ apiKey: message.apiKey });\n\n    // Update device nickname if provided\n    if (message.deviceNickname) {\n      setDeviceNickname(message.deviceNickname);\n      sessionCache.deviceNickname = message.deviceNickname;\n      chrome.storage.local.set({ deviceNickname: message.deviceNickname });\n    }\n\n    // Refresh session cache\n    refreshSessionCache(message.apiKey).then(() => {\n      // Notify popup that session data has been updated\n      chrome.runtime.sendMessage({\n        action: 'sessionDataUpdated',\n        isAuthenticated: true,\n        userInfo: sessionCache.userInfo,\n        devices: sessionCache.devices,\n        recentPushes: sessionCache.recentPushes,\n        autoOpenLinks: sessionCache.autoOpenLinks,\n        deviceNickname: sessionCache.deviceNickname\n      });\n    }).catch((error) => {\n      debugLogger.general('ERROR', 'Error refreshing session cache after API key change', null, error);\n    });\n\n    // Connect WebSocket\n    connectWebSocket();\n\n    sendResponse({ success: true });\n  } else if (message.action === 'logout') {\n    // Clear API key and session data\n    setApiKey(null);\n    setDeviceIden(null);\n    sessionCache.isAuthenticated = false;\n    sessionCache.userInfo = null;\n    sessionCache.devices = [];\n    sessionCache.recentPushes = [];\n\n    // Clear storage\n    chrome.storage.sync.remove(['apiKey']);\n    chrome.storage.local.remove(['deviceIden']);\n\n    // Disconnect WebSocket\n    disconnectWebSocket();\n\n    sendResponse({ success: true });\n  } else if (message.action === 'refreshSession') {\n    const apiKey = getApiKey();\n    if (apiKey) {\n      refreshSessionCache(apiKey).then(() => {\n        sendResponse({\n          isAuthenticated: true,\n          userInfo: sessionCache.userInfo,\n          devices: sessionCache.devices,\n          recentPushes: sessionCache.recentPushes,\n          autoOpenLinks: sessionCache.autoOpenLinks,\n          deviceNickname: sessionCache.deviceNickname\n        });\n      }).catch((error) => {\n        debugLogger.general('ERROR', 'Error refreshing session', null, error);\n        sendResponse({ isAuthenticated: false });\n      });\n\n      return true; // Async response\n    } else {\n      sendResponse({ isAuthenticated: false });\n    }\n  } else if (message.action === 'settingsChanged') {\n    if (message.autoOpenLinks !== undefined) {\n      setAutoOpenLinks(message.autoOpenLinks);\n      sessionCache.autoOpenLinks = message.autoOpenLinks;\n      chrome.storage.sync.set({ autoOpenLinks: message.autoOpenLinks });\n    }\n\n    if (message.notificationTimeout !== undefined) {\n      setNotificationTimeout(message.notificationTimeout);\n      chrome.storage.sync.set({ notificationTimeout: message.notificationTimeout });\n    }\n\n    sendResponse({ success: true });\n  } else if (message.action === 'updateDeviceNickname') {\n    const apiKey = getApiKey();\n    const deviceIden = getDeviceIden();\n\n    if (apiKey && deviceIden && message.nickname) {\n      updateDeviceNickname(apiKey, deviceIden, message.nickname).then(() => {\n        setDeviceNickname(message.nickname);\n        sessionCache.deviceNickname = message.nickname;\n        chrome.storage.sync.set({ deviceNickname: message.nickname });\n\n        sendResponse({ success: true });\n      }).catch((error) => {\n        debugLogger.general('ERROR', 'Error updating device nickname', null, error);\n        sendResponse({ success: false, error: error.message });\n      });\n\n      return true; // Async response\n    } else {\n      sendResponse({ success: false, error: 'Missing required parameters' });\n    }\n  } else if (message.action === 'getDebugSummary') {\n    // Return debug summary for debug dashboard\n    const logData = debugLogger.exportLogs();\n    const wsState = wsStateMonitor.getStateReport();\n\n    // Format websocket state for dashboard compatibility\n    const websocketState = {\n      current: {\n        stateText: websocketClient ? (websocketClient.isConnected() ? 'Connected' : 'Disconnected') : 'Not initialized',\n        readyState: wsState.currentState\n      },\n      lastCheck: wsState.lastCheck,\n      historyLength: wsState.historyLength\n    };\n\n    const summary = {\n      config: debugConfigManager.getConfig(),\n      logs: logData.logs, // Array of log entries\n      totalLogs: logData.summary.totalLogs,\n      performance: performanceMonitor.exportPerformanceData(),\n      websocketState: websocketState,\n      initializationStats: initTracker.exportData(),\n      errors: {\n        total: logData.summary.errors,\n        last24h: logData.summary.errors, // Add last24h for dashboard\n        critical: []\n      }\n    };\n\n    debugLogger.general('DEBUG', 'Sending debug summary', {\n      totalLogs: summary.totalLogs,\n      hasConfig: !!summary.config,\n      hasPerformance: !!summary.performance,\n      websocketStateText: websocketState.current.stateText\n    });\n\n    sendResponse({ success: true, summary });\n    return false; // Synchronous response\n  } else if (message.action === 'getNotificationData') {\n    // Return notification data for detail view\n    const pushData = notificationDataStore.get(message.notificationId);\n    if (pushData) {\n      sendResponse({ success: true, push: pushData });\n    } else {\n      sendResponse({ success: false, error: 'Notification not found' });\n    }\n    return false; // Synchronous response\n  }\n\n  return false;\n});\n\n// Export debug info function for console access\n(globalThis as any).exportDebugInfo = function() {\n  return {\n    debugLogs: debugLogger.exportLogs(),\n    performanceData: performanceMonitor.exportPerformanceData(),\n    websocketState: wsStateMonitor.getStateReport(),\n    initializationData: initTracker.exportData(),\n    sessionCache: {\n      isAuthenticated: sessionCache.isAuthenticated,\n      lastUpdated: sessionCache.lastUpdated ? new Date(sessionCache.lastUpdated).toISOString() : 'never',\n      userInfo: sessionCache.userInfo ? { email: sessionCache.userInfo.email?.substring(0, 3) + '***' } : null,\n      deviceCount: sessionCache.devices?.length || 0,\n      pushCount: sessionCache.recentPushes?.length || 0\n    },\n    websocketConnected: websocketClient ? websocketClient.isConnected() : false,\n    initializationState: {\n      inProgress: initializationState.inProgress,\n      completed: initializationState.completed,\n      timestamp: initializationState.timestamp ? new Date(initializationState.timestamp).toISOString() : null,\n      hasError: !!initializationState.error\n    }\n  };\n};\n\ndebugLogger.general('INFO', 'Background service worker initialized', {\n  timestamp: new Date().toISOString()\n});\n\n"],
  "mappings": "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",
  "names": ["getApiKey", "apiKey", "apiKey", "deviceIden", "deviceNickname", "API_BASE_URL", "PUSHES_URL", "DEVICES_URL", "USER_INFO_URL", "notificationDataStore", "apiKey", "websocketClient", "apiKey", "deviceIden"]
}
